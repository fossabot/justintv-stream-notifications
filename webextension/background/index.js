/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 55);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Concurrency utils for events.
 *
 * @author Martin Giger
 * @license MPL-2.0
 */

const when = (target, event) => {
    if (target instanceof EventTarget) {
        return new Promise(resolve => {
            target.addEventListener(event, resolve, {
                once: true,
                capture: false
            });
        });
    } else if ("on" + event[0].toUpperCase() + event.substr(1) in target) {
        return new Promise(resolve => {
            const property = "on" + event[0].toUpperCase() + event.substr(1),
                  listener = e => {
                target[property].removeListener(listener);
                resolve(e);
            };
            target[property].addListener(listener);
        });
    }
    return Promise.resolve();
};
/* harmony export (immutable) */ __webpack_exports__["d"] = when;


const emit = (target, event, ...detail) => {
    if (detail.length) {
        if (detail.length == 1) {
            detail = detail[0];
        }
        target.dispatchEvent(new CustomEvent(event, { detail }));
    } else {
        target.dispatchEvent(new Event(event));
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = emit;


/**
 * So this is a magic function. It makes things work by being kind of a reversed
 * once. But let me explain: this function will only execute the function if it
 * is the most recently registered one. The first argument has to be an unique
 * id, which is used to check if the callback is the most recent one.
 * This is used to avoid race conditions with DB callbacks when channels are
 * deleted.
 *
 * @param {*} newId - An id for this new callback.
 * @param {Function} fn - Needs to be the same callback to work.
 * @returns {Function} Function that is "debounced".
 */
const invokeOnce = (newId, fn) => {
    fn.currentId = newId;
    return function (...args) {
        if (fn.currentId == newId) {
            delete fn.currentId;
            fn(...args);
        }
    };
};
/* harmony export (immutable) */ __webpack_exports__["c"] = invokeOnce;


/**
 * Filter an array based on a condition that is returned as promise.
 * Like Array.prototype.filter, just that it takes a promise from the callback
 * instead of a boolean.
 *
 * @param {Array} array - Array to filter.
 * @param {Function} callback - Callback to filter on. Should return a promise.
 * @returns {Array} Array filtered based on the result of the callback.
 */
const filterAsync = async (array, callback) => {
    const predicates = await Promise.all(array.map(callback));
    return array.filter((a, i) => predicates[i]);
};
/* harmony export (immutable) */ __webpack_exports__["b"] = filterAsync;


/**
 * Pipe an event from one target to another.
 *
 * @param {module:event-target.EventTarget} source - Object emitting the event.
 * @param {string} event - Event to pipe through.
 * @param {module:event-target.EventTarget} target - Target to pipe to.
 * @returns {undefined}
 */
const pipe = (source, event, target) => {
    source.addEventListener(event, e => target.dispatchEvent(e), { passive: true });
};
/* harmony export (immutable) */ __webpack_exports__["e"] = pipe;


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_underscore__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_underscore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_underscore__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__live_state__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Channel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return User; });
/**
 * Channel and User Objects.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/core
 */



const ITEM_ARGS = ["login", "type", "id", "live"];

/**
 * A generic thing.
 * @class
 */
class Item {
    /**
     * @param {string} login - Unique login name.
     * @param {string} type - Provider name.
     * @param {number} [id] - Extension internal ID if already known.
     */
    constructor(login, type, id) {
        this._uname = "";

        this._login = login;
        this._type = type;
        /**
         * An object with user avatars, by their size in pixels as property name.
         * @type {Object.<(string|number)>}
         */
        this.image = {};
        if (id) {
            this.id = id;
        }
    }
    /**
     * The human-readable name of the user.
     *
     * @type {string}
     * @default Value of {@link module:channel/core~Item#login}
     */
    get uname() {
        if (this._uname !== "") {
            return this._uname;
        } else {
            return this.login;
        }
    }
    set uname(val) {
        if (val) {
            this._uname = val;
        }
    }
    /**
     * The login name of the user, this should be a unique string or number within
     * the provider.
     *
     * @type {string|number}
     * @readonly
     */
    get login() {
        return this._login;
    }
    /**
     * The provider type this user is from.
     *
     * @type {string}
     * @readonly
     */
    get type() {
        return this._type;
    }
    //methods
    /**
     * Retuns the URL to the best image for displaying at the specified size.
     *
     * @param {string|number} size - The size the image will be displayed in in pixels.
     * @returns {string} An URL to an image.
     */
    getBestImageForSize(size) {
        size = Math.round(parseInt(size, 10) * window.devicePixelRatio);
        // shortcut if there's an image with the size demanded
        if (this.image.hasOwnProperty(size.toString())) {
            return this.image[size];
        }

        // search next biggest image
        let index = Number.MAX_VALUE,
            biggest = 0;
        Object.keys(this.image).forEach(s => {
            s = parseInt(s, 10);
            if (s > size && s < index) {
                index = s;
            }
            if (s > biggest) {
                biggest = s;
            }
        });

        if (index > biggest) {
            index = biggest;
        }

        return this.image[index];
    }

    /**
     * @returns {string} The human-readable name of the user with the first
     *          letter capitalized.
     */
    toString() {
        return this.uname.charAt(0).toUpperCase() + this.uname.slice(1);
    }
    /**
     * Serialized version of {@link module:channel/core~Item}
     *
     * @typedef {Object} SerializedItem
     * @property {string} uname
     * @property {string} login
     * @property {Object.<(string|number),string>} image
     * @property {string} type
     * @property {number} [id]
     */

    /**
     * Serialize the item into a normal object.
     *
     * @returns {module:channel/core~SerializedItem} A JSON serializable version
     *          of this item.
     */
    serialize() {
        const obj = {
            uname: this.uname,
            login: this.login,
            image: this.image,
            type: this.type
        };
        if (this.id) {
            obj.id = this.id;
        }
        return obj;
    }
}

/**
 * A generic user.
 *
 * @extends module:channel/core~Item
 */
class User extends Item {
    /**
     * @param {module:channel/core~SerializedUser} properties - Serialized object
     *        to turn into a user.
     * @returns {module:channel/core.User} User based on the serialized object.
     */
    static deserialize(properties) {
        const props = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_underscore__["omit"])(properties, ITEM_ARGS);
        props._uname = properties.uname;
        return Object.assign(new User(...ITEM_ARGS.map(a => properties[a])), props);
    }

    /**
     * @param {string} login - Login of the user.
     * @param {string} type - Type/Provider of the user.
     * @param {number} [id] - ID of the user.
     */
    constructor(login, type, id) {
        super(login, type, id);

        /**
         * The favorite channels of this user as an array of logins.
         * @type {Array.<string>}
         */
        this.favorites = [];
    }
    /**
     * Serialized version of {@link module:channel/core.User}.
     *
     * @typedef {module:channel/core~SerializedItem} SerializedUser
     * @property {Array.<string>} favorites
     */
    /**
     * Serialize the user into a normal object.
     *
     * @returns {module:channel/core~SerializedUser} A JSON serializable version
     *          of this user.
     */
    serialize() {
        return Object.assign(super.serialize(), {
            favorites: this.favorites
        });
    }
}

/**
 * A generic Channel object.
 *
 * @extends module:channel/core~Item
 */
class Channel extends Item {
    /**
     * @param {module:channel/core~SerializedChannel} properties - Serialzed object
     *        to deserialize into a channel.
     * @returns {module:channel/core.Channel} Deserialized channel based on the
     *          object.
     */
    static deserialize(properties) {
        const props = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_underscore__["omit"])(properties, ITEM_ARGS);
        props._uname = properties.uname;
        return Object.assign(new Channel(...ITEM_ARGS.map(a => properties[a])), props);
    }

    /**
     * The title of the live broadcast.
     *
     * @type {string}
     * @default ''
     */

    /**
     * The number of viewers of the live broadcast, -1 if unknown.
     *
     * @type {number}
     * @default -1
     */

    /**
     * Thumbnail of the live broadcast. Typically displayed at a width of 320px.
     *
     * @type {string}
     * @default ''
     */

    /**
     * A URL pointing to a page listing past broadcasts. Opened when clicked on the
     * channel while offline.
     *
     * @type {string}
     * @default ''
     */

    /**
     * A URL to a page containing only the chat for a broadcast.
     *
     * @type {string}
     * @default ''
     */

    /**
     * A UNIX timestamp, automatically set by the ChannelList.
     *
     * @type {number}
     * @readonly
     * @default Date.now()
     */

    /**
     * The category of the live broadcast if known.
     *
     * @type {string}
     * @default ''
     */

    /**
     * If the channel's content is rated mature. Only true if the content rating
     * is known and it is for mature audiences.
     *
     * @type {boolean}
     * @default false
     */


    /**
     * @param {string} login - Login of the channel.
     * @param {string} type - Type/Provider of the channel.
     * @param {number} [id] - ID of the channel.
     * @param {module:channel/live-state~SerializedLiveState} [state] - Live state
     *        of the channel.
     */
    constructor(login, type, id, state) {
        super(login, type, id);

        /**
         * An array of URLs that will contain a player of the stream. The first one is
         * treated as the main channel page and opened when the user clicks on the
         * stream.
         * @type {Array.<string>}
         */
        this.title = '';
        this.viewers = -1;
        this.thumbnail = '';
        this.archiveUrl = '';
        this.chatUrl = '';
        this.lastModified = 0;
        this.category = '';
        this.mature = false;
        this.url = [];

        this.lastModified = Date.now();
        if (state) {
            this.live = __WEBPACK_IMPORTED_MODULE_1__live_state__["a" /* default */].deserialize(state);
        } else {
            this.live = new __WEBPACK_IMPORTED_MODULE_1__live_state__["a" /* default */]();
        }
    }
    // properties
    /**
     * @type {module:channel/live-state.LiveState}
     * @default null
     */
    get live() {
        return this._live;
    }
    set live(val) {
        if (val instanceof __WEBPACK_IMPORTED_MODULE_1__live_state__["a" /* default */]) {
            this._live = val;
        } else {
            throw new TypeError("Trying to set the live state to something that isn't a LiveState");
        }
    }
    /**
     * Serialized version of {@link module:channel/core.Channel}.
     *
     * @typedef {module:channel/core~SerializedItem} SerializedChannel
     * @property {string} title
     * @property {number} viewers
     * @property {string} thumbnail
     * @property {Array.<string>} url
     * @property {string} archiveUrl
     * @property {string} chatUrl
     * @property {number} lastModified
     * @property {string} category
     * @property {string} intent
     * @proeprty {boolean} mature
     * @property {module:channel/live-state~SerializedLiveState} live
     */
    /**
     * Serialize the item into a normal object.
     *
     * @returns {module:channel/core~SerializedChannel} A JSON serializable
     *          version of this channel.
     */
    serialize() {
        return Object.assign(super.serialize(), {
            title: this.title,
            viewers: this.viewers,
            thumbnail: this.thumbnail,
            url: this.url,
            archiveUrl: this.archiveUrl,
            chatUrl: this.chatUrl,
            lastModified: this.lastModified,
            category: this.category,
            mature: this.mature,
            live: this.live.serialize()
        });
    }
}



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sdk__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_event_target_shim__);




//TODO move to storage.local & options_ui

class Preferences extends __WEBPACK_IMPORTED_MODULE_2_event_target_shim___default.a {
    constructor() {
        super();
        __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].addEventListener("message", ({ detail: message }) => {
            if (message.target == "pref-change") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* emit */])(this, "change", message);
            }
        });
    }

    get(pref) {
        if (Array.isArray(pref)) {
            return Promise.all(pref.map(p => this.get(p)));
        } else {
            return __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].doAction({
                target: "get-pref-" + pref,
                pref
            });
        }
    }

    set(pref, value) {
        return __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].doAction({
            target: "set-pref-" + pref,
            pref,
            value
        });
    }

    open() {
        __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].postMessage({
            target: "pref-open"
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = new Preferences();

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parental_controls__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__queue_service__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_event_target_shim__);
/* eslint-disable no-unused-vars */
/**
 * A generic provider class
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/generic-provider
 * @requires module:queue/service
 */





const _ = browser.i18n.getMessage,
      methodNotSupported = (type, method) => Promise.reject(type + "." + method + " is not supported"),
      queues = new WeakMap(),
      queueFor = provider => queues.get(provider);

/**
 * @event module:providers/generic-provider.GenericProvider#updateduser
 * @type {module:channel/core.User}
 */
/**
 * @event module:providers/generic-provider.GenericProvider#newchannels
 * @type {Array.<module:channel/core.Channel>}
 */
/**
 * @event module:providers/generic-provider.GenericProvider#updatedchannels
 * @type {Array.<module:channel/core.Channel>|module:channel/core.Channel}
 */

/**
 * @extends external:Error
 */
class ProviderError extends Error {
    constructor(code) {
        let message;
        switch (code) {
            case 1:
                message = "The API did not accept the given request format";break;
            case 2:
                message = "Could not access the requested resource";break;
            case 3:
                message = "Could not find any result for the given username";break;
            default:
                message = "Could not load the requested resource";break;
        }
        super(message);
        this.code = code;
        this.name = "ProviderError";
    }
}

/**
 * @class
 * @extends module:disposable-target.Disposable
 */
class GenericProvider extends __WEBPACK_IMPORTED_MODULE_3_event_target_shim___default.a {
    static get NETWORK_ERROR() {
        return new ProviderError(0);
    }
    static get API_ERROR() {
        return new ProviderError(1);
    }
    static get ACCESS_ERROR() {
        return new ProviderError(2);
    }
    static get NORESULT_ERROR() {
        return new ProviderError(3);
    }
    static getErrorByHTTPCode(code) {
        switch (code) {
            case 404:
            case 410:
            case 415:
            case 422:
                return this.NORESULT_ERROR;
            case 401:
            case 403:
            case 511:
                return this.ACCESS_ERROR;
            case 500:
            case 501:
            case 502:
            case 504:
            case 506:
            case 507:
            case 508:
            case 510:
            case 429:
                return this.API_ERROR;
            default:
                return this.NETWORK_ERROR;
        }
    }

    /**
     * Internal property if the provider can get the favorites of a user.
     *
     * @type {boolean}
     * @protected
     * @default false
     */

    /**
     * Internal property specifying, if the provider can get the favorites
     * of a user based on stored credentials. The credentials checked are
     * for the URLs in the array the
     * {@link module:providers/generic-provider.GenericProvider#authURL}
     * property specifies.
     *
     * @type {boolean}
     * @protected
     * @default false
     */

    /**
     * Internal property specifying, if the provider can get a featured
     * channel on the platform.
     *
     * @type {boolean}
     * @protected
     * @default false
     */

    /**
     * The value of enabled.
     *
     * @type {boolean}
     * @protected
     * @readonly
     * @default true
     */


    /**
     * Array of URLs to search credentials for.
     *
     * @abstract
     * @type {Array.<string>}
     */


    /**
     * Generic base-class for all providers. Implements common patterns and helpers.
     *
     * @constructs
     * @param {string} type - Provider type descriptor.
     */
    constructor(type) {
        super();
        /**
         * The type specified to the constructor.
         *
         * @type {string}
         * @protected
         */
        this._supportsFavorites = false;
        this._supportsCredentials = false;
        this._supportsFeatured = false;
        this._enabled = true;
        this._type = type;

        queues.set(this, __WEBPACK_IMPORTED_MODULE_2__queue_service__["f" /* getServiceForProvider */](this._type));
    }
    /**
     * An instance of the QueueService for this provider.
     *
     * @type {queueservice.QueueService}
     * @protected
     * @readonly
     */
    get _qs() {
        return queueFor(this);
    }
    // For testing.
    _setQs(val) {
        queues.set(this, val);
    }
    /**
     * Indicates if exploring features should hold mature results. Respects
     * parental control settings of the OS.
     *
     * @returns {boolean} Explore features should hold mature results if true.
     * @protected
     * @async
     */
    _mature() {
        return __WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].get("find_mature").then(value => value && !__WEBPACK_IMPORTED_MODULE_1__parental_controls__["a" /* default */].enabled);
    }
    /**
     * If the provider is fully functional and should be enabled. Makes it
     * impossible to add new channels and users and disables the update
     * request queueing. Existing channels will be kept around, and could
     * still be updated. getChannelDetails is also expected to return a
     * channel that at least sets the login.
     *
     * @type {boolean}
     * @readonly
     */
    get enabled() {
        return this._enabled;
    }
    /**
     * The human readable name of this provider, by default looks for a
     * translated string with the id "provider_type" where type is the value of
     * _type.
     *
     * @type {string}
     * @readonly
     */
    get name() {
        return _("provider" + this._type);
    }
    /**
     * @returns {string} Localized name of the provider.
     * @see {@link module:providers/generic-provider.GenericProvider#name}
     */
    toString() {
        return this.name;
    }
    /**
     * Frozen
     *
     * @typedef {Object} ProviderSupports
     * @property {boolean} favorites - Provider supports getting a user's favorites
     * @property {boolean} credentials - Provider supports credential based auto-detect of users
     * @property {boolean} featured - Provider supports getting featured channels and search
     */
    /**
     * An object based on the _supports properties.
     *
     * @type {module:providers/generic-provider~ProviderSupports}
     * @readonly
     */
    get supports() {
        return Object.freeze({
            favorites: this._supportsFavorites && this._enabled,
            credentials: this._supportsCredentials && this._enabled,
            featured: this._supportsFeatured && this._enabled
        });
    }
    /**
     * Get the favorite channels of a user. Also called the followed channels.
     *
     * @async
     * @param {string} username - The username of the user on the platform
     *                            (as entered by the user in the channels
     *                            manager).
     * @returns {Array} A promise that resolves to an array with to elements in
     *          this order:
     *            - the user (an instance of a User object).
     *            - the favorite channels, an array of Channels objects.
     * @abstract
     */
    getUserFavorites(username) {
        return methodNotSupported(this.name, "getUserFavorites");
    }
    /**
     * Get a Channel object without the requirement of any live metadata.
     *
     * @async
     * @param {string} channelname - The username of the channel to return
     *                         (as entered by the user in the channels manager).
     * @returns {module:channel/core.Channel} Channel object with at least
     *          username, type, image and urls set.
     * @abstract
     */
    getChannelDetails(channelname) {
        return methodNotSupported(this.name, "getChannelDetails");
    }
    /**
     * Queues a reocurring update request for updating the favorite channels
     * of the users.
     *
     * @param {Array.<module:channel/core.User>} users - Users to update the
     *                                                   favorites of.
     * @fires module:providers/generic-provider.GenericProvider#updateduser
     * @fires module:providers/generic-provider.GenericProvider#newchannels
     * @abstract
     * @returns {undefined}
     */
    updateFavsRequest(users) {
        throw this.name + ".updateFavsRequest is not supported.";
    }
    /**
     * Unqueues the reocurring update request for updating the favorite
     * channels of the users.
     *
     * @returns {undefined}
     */
    removeFavsRequest() {
        this._qs.unqueueUpdateRequest(this._qs.LOW_PRIORITY);
    }
    /**
     * Queues a reocurring update request for updating the live status of all
     * channels for this provider.
     *
     * @param {Array.<module:channel/core.Channel>} channels - The Channel
     *                                                        objects to update.
     * @fires module:providers/generic-provider.GenericProvider#updatedchannels
     * @abstract
     * @returns {undefined}
     */
    updateRequest(channels) {
        throw this.name + ".updateRequest is not supported.";
    }
    /**
     * Unqueues the reocurring update request for updating the live status of
     * all channels for this provider.
     *
     * @returns {undefined}
     */
    removeRequest() {
        this._qs.unqueueUpdateRequest(this._qs.HIGH_PRIORITY);
    }
    /**
     * Updates all info for a channel, including its live metadata. By default
     * just calls {@link module:providers/generic-provider.GenericProvider#getChannelDetails}.
     *
     * @async
     * @param {string} channelname - The login of the channel.
     * @returns {module:channel/core.Channel} Updated Channel object.
     */
    updateChannel(channelname) {
        return this.getChannelDetails(channelname);
    }
    /**
     * Updates the information for an array of Channel objects, including
     * their live metadata. The default implementation calls
     * {@link module:providers/generic-provider.GenericProvider#updateChannel}
     * for each item.
     *
     * @async
     * @param {Array.<module:channel/core.Channel>} channels - An array of
     *                                                      channel objects.
     * @returns {Array.<module:channel/core.Channel>} Updated Channel objects.
     */
    updateChannels(channels) {
        return Promise.all(channels.map(channel => this.updateChannel(channel.login)));
    }
    /**
     * Returns channels the provider is featuring. Results should be
     * filtered if _mature is false. By default calls
     * {@link module:providers/generic-provider.GenericProvider#search} with
     * an empty string as argument.
     *
     * @async
     * @returns {Array.<module:channel/core.Channel>} An array of featured
     *                                                channels.
     * @see {@link module:lib/providers/generic-provider.GenericProvider#_mature}
     */
    getFeaturedChannels() {
        return this.search("");
    }
    /**
     * Search for live channels. Results should be filtered if _mature is
     * false.
     *
     * @async
     * @param {string} query - A string to search for.
     * @returns {Array.<module:channel/core.Channel>} An array of channels
     *                                                matching the query.
     * @abstract
     * @see {@link module:lib/providers/generic-provider.GenericProvider#_mature}
     */
    search(query) {
        return methodNotSupported(this.name, "search");
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GenericProvider;

GenericProvider.authURL = [];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

/*globals window */

var Commons = __webpack_require__(18)
var CustomEventTarget = __webpack_require__(51)
var EventWrapper = __webpack_require__(52)
var isObject = Commons.isObject
var LISTENERS = Commons.LISTENERS
var CAPTURE = Commons.CAPTURE
var BUBBLE = Commons.BUBBLE
var ATTRIBUTE = Commons.ATTRIBUTE
var newNode = Commons.newNode
var defineCustomEventTarget = CustomEventTarget.defineCustomEventTarget
var createEventWrapper = EventWrapper.createEventWrapper
var STOP_IMMEDIATE_PROPAGATION_FLAG = EventWrapper.STOP_IMMEDIATE_PROPAGATION_FLAG
var PASSIVE_LISTENER_FLAG = EventWrapper.PASSIVE_LISTENER_FLAG

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

/**
 * A flag which shows there is the native `EventTarget` interface object.
 *
 * @type {boolean}
 * @private
 */
var HAS_EVENTTARGET_INTERFACE = (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
)

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * An implementation for `EventTarget` interface.
 *
 * @constructor
 * @public
 */
var EventTarget = module.exports = function EventTarget() {
    if (this instanceof EventTarget) {
        // this[LISTENERS] is a Map.
        // Its key is event type.
        // Its value is ListenerNode object or null.
        //
        // interface ListenerNode {
        //     var listener: Function
        //     var kind: CAPTURE|BUBBLE|ATTRIBUTE
        //     var next: ListenerNode|null
        // }
        Object.defineProperty(this, LISTENERS, {value: Object.create(null)})
    }
    else if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(EventTarget, arguments[0])
    }
    else if (arguments.length > 0) {
        var types = Array(arguments.length)
        for (var i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i]
        }

        // To use to extend with attribute listener properties.
        // e.g.
        //     class MyCustomObject extends EventTarget("message", "error") {
        //         //...
        //     }
        return defineCustomEventTarget(EventTarget, types)
    }
    else {
        throw new TypeError("Cannot call a class as a function")
    }
}

EventTarget.prototype = Object.create(
    (HAS_EVENTTARGET_INTERFACE ? window.EventTarget : Object).prototype,
    {
        constructor: {
            value: EventTarget,
            writable: true,
            configurable: true,
        },

        addEventListener: {
            value: function addEventListener(type, listener, options) {
                if (listener == null) {
                    return false
                }
                if (typeof listener !== "function" && typeof listener !== "object") {
                    throw new TypeError("\"listener\" is not an object.")
                }

                var capture = isObject(options) ? Boolean(options.capture) : Boolean(options)
                var kind = (capture ? CAPTURE : BUBBLE)
                var node = this[LISTENERS][type]
                if (node == null) {
                    this[LISTENERS][type] = newNode(listener, kind, options)
                    return true
                }

                var prev = null
                while (node != null) {
                    if (node.listener === listener && node.kind === kind) {
                        // Should ignore a duplicated listener.
                        return false
                    }
                    prev = node
                    node = node.next
                }

                prev.next = newNode(listener, kind, options)
                return true
            },
            configurable: true,
            writable: true,
        },

        removeEventListener: {
            value: function removeEventListener(type, listener, options) {
                if (listener == null) {
                    return false
                }

                var capture = isObject(options) ? Boolean(options.capture) : Boolean(options)
                var kind = (capture ? CAPTURE : BUBBLE)
                var prev = null
                var node = this[LISTENERS][type]
                while (node != null) {
                    if (node.listener === listener && node.kind === kind) {
                        if (prev == null) {
                            this[LISTENERS][type] = node.next
                        }
                        else {
                            prev.next = node.next
                        }
                        return true
                    }

                    prev = node
                    node = node.next
                }

                return false
            },
            configurable: true,
            writable: true,
        },

        dispatchEvent: {
            value: function dispatchEvent(event) {
                // If listeners aren't registered, terminate.
                var type = event.type
                var node = this[LISTENERS][type]
                if (node == null) {
                    return true
                }

                // Since we cannot rewrite several properties, so wrap object.
                var wrapped = createEventWrapper(event, this)

                // This doesn't process capturing phase and bubbling phase.
                // This isn't participating in a tree.
                var prev = null
                while (node != null) {
                    // Remove this listener if it's once
                    if (node.once) {
                        if (prev == null) {
                            this[LISTENERS][type] = node.next
                        }
                        else {
                            prev.next = node.next
                        }
                    }
                    else {
                        prev = node
                    }

                    // Call this listener
                    wrapped[PASSIVE_LISTENER_FLAG] = node.passive
                    if (typeof node.listener === "function") {
                        node.listener.call(this, wrapped)
                    }
                    else if (node.kind !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                        node.listener.handleEvent(wrapped)
                    }

                    // Break if `event.stopImmediatePropagation` was called.
                    if (wrapped[STOP_IMMEDIATE_PROPAGATION_FLAG]) {
                        break
                    }

                    node = node.next
                }

                return !wrapped.defaultPrevented
            },
            configurable: true,
            writable: true,
        },
    }
)


/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_underscore__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_underscore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_underscore__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__live_state__ = __webpack_require__(17);
/**
 * Represents information for non-live streams.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/live-state
 * @todo Replace alternate properties with a serialized channel (to avoid require loops)
 */




/**
 * @typedef {number} LiveStateIndicator
 */
/**
 * @typedef {Object} SerializedLiveState
 * @property {module:channel/live-state~LiveStateIndicator} state
 * @property {string} alternateUsername
 * @property {string} alternateURL
 * @see {@link module:channel/live-state.LiveState}
 */
/**
 * Constant for how the live state is to be interpreted in a boolean scenario.
 *
 * @typedef {number} LiveStateInterpretation
 */

const IGNORED_PROPERTIES = ["state", "isLive"],
      OFFLINE = __WEBPACK_IMPORTED_MODULE_2__live_state__["a" /* default */].OFFLINE,
      LIVE = __WEBPACK_IMPORTED_MODULE_2__live_state__["a" /* default */].LIVE,
      REDIRECT = __WEBPACK_IMPORTED_MODULE_2__live_state__["a" /* default */].REDIRECT,
      REBROADCAST = __WEBPACK_IMPORTED_MODULE_2__live_state__["a" /* default */].REBROADCAST,
      TOWARD_LIVE = __WEBPACK_IMPORTED_MODULE_2__live_state__["a" /* default */].TOWARD_LIVE,
      TOWARD_OFFLINE = __WEBPACK_IMPORTED_MODULE_2__live_state__["a" /* default */].TOWARD_OFFLINE,
      getDefaultInterpretation = () => {
  return __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get("panel_nonlive").then(value => {
    return parseInt(value, 10) < 3 ? TOWARD_LIVE : TOWARD_OFFLINE;
  });
};

/**
 * Used to describe the exact state of a stream. Sometimes streams are marked
 * as rebroadcasts or are a re-stream from a different source.
 *
 * @class module:channel/live-state.LiveState
 */
class LiveState {

  /**
   * @param {module:channel/live-state~SerializedLiveState} serializedLiveState
   *                      - LiveState represented as JSON serializable object.
   * @returns {module:channel/live-state.LiveState} LiveState derrived from
   *          the specification of the serialized version.
   */


  /**
   * Interprets everything but offline as live.
   *
   * @type {module:channel/live-state~LiveStateInterpretation}
   * @default 0
   * @const
   */

  /**
   * Indicates the channel is hosting another channel or similar.
   *
   * @const
   * @type {module:channel/live-state~LiveStateIndicator}
   * @alias module:channel/live-state.LiveState.REDIRECT
   * @default 1
   * @see {@link module:channel/live-state.LiveState.LIVE}, {@link module:channel/live-state.LiveState.REBROADCAST}, {@link module:channel/live-state.LiveState.OFFLINE}
   */

  /**
   * Indicates that the channel is offline.
   *
   * @const
   * @type {module:channel/live-state~LiveStateIndicator}
   * @alias module:channel/live-state.LiveState.OFFLINE
   * @default 0
   * @see {@link module:channel/live-state.LiveState.REDIRECT}, {@link module:channel/live-state.LiveState.REBROADCAST}, {@link module:channel/live-state.LiveState.LIVE}
   */
  static deserialize(serializedLiveState) {
    const props = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_underscore__["omit"])(serializedLiveState, IGNORED_PROPERTIES);
    return Object.assign(new LiveState(serializedLiveState.state), props);
  }
  /**
   * Interprets everything but live as offline.
   *
   * @type {module:channel/live-state~LiveStateInterpretation}
   * @default 1
   * @const
   */

  /**
   * The channel is rebroadcasting a previous broadcast.
   *
   * @const
   * @type {module:channel/live-state~LiveStateIndicator}
   * @alias module:channel/live-state.LiveState.REBROADCAST
   * @default 2
   * @see {@link module:channel/live-state.LiveState.LIVE}, {@link module:channel/live-state.LiveState.REDIRECT}, {@link module:channel/live-state.LiveState.OFFLINE}
   */

  /**
   * Indicates that the channel is live.
   *
   * @const
   * @type {module:channel/live-state~LiveStateIndicator}
   * @alias module:channel/live-state.LiveState.LIVE
   * @default 0
   * @see {@link module:channel/live-state.LiveState.REDIRECT}, {@link module:channel/live-state.LiveState.REBROADCAST}, {@link module:channel/live-state.LiveState.OFFLINE}
   */


  /**
   * @constructs
   * @param {module:channel/live-state~LiveStateIndicator} [state={@link module:channel/live-state.LiveState.OFFLINE}]
   *                                   - Initial state, defaulting to offline.
   */
  constructor(state = OFFLINE) {
    this.alternateUsername = "";
    this.alternateURL = "";

    this._state = state;
  }
  /**
   * The state descriptor of this LiveState.
   *
   * @type {module:channel/live-state~LiveStateIndicator}
   * @readonly
   */
  get state() {
    return this._state;
  }
  /**
   * The default interpretation mode based on a user's preference.
   *
   * @type {module:channel/live-state~LiveStateInterpretation}
   * @async
   */
  static defaultInterpretation() {
    return getDefaultInterpretation();
  }
  /**
   * Serialize the LiveState.
   *
   * @returns {module:channel/live-state~SerializedLiveState} JSON
   *          serializable object representation of the live state.
   */
  serialize() {
    return {
      state: this.state,
      alternateUsername: this.alternateUsername,
      alternateURL: this.alternateURL
    };
  }
  /**
   * Interpret the live state to a boolean decision.
   *
   * @param {module:channel/live-state~LiveStateInterpretation} [interpretation]
   *                                - How to interpret live states as boolean.
   * @returns {boolean} Whether the live state should be considered live.
   */
  async isLive(interpretation) {
    if (!interpretation) {
      interpretation = await getDefaultInterpretation();
    }

    if (interpretation === TOWARD_LIVE) {
      return this.state !== OFFLINE;
    } else if (interpretation === TOWARD_OFFLINE) {
      return this.state === LIVE;
    }
  }
  /**
   * Set the state to live or not live. Simple as can be.
   *
   * @param {boolean} live - Shortcut to set the object to simple states.
   */
  setLive(live) {
    this._state = live ? LIVE : OFFLINE;
    this.alternateUsername = "";
    this.alternateURL = "";
  }
}

LiveState.OFFLINE = OFFLINE;
LiveState.LIVE = LIVE;
LiveState.REDIRECT = REDIRECT;
LiveState.REBROADCAST = REBROADCAST;
LiveState.TOWARD_LIVE = TOWARD_LIVE;
LiveState.TOWARD_OFFLINE = TOWARD_OFFLINE;
/* harmony default export */ __webpack_exports__["a"] = LiveState;

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return promisedPaginationHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PaginationHelper; });
/**
 * Pagination helper for APIs with pagination
 * @module pagination-helper
 * @author Martin Giger
 * @license MPL-2.0
 */

/**
 * An SDK request for executing HTTP request.
 * @external sdk/request
 * @requires sdk/request
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/request}
 */
/**
 * Add-on SDK Response object
 * @class Response
 * @memberof external:sdk/request
 * @inner
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/request#Response}
 */

/**
 * A helper object for working with paginated APIs. It fetches all the content
 * and then returns an array of all data. Runs immediately after construction.
 *
 * @class
 * @param {module:pagination-helper~PaginationHelperOptions} options - Pagination
 *        helper configuration.
 * @alias module:pagination-helper.PaginationHelper
 */
function PaginationHelper(options) {
    this.url = options.url;
    this.request = options.request;
    this.fetchNextPage = options.fetchNextPage;
    this.onComplete = options.onComplete;
    this.getItems = options.getItems;

    if ("pageSize" in options) {
        this.pageSize = options.pageSize;
    }
    if ("getPageNumber" in options) {
        this.getPageNumber = options.getPageNumber;
    }

    if ("initialPage" in options) {
        this.page = options.initialPage;
    }
    this.result = [];

    this.getPage(true);
}

PaginationHelper.prototype.url = "localhost/";
PaginationHelper.prototype.page = 0;
PaginationHelper.prototype.pageSize = 100;
PaginationHelper.prototype.result = [];
PaginationHelper.prototype.request = null;
PaginationHelper.prototype.fetchNextPage = null;
PaginationHelper.prototype.onComplete = null;
PaginationHelper.prototype.getItems = null;
PaginationHelper.prototype.getPageNumber = function (page, pageSize) {
    return page + pageSize;
};

/**
 * A function running a request on the provided URL and then calling the
 * callback function. Alternatively returnes a promise. Normally is
 * {@link module:queueservice~QueueServie.queueRequest}, which returns a
 * {@link external:sdk/request~Response}.
 *
 * @callback request
 * @argument {string} url
 * @argument {function} callback
 * @argument {boolean} initial - Indicating if this is the first request ran.
 * @return {?Promise} Optionally returns a promise instead of calling the
 *         callback function.
 */
/**
 * A function determining, if the next page should be fetched.
 *
 * @callback fetchNextPage
 * @argument {?} data - Whatever {@link module:pagination-helper~request} returned.
 * @argument {number} pageSize - The expected size of a page.
 * @return {boolean}
 */
/**
 * @callback completeCallback
 * @argument {Array} data - All the fetched items
 */
/**
 * Extracts the items from a page out of an Add-on SDK Response object.
 *
 * @callback getItems
 * @argument {?} data - Whatever {@link module:pagination-helper~request} returned.
 * @return {Array} The extracted items.
 */
/**
 * @callback getPageNumber
 * @argument {number|string} page - The current page.
 * @argument {number} pageSize - The size of a page.
 * @argument {?} data - Whatever {@link module:pagination-helper~request} returned.
 * @return {number|string} The next page to fetch.
 */
/**
 * @typedef {Object} PaginationHelperOptions
 * @property {string} url - The base URL to call.
 * @property {number} [pageSize=100] - The number of expected items per full page.
 * @property {module:pagination-helper~request} request
 * @property {module:pagination-helper~fetchNextPage} fetchNextPage
 * @property {module:pagination-helper~completeCallback} [onComplete]
 * @property {module:pagination-helper~getItems} getItems
 * @property {module:pagination-helper~getPageNumber} [getPageNumber=(page, pageSize) => page + pageSize]
 * @property {number|string} [initialPage=0] - The first page that is fetched.
 */

/**
 * Fetches the next page and then processes the content. Invokes itself
 * recursively and is initially invoked from the constructor. If all content
 * was fetched onComplete is called.
 *
 * @param {boolean} [initial=false] - If this is the first fetched page.
 * @returns {undefined}
 */
PaginationHelper.prototype.getPage = function (initial = false) {
    const cbk = data => {
        this.result = this.result.concat(this.getItems(data));
        if (this.fetchNextPage(data, this.pageSize)) {
            this.page = this.getPageNumber(this.page, this.pageSize, data);
            this.getPage();
        } else {
            if (this.onComplete) {
                this.onComplete(Array.slice(this.result));
            }
            this.result.length = 0;
        }
    },
          ret = this.request(this.url + this.page, cbk, initial);

    if (typeof ret == "object" && "then" in ret) {
        ret.then(cbk);
    }
};

/**
 * Get a PaginationHelper that resolves a promise. The specified callback
 * functions are not handeld promise aware.
 *
 * @param {module:pagination-helper~PaginationHelperOptions} options - Pagination
 *        helper configuration without onComplete.
 * @async
 * @returns {undefined} The PaginationHelper is done.
 * @alias module:pagination-helper.promisedPaginationHelper
 */
const promisedPaginationHelper = options => {
    return new Promise(resolve => {
        options.onComplete = resolve;

        new PaginationHelper(options);
    });
};



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Build query strings from an Object
 *
 * @author Martin Giger
 * @license MPL-2.0
 */

/* harmony default export */ __webpack_exports__["a"] = {
    stringify(obj) {
        const qs = new URLSearchParams();
        for (const q in obj) {
            qs.append(q, obj[q]);
        }

        return qs.toString();
    }
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return _;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}.call(this));


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_event_target_shim__);
/**
 * SDK communication helper.
 *
 * @author Martin Giger
 * @license MPL-2.0
 */



class SDKCommunication extends __WEBPACK_IMPORTED_MODULE_1_event_target_shim___default.a {
    constructor() {
        super();

        this.port = browser.runtime.connect({ name: "sdk-connection" });
        this.port.onMessage.addListener(message => {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "message", message);
        });
    }

    postMessage(message) {
        if (typeof message != "object" || !("target" in message)) {
            throw new Error("Must at least give a target action for the message");
        }
        this.port.postMessage(message);
    }

    doAction(message) {
        return new Promise((resolve, reject) => {
            // Can't use the once infrastructure since other replies might come in first.
            const waitForAction = ({ detail }) => {
                if (detail.target == message.target + "-reply") {
                    this.removeEventListener("message", waitForAction, false);
                    if (!detail.error) {
                        resolve(detail.payload);
                    } else {
                        reject(detail.error);
                    }
                }
            };
            this.addEventListener("message", waitForAction, false);
            this.postMessage(message);
        });
    }
}

const SDK = new SDKCommunication();

/* harmony default export */ __webpack_exports__["a"] = SDK;

/***/ }),
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = and;
/* harmony export (immutable) */ __webpack_exports__["b"] = or;
/* harmony export (immutable) */ __webpack_exports__["a"] = not;
/**
 * Concurrent logic utils
 *
 * @author Martin Giger
 * @license MPL-2.0
 */

/**
 * Identity function, returns what it gets.
 *
 * @param {?} i - What it gets.
 * @returns {?} What it got.
 */
const identity = i => i;

/**
 * An asynchronous version of the boolean and operation.
 *
 * @param {Promise} args - Promises that return booleans to do an and on.
 * @async
 * @returns {boolean} Result of the and operation on all returned values.
 */
function and(...args) {
  return Promise.all(args).then(p => p.every(identity));
}

/**
 * An asynchronous version of the boolean or operation.
 *
 * @param {Promise} args - Promises that return booleans to do an or on.
 * @async
 * @returns {boolean} Result of the or operation on all returned values.
 */
function or(...args) {
  return Promise.all(args).then(p => p.some(identity));
}

/*
 * Invert the value a promise resolves to.
 *
 * @param {Promise} promsie - Promise that returns the value to invert.
 * @async
 * @returns {boolean} The opposite value than the given promise resolved to.
 */
function not(promise) {
  return promise.then(p => !p);
}

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__twitch__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hitbox__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ustream__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__youtube__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__livestream__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__mlg__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__azubu__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__beam__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__picarto__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__new_livestream__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__douyutv__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__dailymotion__ = __webpack_require__(36);
/**
 * Exports each provider as a property named after the provider's type. Each
 * provider is assumed to be frozen.
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers
 */













/* harmony default export */ __webpack_exports__["a"] = {
    twitch: __WEBPACK_IMPORTED_MODULE_0__twitch__["a" /* default */],
    hitbox: __WEBPACK_IMPORTED_MODULE_1__hitbox__["a" /* default */],
    ustream: __WEBPACK_IMPORTED_MODULE_2__ustream__["a" /* default */],
    youtube: __WEBPACK_IMPORTED_MODULE_3__youtube__["a" /* default */],
    livestream: __WEBPACK_IMPORTED_MODULE_4__livestream__["a" /* default */],
    mlg: __WEBPACK_IMPORTED_MODULE_5__mlg__["a" /* default */],
    azubu: __WEBPACK_IMPORTED_MODULE_6__azubu__["a" /* default */],
    beam: __WEBPACK_IMPORTED_MODULE_7__beam__["a" /* default */],
    picarto: __WEBPACK_IMPORTED_MODULE_8__picarto__["a" /* default */],
    newlivestream: __WEBPACK_IMPORTED_MODULE_9__new_livestream__["a" /* default */],
    douyutv: __WEBPACK_IMPORTED_MODULE_10__douyutv__["a" /* default */],
    dailymotion: __WEBPACK_IMPORTED_MODULE_11__dailymotion__["a" /* default */]
};

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Live state constants
 *
 * @author Martin Giger
 * @license MPL-2.0
 */

/* harmony default export */ __webpack_exports__["a"] = {
    OFFLINE: -1,
    LIVE: 0,
    REDIRECT: 1,
    REBROADCAST: 2,
    TOWARD_LIVE: 0,
    TOWARD_OFFLINE: 1
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


/**
 * Creates a unique key.
 *
 * @param {string} name - A name to create.
 * @returns {symbol|string} Generated unique key.
 * @private
 */
var createUniqueKey = module.exports.createUniqueKey = (
    typeof Symbol !== "undefined" ? Symbol : //eslint-disable-line no-undef
    /* otherwise */ function createUniqueKey(name) {
        return "[[" + name + "_" + Math.random().toFixed(8).slice(2) + "]]"
    }
)

/**
 * Checks whether the given value is a non-null object or not.
 *
 * @param {any} x - The value to be check.
 * @returns {boolean} `true` if the value is a non-null object.
 * @private
 */
var isObject = module.exports.isObject = function isObject(x) {
    return typeof x === "object" && x !== null
}

/**
 * The key of listeners.
 *
 * @type {symbol|string}
 * @private
 */
module.exports.LISTENERS = createUniqueKey("listeners")

/**
 * A value of kind for listeners which are registered in the capturing phase.
 *
 * @type {number}
 * @private
 */
module.exports.CAPTURE = 1

/**
 * A value of kind for listeners which are registered in the bubbling phase.
 *
 * @type {number}
 * @private
 */
module.exports.BUBBLE = 2

/**
 * A value of kind for listeners which are registered as an attribute.
 *
 * @type {number}
 * @private
 */
module.exports.ATTRIBUTE = 3

/**
 * @typedef object ListenerNode
 * @property {function} listener - A listener function.
 * @property {number} kind - The kind of the listener.
 * @property {ListenerNode|null} next - The next node.
 *      If this node is the last, this is `null`.
 */

/**
 * Creates a node of singly linked list for a list of listeners.
 *
 * @param {function} listener - A listener function.
 * @param {number} kind - The kind of the listener.
 * @param {object} [options] - The option object.
 * @param {boolean} [options.once] - The flag to remove the listener at the first call.
 * @param {boolean} [options.passive] - The flag to ignore `event.preventDefault` method.
 * @returns {ListenerNode} The created listener node.
 */
module.exports.newNode = function newNode(listener, kind, options) {
    var obj = isObject(options)

    return {
        listener: listener,
        kind: kind,
        once: obj && Boolean(options.once),
        passive: obj && Boolean(options.passive),
        next: null,
    }
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);
/**
 * Serializes the providers so they can be sent over a message port.
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/serialized
 * @see {@link module:providers}
 */


/**
 * Frozen.
 *
 * @typedef {Object} SerializedProvider
 * @property {string} name
 * @property {module:providers/generic-provider~ProviderSupports} supports
 * @property {boolean} enabled
 */

/**
 * Serializes the providers objects so they can get passed as a message.
 *
 * @param {Object.<string, module:providers/generic-provider.GenericProvider>} providers
 *                                              - Providers object to serialize.
 * @returns {Object<string, module:providers/serialized~SerializedProvider>}
 *         Frozen Object of serialized providers by id.
 */
const serializeProviders = providers => {
  const ret = {};
  for (const p in providers) {
    ret[p] = Object.freeze({
      name: providers[p].name,
      supports: providers[p].supports,
      enabled: providers[p].enabled
    });
  }
  Object.freeze(ret);
  return ret;
};

/**
 * @see {@link module:providers/serialized~serializeProviders}
 * @type {Object<string, module:providers/serialized~SerializedProvider>}
 */
/* harmony default export */ __webpack_exports__["a"] = serializeProviders(__WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */]);

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__update__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__preferences__ = __webpack_require__(2);
/**
 * Queue service for providers. Provides a separated management for requests by
 * provider, all in the same {@link module:queue/update.UpdateQueue}.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module queue/service
 * @requires module:queue/update
 */

//TODO pre-calculate Response.json()?



const queue = new __WEBPACK_IMPORTED_MODULE_0__update__["a" /* default */](),
      services = {},
      defaultRequeue = response => !response.ok && response.status !== 404 && response.status !== 420,
      completeCallback = (requeue, callback, url, data) => {
    if (!requeue(data)) {
        callback(data, url);
    }
};

/**
 * @callback updateRequestCallback
 * @param {external:sdk/request~Response} data
 * @param {string} url
 */

/**
 * A service providing methods for a provider to place one-time and reocurring
 * requests.
 *
 * @class
 */
class QueueService {
    /**
     * @private
     * @type {Array}
     */
    constructor() {
        this.highPriorityRequestIds = [];
        this.lowPriorityRequestIds = [];
        this.HIGH_PRIORITY = QueueService.HIGH_PRIORITY;
        this.LOW_PRIORITY = QueueService.LOW_PRIORITY;

        this.highPriorityRequestIds = [];
        this.lowPriorityRequestIds = [];
    }

    /**
     * Returns the request ID array for the specified priority.
     *
     * @private
     * @param {module:queue-service~QueuePriority} priority - Priority to get
     *                                                        the array for.
     * @returns {Array} Array of request IDs.
     */

    /**
     * @private
     * @type {Array}
     */
    getRequestProperty(priority) {
        return this[priority + "PriorityRequestIds"];
    }

    /**
     * Determines if the request has to be requeued due to errors.
     *
     * @callback requeue
     * @param {external:sdk/request~Response} data - Response that was returned.
     * @returns {boolean} When true, the request will be queued again.
     */
    /**
     * Immediately run a request to the given URL.
     *
     * @param {string} url - The URL to request.
     * @param {Object.<string, string>} [headers={}] - An object with the headers
     *                                                 to send.
     * @param {module:queue/service~requeue} [requeue=(r) => r.status > 499]
     *                             - Determines if the request should be re-run.
     * @param {number} [attempt=0] - Counter to avoid requeuing infinitely.
     * @returns {Promise} A promise resolving with the Add-on SDK Request response.
     */
    queueRequest(url, headers = {}, requeue = defaultRequeue, attempt = 0) {
        console.log("Queueing " + url);
        return new Promise((resolve, reject) => {
            const id = queue.addRequest({
                url,
                headers: new Headers(headers),
                onComplete: data => {
                    if (requeue(data)) {
                        __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get("queueservice_maxRetries").then(maxRetries => {
                            if (attempt < maxRetries) {
                                resolve(this.queueRequest(url, headers, requeue, ++attempt));
                            } else {
                                reject("Too many attempts");
                            }
                        });
                    } else {
                        resolve(data);
                    }
                },
                onError: reject
            }, false, true);

            if (attempt === 0 && navigator.onLine) {
                queue.getRequestById(id);
            }
        });
    }

    /**
     * Unqueues an all update requests of the given priority. If none is given,
     * all update requests are unqueued.
     *
     * @param {module:queue/service~QueuePriority?} priority - Priority of
     *                                                      reuqests to unqueue.
     * @returns {undefined}
     */
    unqueueUpdateRequest(priority) {
        if (!priority) {
            this.unqueueUpdateRequest(QueueService.HIGH_PRIORITY);
            this.unqueueUpdateRequest(QueueService.LOW_PRIORITY);
        } else {
            if (this.getRequestProperty(priority).length > 0) {
                this.getRequestProperty(priority).forEach(reqId => {
                    queue.removeRequest(reqId);
                });
                this.getRequestProperty(priority).length = 0;
            }
        }
    }
    /**
     * Queue a new reocurring update request of the given priority. Removes all
     * existing update requests of this priority.
     *
     * @param {Array.<string>} urls - An array of URLs to call.
     * @param {module:queue/service~QueuePriority} priority - Priority to queue
     *                                                        the request as.
     * @param {module:queue/service~updateRequestCallback} callback - Called
     *                                           whenever a request is done (for
     *                                           each provided URL).
     * @param {Object.<string,string>} [rawHeaders={}] - An object with header-value
     *                                                pairs to send with the
     *                                                request.
     * @param {module:queue/service~requeue} [requeue=(r) => r.status > 499]
     *                             - Determinines if a request should be re-run.
     * @returns {undefined}
     */
    queueUpdateRequest(urls, priority, callback, rawHeaders = {}, requeue = defaultRequeue) {
        console.log("Requeueing " + priority + " priority update request");
        this.unqueueUpdateRequest(priority);
        const requests = this.getRequestProperty(priority),
              skips = priority == QueueService.LOW_PRIORITY ? 4 : 0,
              headers = new Headers(rawHeaders);

        requests.push(...urls.map(url => queue.addRequest({
            url,
            headers,
            onComplete: completeCallback.bind(null, requeue, callback, url)
        }, true, false, skips)));
    }
}

/**
 * Get a QueueService for the usage in a provider.
 *
 * @param {string} providerName - The type of the provider.
 * @returns {module:queue/service~QueueService} QueueService for the provider.
 */
QueueService.HIGH_PRIORITY = "high";
QueueService.LOW_PRIORITY = "low";
const getServiceForProvider = providerName => {
    if (!services.hasOwnProperty(providerName)) {
        services[providerName] = new QueueService();
    }
    return services[providerName];
};
/* harmony export (immutable) */ __webpack_exports__["f"] = getServiceForProvider;


/**
 * Set the internal queue refresh properties.
 *
 * @param {module:queue/pauseable~QueueOptions} options - Queue options.
 * @returns {undefined}
 */
const setOptions = options => {
    console.log("[QS]> setting queue options:" + options.toSource());
    queue.autoFetch(options.interval, options.amount, options.maxSize);
};
/* harmony export (immutable) */ __webpack_exports__["c"] = setOptions;


/**
 * Change the interval of the internal queue.
 *
 * @param {number} interval - Refresh interval in milliseconds.
 * @returns {undefined}
 */
const updateOptions = interval => {
    console.log("[QS]> setting interval to " + interval);
    queue.autoFetch(interval);
};
/* harmony export (immutable) */ __webpack_exports__["e"] = updateOptions;


/**
 * Pause the internal queue.
 *
 * @returns {undefined}
 */
const pause = () => {
    queue.pause();
};
/* harmony export (immutable) */ __webpack_exports__["a"] = pause;


/**
 * Resume the internal queue.
 *
 * @returns {undefined}
 */
const resume = () => {
    queue.resume();
};
/* harmony export (immutable) */ __webpack_exports__["b"] = resume;


/**
 * @typedef {Object} QueueServiceListener
 * @property {function} containsPriorized - Callback for the
 * {@link module:queue/update.UpdateQueue#event:queuepriorized} event of the
 * internal queue.
 * @property {function} priorizedLoaded - Callback for the
 * {@link module:queue/update.UpdateQueue#event:allpriorizedloaded} event of the
 * internal queue.
 * @property {function} paused
 * @property {function} resumed
 */

/**
 * Add event listeners to the internal queue.
 *
 * @param {module:queue/service~QueueServiceListener} listeners - Listeners to add.
 * @returns {undefined}
 */
const addListeners = ({ containsPriorized, priorizedLoaded, paused, resumed }) => {
    if (containsPriorized) {
        queue.addEventListener("queuepriorized", containsPriorized);
    }
    if (priorizedLoaded) {
        queue.addEventListener("allpriorizedloaded", priorizedLoaded);
    }
    if (paused) {
        queue.addEventListener("pause", paused);
    }
    if (resumed) {
        queue.addEventListener("resume", resumed);
    }
};
/* harmony export (immutable) */ __webpack_exports__["d"] = addListeners;


/**
 * Remove event listeners from the internal queue.
 *
 * @param {module:queue/service~QueueServiceListener} listeners - Listeners to
 *        remove.
 * @returns {undefined}
 */
const removeListeners = ({ containsPriorized, priorizedLoaded, paused, resumed }) => {
    if (containsPriorized) {
        queue.removeEventListener("queuepriorized", containsPriorized);
    }
    if (priorizedLoaded) {
        queue.removeEventListener("allpriorizedloaded", priorizedLoaded);
    }
    if (paused) {
        queue.removeEventListener("pause", paused);
    }
    if (resumed) {
        queue.removeEventListener("resume", resumed);
    }
};
/* unused harmony export removeListeners */


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sdk__ = __webpack_require__(10);
/**
 * Parental controls wrapper.
 *
 * @author Martin Giger
 * @license MPL-2.0
 */


let enabled = false;

const getEnabled = () => __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].doAction({ target: "pc-enabled" }).then(e => {
    enabled = e;
});

/* harmony default export */ __webpack_exports__["a"] = {
    get enabled() {
        getEnabled();
        return enabled;
    }
};

getEnabled();

/***/ }),
/* 22 */
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__manager__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__list__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_serialized__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__parental_controls__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_underscore__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_underscore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_underscore__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__dump__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__logins__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_event_target_shim__);
/**
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/controller
 */













/**
 * @event module:channel/controller.ChannelController#channelsadded
 * @type {Array.<module:channel/core.Channel>}
 */
/**
 * @event module:channel/controller.ChannelController#channeldeleted
 * @type {number}
 */
/**
 * @event module:channel/controller.ChannelController#channelupdated
 * @type {module:channel/core.Channel}
 */

//const REFRESH_PROFILE_URL = "https://support.mozilla.org/kb/refresh-firefox-reset-add-ons-and-settings",

/**
 * Filters mature channels if parental controls are activated.
 *
 * @param {Array.<module:channel/core.Channel>} channels - Channels to filter.
 * @returns {Array.<module:channel/core.Channel>} Filtered of channels marked as
 *          mature if parental controls are activated.
 */
const filterInapropriateChannels = channels => {
    if (__WEBPACK_IMPORTED_MODULE_6__parental_controls__["a" /* default */].enabled) {
        return channels.filter(c => !c.mature);
    } else {
        return channels;
    }
},

/**
 * Filter channels to exclude existing favorites.
 *
 * @param {module:channel/core.User} user - User whose favs should be excluded.
 * @param {Array.<module:channel/core.Channel>} channels - Channels to filter.
 * @returns {Array.<module:channel/core.Channel>} Filtered array of channels.
 */
filterExistingFavs = (user, channels) => {
    return channels.filter(ch => !user.favorites.includes(ch.login));
};

/**
 * Controller for all the channel stuff. Handles getting info from providers
 * and abstracts the {@link module:channel/list.ChannelList} complications away.
 * @extends external:EventTarget
 */
class ChannelController extends __WEBPACK_IMPORTED_MODULE_11_event_target_shim___default.a {

    /**
     * @fires module:channel/controller.ChannelController#channelsadded
     * @fires module:channel/controller.ChannelController#channeldeleted
     * @fires module:channel/controller.ChannelController#channelupdated
     */
    constructor() {
        super();
        /**
         * @type {Array.<function>}
         * @private
         */
        this._ready = false;
        this._queue = [];

        const managerError = (e, name, type, itemType, canceled = () => false) => {
            console.error("loading", itemType, ":", name, type, "an error occured");
            console.error(e);
            if (canceled()) {
                this._manager.onCancel(name, type, itemType);
            } else if (name && type in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */]) {
                this._manager.onError(name, __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].name, itemType);
            } else {
                this._manager.onError();
            }
        },
              managerDoneLoading = () => {
            this._manager.loading = false;
        };
        /**
         * @type module:channel/manager.ChannelsManager
         * @private
         */
        this._manager = new __WEBPACK_IMPORTED_MODULE_1__manager__["a" /* default */]();
        this._manager.addEventListener("addchannel", ({ detail: [name, type, canceled] }) => this.addChannel(name, type, canceled).then(() => this._manager._deleteCancelingValue("channel", type, name), e => managerError(e, name, type, "channel", canceled)));
        this._manager.addEventListener("removechannel", ({ detail }) => this.removeChannel(detail));
        this._manager.addEventListener("updatechannel", ({ detail }) => this.updateChannel(detail).catch(managerDoneLoading));
        this._manager.addEventListener("adduser", ({ detail: [username, type, canceled] }) => this.addUser(username, type, canceled).then(() => this._manager._deleteCancelingValue("user", type, username), e => managerError(e, username, type, "user", canceled)));
        this._manager.addEventListener("removeuser", ({ detail }) => this.removeUser(detail));
        this._manager.addEventListener("updatefavorites", ({ detail }) => this.updateUser(detail).catch(managerDoneLoading));
        this._manager.addEventListener("autoadd", () => this.autoAddUsers().catch(managerDoneLoading));
        this._manager.addEventListener("getdata", () => {
            Promise.all([this.getChannelsByType().then(channels => channels.forEach(ch => this._manager.onChannelAdded(ch))), this.getUsersByType().then(users => users.forEach(usr => this._manager.onUserAdded(usr)))]).then(managerDoneLoading, managerDoneLoading);

            this._manager.addProviders(__WEBPACK_IMPORTED_MODULE_5__providers_serialized__["a" /* default */]);
        });
        this._manager.addEventListener("debugdump", () => {
            Promise.all([this.getChannelsByType(), this.getUsersByType()]).then(([channels, users]) => {
                return __WEBPACK_IMPORTED_MODULE_8__dump__["a" /* copy */](channels, users);
            });
        });
        this._manager.addEventListener("showoptions", () => {
            __WEBPACK_IMPORTED_MODULE_9__preferences__["a" /* default */].open();
        });

        /*
         * These are a bunch of helpers for onChanneldelted. The comment there
         * explains more or less what's going on.
         */
        const deletedTypes = new Map(),

        // We only want the afterchannelsdeleted event to fire after all channels are gone.
        debouncedEvent = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_underscore__["debounce"])(() => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["a" /* emit */])(this, "afterchannelsdeleted"), 500),
              deleteCallback = type => {
            this._list.getChannelsByType(type).then(channels => {
                if (channels.length > 0 && __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].enabled) {
                    __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].updateRequest(channels);
                } else {
                    __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].removeRequest();
                }
                deletedTypes.delete(type);
                debouncedEvent();
            });
        };
        /**
         * @type module:channel/list.ChannelList
         * @private
         */
        this._list = new __WEBPACK_IMPORTED_MODULE_2__list__["a" /* default */]();
        this._list.addEventListener("ready", () => {
            this._ready = true;

            // Resolve all the queued up promises.
            this._queue.forEach(r => r());
            this._queue.length = 0;
        });
        this._list.addEventListener("channelsadded", ({ detail: channels }) => {
            // Assume we always only get an array of channels with the same type.
            if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][channels[0].type].enabled) {
                this._list.getChannelsByType(channels[0].type).then(chans => {
                    __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][chans[0].type].updateRequest(chans);
                });
            }

            channels.forEach(chan => this._manager.onChannelAdded(chan));

            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["a" /* emit */])(this, "channelsadded", channels);
        });
        this._list.addEventListener("useradded", ({ detail: user }) => {
            if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].supports.favorites) {
                this._list.getUsersByType(user.type).then(users => {
                    __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].updateFavsRequest(users);
                });
            }

            this._manager.onUserAdded(user);
        });
        this._list.addEventListener("beforechanneldeleted", ({ detail }) => {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["a" /* emit */])(this, "beforechanneldeleted", detail);
        });
        this._list.addEventListener("channeldeleted", ({ detail: channel }) => {
            /*
             * Yeah, this is a bit confusing, but that's why there are
             * comments explaining it. So sometimes multiple channels get
             * deleted at once - the channels manager supports multi-selects
             * But they aren't of the same type. So what we want to do, is
             * call the unqueueRequest() for each provider exactly once.
             * To do so, we have to make sure, it only gets called for the
             * last deleted channel of a type. invokeOnce makes sure only
             * when the last "invoker" of invokeOnce is calling it, the
             * method gets executed. Since we have multiple types, there is
             * a map, storing the callback invokeOnce calls for each type.
             * And that's all there is to it. Just to reduce requeueing
             * stuff. Now why should only the last one get invoked?
             * Because getChannelsByType is async, and in the worst case,
             * the one without channels to return returns first, which means
             * an update requests with channels that were deleted would be
             * queued, which would lead to them being readded to the list.
             * So this is all totally needed, especially the length of this
             * very comment is crucial to the operation. For more long
             * comments, explaining stuff, check out the lib/utils module,
             * where invokeOnce is kind of explained.
             */
            if (!deletedTypes.has(channel.type)) {
                deletedTypes.set(channel.type, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_underscore__["partial"])(deleteCallback, channel.type));
            }
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["c" /* invokeOnce */])(channel.id, deletedTypes.get(channel.type));

            this._manager.onChannelRemoved(channel.id);

            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["a" /* emit */])(this, "channeldeleted", channel.id);
        });
        this._list.addEventListener("userdeleted", ({ detail: user }) => {
            /* not doing the same mass deletion stuff as for channels, as I
               assume there are less users and it'd mess up the queue's pausing,
               if a user is removed because a channel was deleted.
             */
            if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].supports.favorites) {
                this._list.getUsersByType(user.type).then(users => {
                    if (users.length > 0) {
                        __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].updateFavsRequest(users);
                    } else {
                        __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].removeFavsRequest();
                    }
                });
            }

            this._manager.onUserRemoved(user.id);
        });
        this._list.addEventListener("channelupdated", ({ detail: channel }) => {
            this._manager.onChannelUpdated(channel);

            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["a" /* emit */])(this, "channelupdated", channel);
        });
        this._list.addEventListener("userupdated", ({ detail }) => {
            this._manager.onUserUpdated(detail);
        });
        /*this._list.addEventListener("clear", ({ detail: hard }) => {
            if(hard) {
                //TODO swap out the panel and warning state on the button
                showNotificationBox({
                    value: "jtvn-dberased",
                    label: _("lost_channels"),
                    priority: "WARNING_HIGH",
                    persistence: 10,
                    image: self.data.url("./icon18.png"),
                    buttons: [
                        {
                            label: _("manageChannels_label"),
                            onClick: () => this.showManager()
                        }
                    ]
                });
            }
        });
        this._list.addEventListener("unfixableerror", () => {
            //TODO swap out panel and add warning state to button
            showNotificationBox({
                value: "jtvn-restorefailed",
                label: _("restore_failed"),
                priority: "CRITICAL_LOW",
                persistence: 10,
                image: self.data.url("./offline18.png"),
                buttons: [
                    {
                        label: _("restore_action"),
                        onClick: () => tabs.open({ url: REFRESH_PROFILE_URL })
                    }
                ]
            });
        });*/
        // Provider update events

        /**
         * @type module:providers/events.EventSink
         * @private
         */
        this._eventSink = new __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* default */]();
        this._eventSink.addEventListener("updateduser", ({ detail }) => {
            this._list.setUser(detail);
        });
        this._eventSink.addEventListener("newchannels", ({ detail: channels }) => {
            channels = filterInapropriateChannels(channels);
            if (channels.length > 0) {
                this._list.addChannels(channels);
            }
        });
        this._eventSink.addEventListener("updatedchannels", ({ detail: channels }) => {
            if (Array.isArray(channels)) {
                channels.forEach(channel => this._list.setChannel(channel).catch(() => this._list.addChannel(channel)));
            } else {
                this._list.setChannel(channels).catch(() => this._list.addChannel(channels));
            }
        });

        const channelsCb = channels => {
            if (channels.length) {
                __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][channels[0].type].updateRequest(channels);
            }
        },
              usersCb = users => {
            if (users.length) {
                __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][users[0].type].updateFavsRequest(users);
            }
        };

        for (const p in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */]) {
            if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][p].enabled) {
                this.getChannelsByType(p).then(channelsCb);
                if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][p].supports.favorites) {
                    this.getUsersByType(p).then(usersCb);
                }
            }
        }
    }
    /**
     * Returns a promise that resolves as soon as the ChannelList is ready.
     * Another method in this module that makes magic happen...
     * The promise is resolved with all the arguments this method was called.
     *
     * @param {?} args - Arguments to the callback.
     * @async
     * @private
     * @returns {undefined}
     */

    /**
     * @type {boolean}
     * @private
     */
    _ensureQueueReady(...args) {
        if (!this._ready) {
            return new Promise(resolve => this._queue.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_underscore__["partial"])(resolve, ...args)));
        } else {
            return Promise.resolve(args);
        }
    }
    /**
     * Get the details of a channel and store them in the ChannelList.
     *
     * @param {string} name - Username of the channel to add.
     * @param {string} type - Type/provider of the channel to add.
     * @param {Funtion} [canceled=() => false] - Canceling checker.
     * @returns {module:channel/core.Channel} Resulting channel object.
     * @throws If the provider is disabled.
     * @throws If parental controls are enabled and the channel is marked mature.
     * @throws If the action is canceled.
     */
    async addChannel(name, type, canceled = () => false) {
        if (type in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].enabled) {
            const channel = await __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].getChannelDetails(name);
            if (__WEBPACK_IMPORTED_MODULE_6__parental_controls__["a" /* default */].enabled && channel.mature) {
                throw "Not allowed to add this channel";
            }

            await this._ensureQueueReady();

            if (canceled()) {
                throw "Canceled";
            }

            return this._list.addChannel(channel);
        } else {
            throw "Provider is disabled";
        }
    }
    /**
     * Update a channel and store it in the ChannelList.
     *
     * @param {number} channelId - ID of the channel to update.
     * @returns {module:channel/core.Channel?} Updated channel object. May be
     *          null if the provider is disabled.
     */
    async updateChannel(channelId) {
        await this._ensureQueueReady();
        let channel = await this._list.getChannel(channelId);
        if (!__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][channel.type].enabled) {
            return null;
        }

        channel = await __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][channel.type].updateChannel(channel.login);
        return this._list.setChannel(channel);
    }
    /**
     * Update channels by provider. Doesn't update if the provider is disabled.
     *
     * @param {string} [provider=null] - Type of channels to update. All
     *                                   channels are updated if left out.
     * @returns {Array.<module:channel/core.Channel>|module:channel/core.Channel}
     *          List of updated channel objects, if multiple were updated, else
     *          object of the updated channel.
     */
    async updateChannels(provider = null) {
        if (provider === null || !(provider in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */])) {
            return Promise.all(Object.keys(__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */]).filter(p => __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][p].enabled).map(this.updateChannels.bind(this)));
        } else if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][provider].enabled) {
            await this._ensureQueueReady();
            let channels = await this._list.getChannelsByType(provider);

            if (channels.length) {
                channels = await __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][provider].updateChannels(channels);
            }

            if (Array.isArray(channels)) {
                return Promise.all(channels.map(this._list.setChannel.bind(this._list)));
            } else {
                return this._list.setChannel(channels);
            }
        } else {
            return [];
        }
    }
    /**
     * Get a channel.
     *
     * @param {number} channelId - ID of the channel.
     * @returns {module:channel/core.Channel} Channel instance.
     * @async
     */
    getChannel(channelId) {
        return this._ensureQueueReady().then(() => this._list.getChannel(channelId));
    }
    /**
     * Get multiple channels by provider.
     *
     * @param {string} [provider=null] - Type of the channels to return. If
     *                                      left out, all channels are returned.
     * @returns {Array.<module:channel/core.Channel>} List of channels with for
     *          the given type/provider.
     * @async
     */
    getChannelsByType(provider = null) {
        return this._ensureQueueReady().then(() => this._list.getChannelsByType(provider));
    }
    /**
     * Remove a channel from the ChannelList.
     *
     * @param {number} channelId
     * @returns {module:channel/core.Channel} Removed channel.
     * @async
     */
    removeChannel(channelId) {
        return this._ensureQueueReady().then(() => this._list.removeChannel(channelId));
    }
    /**
     * Add a user and its favorites.
     *
     * @param {string} username - Username of the user to add.
     * @param {string} type - Type/provider of the user to add.
     * @param {Function} [canceled=() => false] - Canceling checker.
     * @returns {module:channel/core.User} An array with the added user and an array of added
     *          channels.
     * @throws Gets rejected if the provider doesn't support favorites.
     * @throws When the action is canceled.
     */
    async addUser(username, type, canceled = () => false) {
        if (type in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].supports.favorites) {
            let [user, channels] = await __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].getUserFavorites(username);
            await this._ensureQueueReady();

            if (canceled()) {
                throw "Canceled";
            }

            if (__WEBPACK_IMPORTED_MODULE_6__parental_controls__["a" /* default */].enabled) {
                channels = channels.filter(c => !c.mature);
            }

            const [u] = await Promise.all([this._list.addUser(user), this._list.addChannels(filterInapropriateChannels(channels))]);
            return u;
        } else {
            throw "Can't add users for provider " + type;
        }
    }
    /**
     * @private
     * @param {module:channel/core.User} user - User instance to update.
     * @async
     * @returns {module:channel/core.User} Updated user.
     */
    async _updateUser(user) {
        const [updatedUser, channels] = await __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].getUserFavorites(user.login),
              [finalUser] = await Promise.all([this._list.setUser(updatedUser),
        // Can't just call this.addUser(user.login, user.type) because of this.
        this._list.addChannels(filterInapropriateChannels(filterExistingFavs(user, channels)))]);
        return finalUser;
    }
    /**
     * Update a user or all users and add any new favorites.
     *
     * @param {number} [userId] - ID of the user, if not specified updates
     *                            all users.
     * @returns {Array.<module:channel/core.User>} Updated user instances.
     */
    async updateUser(userId) {
        await this._ensureQueueReady();
        let users;
        if (userId) {
            users = [await this._list.getUser(userId)];
        } else {
            users = await this.getUsersByType();
        }

        return Promise.all(users.filter(user => __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][user.type].supports.favorites).map(this._updateUser.bind(this)));
    }
    /**
     * Get all users of the given type.
     *
     * @param {string} [provider=null] - Type the users should be of. If
     *                                        omitted all users are returned.
     * @returns {Array.<module:channel/core.User>} User instances for the given
     *          type/provider.
     * @async
     */
    getUsersByType(provider = null) {
        return this._ensureQueueReady().then(() => this._list.getUsersByType(provider));
    }
    /**
     * Remove a user from the ChannelList and optionally remove the channels it
     * favorited.
     *
     * @param {number} userId - ID of the user to remove.
     * @param {boolean} [removeFavorites=false] - Also remove favorited channels
     *        of the user.
     * @returns {module:channel/core.User} Removed user instance.
     */
    async removeUser(userId, removeFavorites = false) {
        await this._ensureQueueReady();
        let p = Promise.resolve();
        if (removeFavorites) {
            p = this._list.removeChannelsByUserFavorites(userId);
        }
        const [u] = await Promise.all([this._list.removeUser(userId), p]);
        return u;
    }
    /**
     * @private
     * @async
     * @param {string} provider - Provider/type to add credentials for.
     * @param {Array} credentials - Resulting credentials from a search.
     * @returns {Array.<module:channel/core.User>} Added user instances.
     */
    _addFoundCredentials(provider, credentials) {
        return Promise.all(credentials.filter(credential => credential.username).map(credential => {
            console.log(`Found a credential for ${ provider } user ${ credential.username }`);
            return this.addUser(credential.username, provider);
        }));
    }
    /**
     * @private
     * @async
     * @param {string} provider - Provider to search for users.
     * @param {string} url - URL to search for credentials for.
     * @returns {Array.<module:channel/core.User>} Users found for the given url.
     */
    _findUsersByURL(provider, url) {
        return __WEBPACK_IMPORTED_MODULE_10__logins__["a" /* search */]({ url }).then(this._addFoundCredentials.bind(this, provider));
    }
    /**
     * Add users that have stored credentials.
     *
     * @param {string} [provider] - Provider to add users stored in the
     * credentials for. If not provided, all providers are searched.
     * @returns {Array.<module:channel/core.User} Users added based on saved
     *          credentials.
     * @throws If the provider does not support adding users based on credentials.
     * @async
     */
    autoAddUsers(provider) {
        if (!provider || !(provider in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */])) {
            return Promise.all(Object.keys(__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */]).filter(p => __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][p].supports.credentials).map(this.autoAddUsers.bind(this)));
        } else if (__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][provider].supports.credentials) {
            console.log(`Searching login name for ${ provider }`);
            return Promise.all(__WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][provider].authURL.map(this._findUsersByURL.bind(this, provider))).then(__WEBPACK_IMPORTED_MODULE_7_underscore__["flatten"]);
        } else {
            return Promise.reject(`Provider ${ provider } does not support auto adding users`);
        }
    }
    /**
     * Opens or focueses a tab with the manager.
     *
     * @returns {undefined}
     * @async
     */
    showManager() {
        return this._manager.open();
    }

    /**
     * Set the theme of the channel manager.
     *
     * @param {number} theme - Theme ID to use.
     * @returns {undefined}
     */
    setTheme(theme) {
        this._ensureQueueReady().then(() => this._manager.setTheme(theme));
    }

    /**
     * Copies the stream URL of the given channel to the clipboard.
     *
     * @param {number|string} id - ID or login.
     * @param {string} [type] - Type if not an ID is given.
     * @returns {undefined}
     */
    async copyChannelURL(id, type) {
        let channel;
        if (type) {
            if (!(type in __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */])) {
                throw "Specified type is not known";
            }

            channel = await __WEBPACK_IMPORTED_MODULE_0__providers__["a" /* default */][type].updateChannel(id);
        } else {
            channel = await this._list.getChannel(id);
        }

        const url = channel.live.alternateURL ? channel.live.alternateURL : channel.url[0],
              p = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils__["d" /* when */])(document, "copy");
        document.execCommand("copy", false, null);
        const [e, pattern] = await Promise.all([p, __WEBPACK_IMPORTED_MODULE_9__preferences__["a" /* default */].get("copy_pattern")]);

        e.clipboardData.setData("text/plain", pattern.replace("{URL}", url));
        e.preventDefault();

        return channel;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ChannelController;


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = selectOrOpenTab;
/**
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/utils
 */

/**
 * Opens the given channel in a new tab, unless there is already a tab open for
 * it.
 *
 * @param {module:channel/core.Channel} channel - The channel to open.
 * @param {string} [what] - Specifies the action to take. "chat" opens the
 *         channel's chat, "archive" opens the archive.
 * @returns {number?} The channel should now be visible for the user.
 */
async function selectOrOpenTab(channel, what) {
    let toCheck = [];

    if (what === "chat") {
        toCheck.push(channel.chatUrl);
    } else if (what === "archive" || !channel.live.isLive()) {
        toCheck.push(channel.archiveUrl);
    } else {
        toCheck = channel.url;

        if (what === "livestreamer") {
            throw "Not supported";
        }
    }

    const tabs = await browser.tabs.query({
        url: toCheck
    });
    if (tabs.length) {
        return browser.tabs.update(tabs[0].id, {
            active: true
        });
    }
    // There's no tab open for the channel
    return browser.tabs.create({ url: toCheck[0] });
}

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__channel_live_state__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_event_target_shim__);
/**
 * Model for the Panel.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module list
 * @requires module:channel/utils
 * @requires module:list/firefox
 * @todo coutner badge vs. live state handling change
 */
// setup event handling






/**
 * Should open the ChannelsManager.
 *
 * @event module:list.ListView#opencm
 */
/**
 * Passes two arguments: type and login of the channel to add.
 *
 * @event module:list.ListView#addchannel
 */
/**
 * The user triggered a manual refresh from the list. Optionally holds the ID of
 * the channel to update, else all channels are to be updated.
 *
 * @event module:list.ListView#refresh
 * @type {number?}
 */
/**
 * The user wishes to open the a channel by approriate means. The second
 * parameter specifies the means, like the "what" parameter of
 * {@link module:channel/utils.selectOrOpenTab}.
 *
 * @event module:list.ListView#open
 * @type {number}
 */
/**
 * The user wishes to pause the update queue.
 *
 * @event module:list.ListView#pause
 */
/**
 * The user wishes to resume the update queue.
 *
 * @event module:list.ListView#resume
 */
/**
 * The list is ready for modifications.
 *
 * @event module:list.ListView#ready
 */
/**
 * @typedef Style
 * @type {number}
 */
/**
 * @typedef {number} NonLiveDisplay
 */

const LIVE_ICONS = {
    "16": "assets/images/icon16.png",
    "18": "assets/images/icon18.png",
    "32": "assets/images/icon32.png",
    "36": "assets/images/icon36.png",
    "48": "assets/images/icon48.png",
    "64": "assets/images/icon64.png"
},
      OFFLINE_ICONS = {
    "16": "assets/images/offline16.png",
    "18": "assets/images/offline18.png",
    "32": "assets/images/offline32.png",
    "36": "assets/images/offline36.png",
    "48": "assets/images/offline48.png",
    "64": "assets/images/offline64.png"
},
      _ = browser.i18n.getMessage;

/**
 * @class module:list.ListView
 * @extends external:EventTarget
 */
class ListView extends __WEBPACK_IMPORTED_MODULE_4_event_target_shim___default.a {
    /**
     * @constructs
     * @fires module:list.ListView#opencm
     * @fires module:list.ListView#addchannel
     * @fires module:list.ListView#ready
     * @fires module:list.ListView#open
     * @fires module:list.ListView#refresh
     * @fires module:list.ListView#pause
     * @fires module:list.ListView#resume
     * @alias module:list.ListView
     */

    /**
     * Display non-live channels in their own category.
     * @const {module:list~NonLiveDisplay
     * @default 2
     */


    /**
     * Display non-live channels as live.
     *
     * @const {module:list~NonLiveDisplay}
     * @default 0
     */

    /**
     * @const {module:list~Style}
     * @default 1
     */
    constructor() {
        super();

        this.ready = false;
        this.port = null;
        this._liveState = false;
        this.live = new Set();
        this.nonlive = new Set();

        browser.runtime.onConnect.addListener(port => {
            if (port.name == "list") {
                this._setupPort(port);
            }
        });

        __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].addEventListener("change", event => {
            if (event.pref == "panel_badge") {
                this.updateBadge();
            }
        }, { passive: false });
    }
    /**
     * Display non-live channels as offline (ignore their liveness). This is handled
     * directly in this module, so the channel gets passed as going offline.
     * @const {module:list~NonLiveDisplay}
     * @default 3
     */

    /**
     * Display non-live channels as live but sort them to the bottom if possible.
     * @const {module:list~NonLiveDisplay}
     * @default 1
     */

    /**
     * @const {module:list~Style}
     * @default 2
     */

    /**
     * @const {module:list~Style}
     * @default 0
     */


    _setupPort(port) {
        this.port = port;

        this.setNonLiveDisplay();
        this.port.onMessage.addListener(event => {
            if (event.target == "openUrl") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "open", event.channelId);
            } else if (event.target == "openChat") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "open", event.channelId, "chat");
            } else if (event.target == "openArchive") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "open", event.channelId, "archive");
            } else if (event.target == "refresh") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "refresh", event.channelId);
            } else if (event.target == "configure") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "opencm");
            } else if (event.target == "add") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "addchannel", event.type, event.login);
            } else if (event.target == "pause") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "pause");
            } else if (event.target == "resume") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "resume");
            } else if (event.target == "ready") {
                this.ready = true;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "ready");
            } else if (event.target == "search") {
                __WEBPACK_IMPORTED_MODULE_3__providers__["a" /* default */][event.type].search(event.query).then(channels => this.setFeatured(channels.map(c => c.serialize()), event.type, event.query), () => this.setFeatured([], event.type, event.query));
            } else if (event.target == "explore") {
                if (event.type) {
                    __WEBPACK_IMPORTED_MODULE_3__providers__["a" /* default */][event.type].getFeaturedChannels().then(channels => this.setFeatured(channels.map(c => c.serialize()), event.type), () => this.setFeatured([], event.type));
                }
            } else if (event.target == "copy") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "copy", event.channelId);
            } else if (event.target == "copyexternal") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "copy", event.login, event.type);
            } else if (event.target == "removedLive") {
                this._unregisterChannel(event.channelId);
            }
        });

        this.port.onDisconnect.addListener(() => {
            this.port = null;
        });
    }

    _emitToList(event, data) {
        if (this.port) {
            this.port.postMessage({
                target: event,
                data
            });
        }
    }

    get countNonlive() {
        return this.nonLiveDisplay < ListView.DISTINCT;
    }

    async updateBadge() {
        const size = this.live.size + (this.countNonlive ? this.nonlive.size : 0);
        if (size > 0) {
            if (await __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get("panel_badge")) {
                browser.browserAction.setBadgeText({
                    text: size.toString()
                });
            } else {
                browser.browserAction.setBadgeText({
                    text: ""
                });
            }

            browser.browserAction.setIcon({
                path: LIVE_ICONS
            });
            browser.browserAction.setTitle({
                title: _("listTooltipLive")
            });
        } else {
            browser.browserAction.setBadgeText({
                text: ""
            });
            browser.browserAction.setIcon({
                path: OFFLINE_ICONS
            });
            browser.browserAction.setTitle({
                title: _("listTooltipOffline")
            });
        }
    }

    _updateChannel(channel) {
        if (channel.live.state == __WEBPACK_IMPORTED_MODULE_2__channel_live_state__["a" /* default */].OFFLINE) {
            this._unregisterChannel(channel.id);
        } else {
            this._registerChannel(channel);
        }
        this.updateBadge();
    }

    _registerChannel(channel) {
        if (channel.live.state == __WEBPACK_IMPORTED_MODULE_2__channel_live_state__["a" /* default */].LIVE) {
            if (this.nonlive.has(channel.id)) {
                this.nonlive.delete(channel.id);
            }
            this.live.add(channel.id);
        } else {
            if (this.live.has(channel.id)) {
                this.live.delete(channel.id);
            }
            this.nonlive.add(channel.id);
        }
    }

    _unregisterChannel(channelId) {
        if (this.live.has(channelId)) {
            this.live.delete(channelId);
        } else if (this.nonlive.has(channelId)) {
            this.nonlive.delete(channelId);
        }

        if (this.live.size === 0 && (!this.countNonlive || this.nonlive.size === 0)) {
            this.liveState = false;
        }
    }

    /**
     * Indicates the live state over all channels.
     *
     * @memberof module:list.ListView
     * @type {boolean}
     */
    get liveState() {
        return this._liveState;
    }
    set liveState(val) {
        this._liveState = val;
        if (!val) {
            this.live.clear();
            this.updateBadge();
        }
    }

    /**
     * Set the style of the list.
     *
     * @param {module:list~Style} style - Style to set.
     * @returns {undefined}
     */
    setStyle(style = this._style) {
        this._style = style;
        this._emitToList("setStyle", style);
    }

    /**
     * Set the visibility of the extras.
     *
     * @param {boolean} visible - Visibility of extras.
     * @returns {undefined}
     */
    setExtrasVisibility(visible = this._extras) {
        this._extras = visible;
        this._emitToList("setExtras", visible);
    }

    /**
     * Set the display type for non-live content.
     *
     * @param {module:list~NonLiveDisplay} style - Display mode of non-live content.
     * @returns {undefined}
     */
    setNonLiveDisplay(style = this.nonLiveDisplay) {
        this.nonLiveDisplay = style;
        this.updateBadge();
        if (this.nonlive.size > 0 && this.live.size === 0 && style < 2) {
            this.liveState = true;
        }

        this._emitToList("setNonLiveDisplay", style);
    }

    /**
     * Add channels to the list. Updates the live state.
     *
     * @param {Array.<module:channel/core.Channel>} channels - Channels to add.
     * @returns {undefined}
     */
    addChannels(channels) {
        if (channels.some(channel => channel.live.isLive())) {
            this.liveState = true;
        }
        channels.forEach(this._updateChannel, this);
        this.updateBadge();
        this._emitToList("addChannels", channels.map(c => c.serialize()));
    }
    /**
     * Remove a channel from the list. Updates the liveState if appropriate.
     *
     * @param {number} channelId - ID of the channel to remove.
     * @returns {undefined}
     */
    removeChannel(channelId) {
        this._unregisterChannel(channelId);
        this._emitToList("removeChannel", channelId);
    }
    /**
     * Mark a channel as live. Also updates the liveState. Can also be user to
     * update the info of a channel.
     *
     * @param {module:channel/core.Channel} channel - Channel to mark live.
     * @returns {undefined}
     */
    setChannelLive(channel) {
        this._updateChannel(channel);
        this._emitToList("setOnline", channel.serialize());
        this.liveState = true;
    }
    /**
     * Mark a channel as offline. Also updates liveState if appropriate.
     *
     * @param {module:channel/core.Channel} channel - Channel to mark offline.
     * @returns {undefined}
     */
    setChannelOffline(channel) {
        this._updateChannel(channel);
        this._emitToList("setOffline", channel.serialize());
    }

    /**
     * Mark a channel as in a distinct state that is not online or offline.
     *
     * @param {module:channel/core.Channel} channel - Channel to give a distinct
     *                                                state to.
     * @returns {undefined}
     */
    setChannelDistinct(channel) {
        this._updateChannel(channel);
        this._emitToList("setDistinct", channel.serialize());
    }

    /**
     * Set the available providers.
     *
     * @param {Object.<module:providers/generic-provider.GenericProvider>} serializedProviders
     *                                                    - Available providers.
     * @returns {undefined}
     */
    setProviders(serializedProviders) {
        this._emitToList("setProviders", serializedProviders);
    }

    /**
     * Indicate if the update queue is running in the background or not.
     *
     * @param {boolean} enabled - If queue is enabled.
     * @returns {undefined}
     */
    setQueueStatus(enabled) {
        this._emitToList("queueStatus", enabled);
    }

    /**
     * Indicate if the queue is temporarily paused.
     *
     * @param {boolean} paused - If queue is paused.
     * @returns {undefined}
     */
    setQueuePaused(paused) {
        this._emitToList("queuePaused", paused);
    }

    /**
     * Set the theme.
     *
     * @param {number} theme - Theme type.
     * @returns {undefined}
     */
    setTheme(theme) {
        this._emitToList("theme", theme);
    }

    /**
     * Something with the channel changed. Performs appropriate actions based on the
     * state of the channel. Updates liveState if appropriate.
     *
     * @param {module:channel/core.Channel} channel - Channel that changed.
     * @returns {undefined}
     */
    onChannelChanged(channel) {
        if (channel.live.state > 0 && this.nonLiveDisplay === ListView.LIVE_DISTINCT) {
            this.setChannelDistinct(channel);
        } else if (channel.live.isLive()) {
            this.setChannelLive(channel);
        } else {
            this.setChannelOffline(channel);
        }
    }

    setFeatured(channels, type, q = null) {
        this._emitToList("setFeatured", { channels, type, q });
    }
}

ListView.STYLE_COMPACT = 0;
ListView.STYLE_NORMAL = 1;
ListView.STYLE_THUMBNAIL = 2;
ListView.LIVE = 0;
ListView.LIVE_BOTTOM = 1;
ListView.DISTINCT = 2;
ListView.OFFLINE = 3;
/* harmony default export */ __webpack_exports__["a"] = ListView;

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_live_state__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logic__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_event_target_shim__);
/**
 * Model for the Notifications
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module notifier
 */







const _ = browser.i18n.getMessage,


/**
 * Size of the image shown in the notification.
 * @const {number}
 * @default 100
 */
NOTIFICATION_ICON_SIZE = 100;

/**
 * @class module:notifier.Notifier
 * @extends external:EventTarget
 */
class Notifier extends __WEBPACK_IMPORTED_MODULE_4_event_target_shim___default.a {
    /**
     * @constructs
     */
    constructor() {
        super();
        /**
         * The last title of each channel by id the notifier last saw.
         *
         * @type {Map.<number, string>}
         */
        this.channelTitles = new Map();
        /**
         * Proprietary thing I'm too tired to explain, but it stores the relevant
         * info about a channel's current state.
         *
         * @type {Map.<number, object>}
         */
        this.channelStates = new Map();
        browser.notifications.onClicked.addListener(id => {
            if (id.startsWith("cn")) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils__["a" /* emit */])(this, "click", id.substr(2));
            }
        });
    }

    /**
     * If online notifications should be shown.
     *
     * @returns {boolean} Show online notifications when true.
     * @async
     */
    onlineNotifications() {
        return __WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].get("onlineNotification");
    }
    /**
     * If title change notifications should be shown.
     *
     * @returns {boolean} Show title change notifications when true.
     * @async
     */
    titleNotifications() {
        return __WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].get("titleChangeNotification");
    }
    /**
     * If offline notifications should be shown.
     *
     * @returns {boolean} Show offline notifications when true.
     * @async
     */
    offlineNotifications() {
        return __WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].get("offlineNotification");
    }
    /**
     * If non-live types are handled like a non-binary state, they get custom
     * notifications when this is set.
     *
     * @returns {boolean} Show non-live notifications when true.
     * @async
     */
    nonliveNotifications() {
        return __WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].get("nonliveNotification");
    }
    /**
     * If any notifications are to be shown.
     *
     * @returns {boolean} Can show notifications when true.
     * @async
     */
    showNotifications() {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__logic__["b" /* or */])(this.onlineNotifications(), this.titleNotifications(), this.offlineNotifications(), this.nonliveNotifications());
    }
    /**
     * Store a channel's state.
     *
     * @param {module:channel/core.Channel} channel - The channel to store.
     * @returns {undefined}
     */
    _setChannelState(channel) {
        this.channelStates.set(channel.id, {
            state: channel.live.state,
            user: channel.live.alternateUsername
        });
    }
    /**
     * Determine if the state of a channel has changed.
     *
     * @param {module:channel/core.Channel} channel - The channel that might
     *                                                have changed.
     * @returns {boolean} When true the channel state changed.
     */
    _channelStateChanged(channel) {
        const oldState = this.channelStates.get(channel.id);
        return oldState === undefined || oldState.state != channel.live.state || channel.live.state > __WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].LIVE && oldState.user != channel.live.alternateUsername;
    }
    async _getLiveInterpretation() {
        if (await this.nonliveNotifications()) {
            return __WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].TOWARD_LIVE;
        } else {
            return __WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].TOWARD_OFFLINE;
        }
    }
    /**
     * Show a notification to the user, if the channel isn't in the currently
     * active tab, the channel changed accordingly and the respective
     * notification is activated.
     * This also manages the {@link module:notifier.Notifier~channelTitles} Map.
     *
     * @param {module:channel/core.Channel} channel - The channel to show a
     *                                                notification for.
     * @returns {undefined}
     */
    async sendNotification(channel) {
        // Mute notifications for the current tab
        const [tab, showNotifications] = await Promise.all([browser.tabs.query({
            active: true,
            currentWindow: true,
            url: channel.url
        }), this.showNotifications()]);

        if (showNotifications && !tab.length) {
            const liveInterpretation = await this._getLiveInterpretation();
            let title = null;
            if ((await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__logic__["c" /* and */])(channel.live.isLive(__WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].TOWARD_OFFLINE), this.onlineNotifications())) && this._channelStateChanged(channel)) {
                title = _("onlineNotification", channel.toString());
            } else if ((await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__logic__["c" /* and */])(channel.live.isLive(liveInterpretation), this.titleNotifications(), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__logic__["b" /* or */])(channel.live.state === __WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].LIVE, this.nonliveNotifications()))) && !this._channelStateChanged(channel) && this.channelTitles.get(channel.id) != channel.title) {
                title = _("updateNotification", channel.toString());
            } else if ((await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__logic__["c" /* and */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__logic__["a" /* not */])(channel.live.isLive(liveInterpretation)), this.offlineNotifications())) && this.channelTitles.has(channel.id)) {
                title = _("offlineNotification", channel.toString());
            } else if (channel.live.state > __WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].LIVE && (await this.nonliveNotifications()) && this._channelStateChanged(channel)) {
                const stateName = __WEBPACK_IMPORTED_MODULE_1__channel_live_state__["a" /* default */].REDIRECT === channel.live.state ? "Redirect" : "Rebroadcast";
                title = _("nonliveNotification", [channel.toString(), _("nonliveNotificationState" + stateName, channel.live.alternateUsername)]);
            }

            if (title !== null) {
                const opts = {
                    type: "basic",
                    title,
                    message: channel.title,
                    iconUrl: channel.getBestImageForSize(NOTIFICATION_ICON_SIZE)
                };

                browser.notifications.create(`cn${ channel.id }`, opts);
            }
        }

        if (await channel.live.isLive()) {
            this.channelTitles.set(channel.id, channel.title);
        } else {
            this.channelTitles.delete(channel.id);
        }

        this._setChannelState(channel);
    }
    /**
     * Callback to call, whenever an event gets removed. This removes the
     * channel from the internal map.
     *
     * @param {number} channelId - ID of the channel that was removed.
     * @returns {undefined}
     */
    onChannelRemoved(channelId) {
        if (this.channelTitles.has(channelId)) {
            this.channelTitles.delete(channelId);
        }
        if (this.channelStates.has(channelId)) {
            this.channelStates.delete(channelId);
        }
    }

    /**
     * Notify the user, that the string has been copied to the clipboard.
     *
     * @param {string} channelName - Name of the channel that was copied.
     * @returns {undefined}
     */
    notifyCopied(channelName) {
        browser.notifications.create("copy", {
            type: "basic",
            title: _("copyNotification", channelName),
            iconURL: "../images/icon64.png"
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Notifier;


/***/ }),
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(0);
/**
 * Creates a dump of the whole channel list and other relevant settings and
 * can copy it to the clipboard.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/dump
 */




const PREFS_MAPPING = Object.freeze({
    queue: Object.freeze({
        interval: "updateInterval",
        ratio: "queue_ratio",
        maxAmount: "queue_maxRequestBatchSize",
        maxRetries: "queueservice_maxRetries"
    }),
    panel: Object.freeze({
        style: "panel_style",
        extras: "panel_extras",
        width: "panel_minWidth",
        height: "panel_maxHeight",
        badge: "panel_badge"
    }),
    misc: Object.freeze({
        cacheTime: "channellist_cacheTime",
        findMature: "find_mature"
    })
});
/* unused harmony export PREFS_MAPPING */


/**
 * Frozen
 *
 * @typedef {Object} DataDump
 * @property {Array.<Object>} channels - Serialized channels
 * @property {Array.<Object>} users - Serialized users
 * @property {Object} prefs - Collection of important preferences
 * @property {Object} meta - System information
 */

/**
 * Creates a JSON serialized dump of all importand extension data.
 *
 * @param {Array.<module:channel/core.Channel>} channels - Channels to dump.
 * @param {Array.<module:channel/core.User>} users - Users to dump.
 * @returns {module:channel/dump~DataDump} Serialized data dump.
 * @async
 */
const create = async (channels, users) => {
    const p = {};
    const promises = [];
    for (let branch in PREFS_MAPPING) {
        p[branch] = {};
        for (let name in PREFS_MAPPING[branch]) {
            promises.push(__WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].get(PREFS_MAPPING[branch][name]).then(value => {
                p[branch][name] = value;
            }));
        }
    }

    await Promise.all(promises);

    for (let branch in p) {
        Object.freeze(p[branch]);
    }

    const platform = await browser.runtime.getPlatformInfo();
    const manifest = browser.runtime.getManifest();

    const debugDump = {
        channels: channels.map(c => c.serialize()),
        users: users.map(u => u.serialize()),
        prefs: Object.freeze(p),
        meta: Object.freeze({
            version: manifest.version,
            platform: platform.os,
            platformArch: platform.arch,
            language: browser.i18n.getUILanguage(),
            lastError: browser.runtime.lastError
        })
    };
    Object.freeze(debugDump);

    return debugDump;
};
/* unused harmony export create */


/**
 * Creates and copies the data dump to the clipboard.
 *
 * @param {Array.<module:channel/core.Channel>} channels - Channels to dump.
 * @param {Array.<module:channel/core.User>} users - Users to dump.
 */
const copy = async (channels, users) => {
    const data = await exports.create(channels, users),
          p = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__["d" /* when */])(document, "copy");
    document.execCommand("copy", false, null);
    const e = await p;

    e.clipboardData.setData("application/json", JSON.stringify(data, null, 2));
    e.preventDefault();
    console.log("Data dump copied to clipboard");
};
/* harmony export (immutable) */ __webpack_exports__["a"] = copy;


/**
 * @typedef {Object} ChannelsAndUsers
 * @property {Array.<module:channel/core.Channel>} channels
 * @property {Array.<module:channel/core.User>} users
 */

/**
 * Loads a data dump's data into the extension. Applies dumped settings
 * directly.
 *
 * @param {module:channel/dump~DataDump} debugDump - Dump to decode.
 * @returns {module:channel/dump~ChannelsAndUsers} Deserialized channels and
 *          users.
 * @async
 */
const load = debugDump => {
    const promises = [];
    for (let branch in debugDump.prefs) {
        for (let name in debugDump.prefs[branch]) {
            promises.push(__WEBPACK_IMPORTED_MODULE_0__preferences__["a" /* default */].set(PREFS_MAPPING[branch][name], debugDump.prefs[branch][name]));
        }
    }

    return {
        channels: debugDump.channels.map(c => __WEBPACK_IMPORTED_MODULE_1__core__["b" /* Channel */].deserialize(c)),
        users: debugDump.users.map(u => __WEBPACK_IMPORTED_MODULE_1__core__["a" /* User */].deserialize(u))
    };
};
/* unused harmony export load */


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__live_state__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_event_target_shim__);
/**
 * Channel list Object.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/list
 * @requires module:channel/core
 */
// setup event handling






/**
 * IndexedDB version.
 *
 * @const {number}
 * @default 2
 */
const VERSION = 2,


/**
 * Database name.
 *
 * @const {string}
 * @default "channellist"
 */
NAME = "channellist";

/**
 * The ChannelList is ready to be used.
 *
 * @event module:channel/list.ChannelList#ready
 */
/**
 * Whenever one or more channels are added to the ChannelList this event is
 * fired.
 *
 * @event module:channel/list.ChannelList#channelsadded
 * @type {Array.<module:channel/core.Channel>}
 */
/**
 * Whenever a user is added to the ChannelList this event is fired.
 *
 * @event module:channel/list.ChannelList#useradded
 * @type {module:channel/core.User}
 */
/**
 * @event module:channel/list.ChannelList#channelupdated
 * @type {module:channel/core.Channel}
 */
/**
 * @event module:channel/list.ChannelList#userupdated
 * @type {module:channel/core.User}
 */
/**
 * Gets fired before a channel is deleted.
 *
 * @event module:channel/list.ChannelList#beforechanneldeleted
 * @type {number}
 */
/**
 * Gets fired after a channel was deleted.
 *
 * @event module:channel/list.ChannelList#channeldeleted
 * @type {module:channel/core.Channel}
 */
/**
 * @event module:channel/list.ChannelList#userdeleted
 * @type {module:channel/core.User}
 */
/**
 * Fired when all content of the ChannelList is removed. If the first argument
 * is true, the whole DB has been deleted and recreated, most likely to fix it.
 *
 * @event module:channel/list.ChannelList#clear
 * @type {boolean}
 */
/**
 * The database could not be repaired.
 *
 * @event module:channel/list.ChannelList#unfixableerror
 */
/**
 * The datbase was fixed, but all the content was list in the process. User
 * might want to re-add content.
 *
 * @event module:channel/list.ChannelList#fixdb
 */

/**
 * @class module:channel/list.ChannelList
 * @extends external:EventTarget
 */
class ChannelList extends __WEBPACK_IMPORTED_MODULE_4_event_target_shim___default.a {
    /**
     * @constructs
     * @fires module:channel/list.ChannelList#ready
     */

    /**
     * Reference to the DB
     *
     * @type {IndexedDB?}
     */
    constructor() {
        super();

        this.db = null;
        this._openingDB = null;
        this.idCache = new Map();

        this.openDB(NAME);
    }

    /**
     * Opens the DB, initializes the schema if it's a new DB or sets channels
     * offline that were online and have last been updated a certain time ago.
     *
     * @param {string} name - Name of the DB to open.
     * @param {boolean} [dontTry=false] - Don't try to fix the DB.
     * @async
     * @fires module:channel/list.ChannelList#ready
     * @fires module:channel/list.ChannelList#fixdb
     * @returns {undefined} The DB is ready.
     * @throws Could not open the DB.
     */

    /**
     * Holds a promise until the DB is being opened.
     *
     * @type {Promise?}
     */
    openDB(name, dontTry = false) {
        console.log(`ChannelList.openDB(${ name },${ dontTry })`);
        // Quick path if DB is already opened.
        if (this.db) {
            return Promise.resolve();
        } else if (this._openingDB !== null) {
            return this._openingDB;
        }

        this._openingDB = new Promise((resolve, reject) => {
            // Try to open the DB
            const request = window.indexedDB.open(name, VERSION);
            request.onupgradeneeded = e => {
                this.db = e.target.result;

                const users = this.db.createObjectStore("users", { keyPath: "id", autoIncrement: true });
                users.createIndex("typename", ["type", "login"], { unique: true });
                users.createIndex("type", "type", { unique: false });
                //users.createIndex("id", "id", { unique: true });
                const channels = this.db.createObjectStore("channels", { keyPath: "id", autoIncrement: true });
                channels.createIndex("typename", ["type", "login"], { unique: true });
                channels.createIndex("type", "type", { unique: false });
                //channels.createIndex("id", "id", { unique: true });
            };

            // DB is ready
            request.onsuccess = e => {
                this.db = e.target.result;

                __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get("channellist_cacheTime").then(cacheTime => {
                    // Set all channels to offline, that haven't been updated in a certain time.
                    const transaction = this.db.transaction("channels", "readwrite"),
                          store = transaction.objectStore("channels"),
                          minDate = Date.now() - cacheTime,
                          //now - 10 min
                    req = store.index("typename").openCursor();

                    req.onsuccess = event => {
                        const cursor = event.target.result;

                        if (cursor) {
                            this.idCache.set(cursor.value.type + cursor.value.login, cursor.value.id);
                            if (cursor.value.lastModified < minDate) {
                                cursor.value.live.state = __WEBPACK_IMPORTED_MODULE_3__live_state__["a" /* default */].OFFLINE;
                                cursor.update(cursor.value);
                            }
                            cursor.continue();
                        } else {
                            resolve();
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "ready");
                        }
                    };
                });
            };

            /* istanbul ignore next */
            request.onerror = () => {
                if (!dontTry) {
                    if (this.db) {
                        this.db.close();
                        delete this.db;
                    }
                    resolve(this.clear().catch(e => {
                        console.error("Couldn't delete the DB");
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "unfixableerror");
                        throw e;
                    }));
                } else {
                    console.error(request.error);
                    reject();
                }
            };
        });
        // Clear it once the promise is done.
        this._openingDB.then(() => {
            this._openingDB = null;
        }, () => {
            this._openingDB = null;
        });
        return this._openingDB;
    }

    /**
     * Gets the ID of a channel, if it is in the ChannelList.
     *
     * @param {string} name - Login of the channel.
     * @param {string} type - Type of the channel.
     * @async
     * @returns {number} The ID of the channel if it exists.
     */
    getChannelId(name, type) {
        console.info("ChannelList.getChannelId(" + name + "," + type + ")");
        return new Promise((resolve, reject) => {
            if (this.idCache.has(type + name)) {
                console.warn("HIT ID CACHE");
                resolve(this.idCache.get(type + name));
            } else {
                const transaction = this.db.transaction("channels"),
                      index = transaction.objectStore("channels").index("typename"),
                      req = index.get([type, name]);
                req.onsuccess = () => {
                    if (req.result) {
                        this.idCache.set(type + name, req.result.id);
                        resolve(req.result.id);
                    } else {
                        reject();
                    }
                };
                req.onerror = reject;
            }
        });
    }

    /**
     * Gets the ID of a user, if it is in the ChannelList.
     *
     * @param {string} name - Login of the user.
     * @param {string} type - Type of the user.
     * @async
     * @returns {number} The ID of the user (if it exsits).
     */
    getUserId(name, type) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("users"),
                  index = transaction.objectStore("users").index("typename"),
                  req = index.get([type, name]);
            req.onsuccess = () => {
                if (req.result) {
                    resolve(req.result.id);
                } else {
                    reject();
                }
            };
            req.onerror = reject;
        });
    }

    /**
     * Get the specified channel.
     *
     * @param {(number|string)} id - ID of login of the channel.
     * @param {string} [type] - Type of the channel if a login was passed as
     *                             first argument.
     * @returns {module:channel/core.Channel}
     * @throws The channel doesn't exist or no arguments passed.
     */
    async getChannel(id, type) {
        console.info("ChannelList.getChannel(" + id + ")");
        if (type) {
            id = await this.getChannelId(id, type);
        }
        if (!id) {
            throw "No ID specified";
        }

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("channels"),
                  store = transaction.objectStore("channels"),
                  req = store.get(id);

            req.onsuccess = () => {
                if (req.result) {
                    resolve(__WEBPACK_IMPORTED_MODULE_2__core__["b" /* Channel */].deserialize(req.result));
                } else {
                    reject();
                }
            };
            req.onerror = reject;
        });
    }

    /**
     * Get the specified user.
     *
     * @param {(number|string)} id - ID of login of the user.
     * @param {string} [type] - Type of the user if a login was passed as first
     *                             argument.
     * @returns {module:channel/core.User}
     * @throws The user doesn't exist or no arguments passed.
     */
    async getUser(id, type) {
        if (type) {
            id = await this.getUserId(id, type);
        }

        if (!id) {
            throw "No ID specified";
        }

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("users"),
                  store = transaction.objectStore("users"),
                  req = store.get(id);

            req.onsuccess = () => {
                if (req.result) {
                    resolve(__WEBPACK_IMPORTED_MODULE_2__core__["a" /* User */].deserialize(req.result));
                } else {
                    reject();
                }
            };
            req.onerror = reject;
        });
    }

    /**
     * Add a channel to the list.
     *
     * @param {module:channel/core.Channel} channel - The channel to add.
     * @throws {string} If the channel is already in the list.
     * @fires module:channel/list.ChannelList#channelsadded
     * @returns {module:channel/core.Channel} Added channel with the ID set.
     */
    async addChannel(channel) {
        console.info("ChannelList.addChannel(" + channel.login + ")");
        channel.lastModified = Date.now();

        if (await this.channelExists(channel.login, channel.type)) {
            throw "Channel already exists";
        }

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("channels", "readwrite"),
                  store = transaction.objectStore("channels"),
                  req = store.add(channel.serialize());

            req.onsuccess = () => {
                channel.id = req.result;
                this.idCache.set(channel.type + channel.login, channel.id);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "channelsadded", [channel]);
                resolve(channel);
            };
            req.onerror = reject;
        });
    }

    /**
     * Add multiple channels to the list.
     *
     * @param {Array.<module:channel/core.Channel>} channels - The channels to add.
     * @fires module:channel/list.ChannelList#channelsadded
     * @async
     * @returns {Array.<module:channel/core.Channel>} Added channels with their ID set.
     */
    addChannels(channels) {
        console.info("ChannelList.addChannels(channels)");
        if (channels instanceof __WEBPACK_IMPORTED_MODULE_2__core__["b" /* Channel */]) {
            return this.addChannel(channels).then(channel => [channel]);
        } else if (Array.isArray(channels)) {
            if (channels.length == 1) {
                return this.addChannel(channels[0]).then(channel => [channel]);
            } else if (channels.length > 1) {
                return new Promise(resolve => {
                    const transaction = this.db.transaction("channels", "readwrite"),
                          store = transaction.objectStore("channels"),
                          index = store.index("typename"),
                          addedChannels = [];
                    channels.forEach((channel, i) => {
                        const ireq = index.get([channel.type, channel.login]);
                        ireq.onsuccess = () => {
                            if (!ireq.result) {
                                console.log("Adding channel " + channel.login);
                                channel.lastModified = Date.now();
                                const req = store.add(channel.serialize());
                                req.onsuccess = () => {
                                    channels[i].id = req.result;
                                    this.idCache.set(channel.type + channel.login, req.result);
                                    addedChannels.push(channels[i]);
                                };
                                /* istanbul ignore next */
                                req.onerror = () => {
                                    console.error(req.error);
                                };
                            } else {
                                console.log("Channel " + channel.login + " has already been added");
                            }
                        };
                    }, this);
                    transaction.oncomplete = () => {
                        if (addedChannels.length > 0) {
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "channelsadded", addedChannels);
                        }
                        resolve(addedChannels);
                    };
                });
            }
        }
        return Promise.resolve([]);
    }

    /**
     * Add a user to the list.
     *
     * @param {module:channel/core.User} user - The channel to add.
     * @fires module:channel/list.ChannelList#useradded
     * @returns {module:channel/core.User} The newly added User with ID.
     */
    async addUser(user) {
        if (await this.userExists(user.login, user.type)) {
            throw "User already exists";
        }

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("users", "readwrite"),
                  store = transaction.objectStore("users"),
                  req = store.add(user.serialize());

            req.onsuccess = () => {
                user.id = req.result;
                resolve(user);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "useradded", user);
            };
            req.onerror = reject;
        });
    }

    /**
     * Change the data of a channel.
     *
     * @param {module:channel/core.Channel} channel - The new data for the channel.
     * @fires module:channel/list.ChannelList#channelupdated
     * @returns {module:channel/core.Channel} The new version of the channel.
     */
    async setChannel(channel) {
        console.info("ChannelList.setChannel(" + channel.id + ")");
        if (!("id" in channel)) {
            channel.id = await this.getChannelId(channel.login, channel.type);
        }

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("channels", "readwrite"),
                  store = transaction.objectStore("channels");

            channel.lastModified = Date.now();

            const req = store.put(channel.serialize());

            req.onsuccess = () => {
                this.idCache.set(channel.type + channel.login, req.result);
                channel.id = req.result; //TODO was there a reason to fetch the channel here?
                resolve(channel);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "channelupdated", channel);
            };
            req.onerror = reject;
        });
    }

    /**
     * Change the data of a user.
     *
     * @param {module:channel/core.User} user - The new data for the user.
     * @fires module:channel/list.ChannelList#userupdated
     * @returns {module:channel/core.User} The new version of the user stored
     *                                      in the ChannelList.
     */
    async setUser(user) {
        if (!("id" in user)) {
            user.id = await this.getUserId(user.login, user.type);
        }
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("users", "readwrite"),
                  store = transaction.objectStore("users"),
                  req = store.put(user.serialize());

            req.onsuccess = () => {
                user.id = req.result;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "userupdated", user);
                resolve(user);
            };
            req.onerror = reject;
        });
    }

    /**
     * Remove a channel from the list. Also removes all users that have this channel
     * as favorite.
     *
     * @param {(number|string)} id - ID or login of the channel to remove.
     * @param {string} [type] - Type of the channel if no ID was passed.
     * @fires module:channel/list.ChannelList#beforechanneldeleted
     * @fires module:channel/list.ChannelList#channeldeleted
     * @returns {module:channel/core.Channel} Resolves to the removed channel.
     */
    async removeChannel(id, type) {
        console.info("ChannelList.removeChannel(" + id + ")");
        if (type) {
            id = await this.getChannelId(id, type);
        }

        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "beforechanneldeleted", id);
        const channel = await this.getChannel(id);
        await Promise.all([this.removeUsersWithFavorite(id), new Promise((resolve, reject) => {
            const transaction = this.db.transaction("channels", "readwrite"),
                  store = transaction.objectStore("channels"),
                  req = store.delete(id);
            console.log("queued deletion");

            req.onsuccess = () => {
                this.idCache.delete(channel.type + channel.login);
                resolve(channel);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "channeldeleted", channel);
            };
            req.onerror = reject;
        })]);

        return channel;
    }

    /**
     * Remove a user from the list.
     *
     * @param {(number|string)} id - ID or login of the user to remove.
     * @param {string} [type] - Type of the user if no ID was passed.
     * @fires module:channel/list.ChannelList#userdeleted
     * @returns {module:channel/core.User} Resolves to the removed user.
     */
    async removeUser(id, type) {
        const user = await this.getUser(id, type);
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("users", "readwrite"),
                  store = transaction.objectStore("users"),
                  req = store.delete(user.id);

            req.onsuccess = () => {
                resolve(user);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "userdeleted", user);
            };
            req.onerror = reject;
        });
    }

    /**
     * Check if a channel is in the ChannelList.
     *
     * @param {(number|string)} id - ID or login of the channel.
     * @param {string} [type] - Type of the channel if no ID was passed.
     * @async
     * @returns {boolean} Resolves to a boolean indicating if the channel exists.
     */
    channelExists(id, type) {
        console.info("ChannelList.channelExists(", id, ",", type, ")");
        return this.getChannel(id, type).then(channel => !!channel, () => false);
    }

    /**
     * Check if a user is in the ChannelList.
     *
     * @param {(number|string)} id - ID or login of the user.
     * @param {string} [type] - Type of the user if no ID was passed.
     * @async
     * @returns {boolean} Resolves to a boolean indicating if the user exists.
     */
    userExists(id, type) {
        console.info("ChannelList.userExists(", id, ",", type, ")");

        return this.getUser(id, type).then(channel => !!channel, () => false);
    }

    /**
     * Get the live status of the ChannelList as a whole.
     *
     * @param {string} [type] - Check the live state of just the channels of the
     *                             specified type.
     * @todo make live an index and then get all the channels that are live and
     *       count those. That should be slightly faster than this O(n)
     *       operation on the array of all channels.
     * @returns {boolean} Resolves to a boolean indicating, if there are any live
     *                   channels.
     */
    async liveStatus(type) {
        const channels = await this.getChannelsByType(type);
        return channels.some(channel => channel.live.isLive());
    }

    /**
     * Get all channels with the specified type.
     *
     * @param {string} [type] - Type all the channels should have. If left out,
     *                             all channels are returned.
     * @async
     * @returns {Array.<module:channel/core.Channel>}
     */
    getChannelsByType(type) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("channels"),
                  store = transaction.objectStore("channels"),
                  retchans = [];

            transaction.onerror = reject;

            if (!type) {
                store.index("typename").openCursor().onsuccess = event => {
                    const cursor = event.target.result;

                    if (cursor) {
                        retchans.push(__WEBPACK_IMPORTED_MODULE_2__core__["b" /* Channel */].deserialize(cursor.value));
                        cursor.continue();
                    } else {
                        resolve(retchans);
                    }
                };
            } else {
                const keyRange = IDBKeyRange.only(type),
                      index = store.index("type");

                index.openCursor(keyRange).onsuccess = event => {
                    const cursor = event.target.result;

                    if (cursor) {
                        retchans.push(__WEBPACK_IMPORTED_MODULE_2__core__["b" /* Channel */].deserialize(cursor.value));
                        cursor.continue();
                    } else {
                        resolve(retchans);
                    }
                };
            }
        });
    }

    /**
     * Get all users in the ChannelList with a certain type.
     *
     * @param {string} [type] - The type all returned users should have. If left
     *                             out all users are returned.
     * @async
     * @returns {Array.<module:channel/core.User>}
     */
    getUsersByType(type) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction("users"),
                  store = transaction.objectStore("users"),
                  retusrs = [];

            transaction.onerror = reject;

            if (!type) {
                store.index("typename").openCursor().onsuccess = event => {
                    const cursor = event.target.result;

                    if (cursor) {
                        retusrs.push(__WEBPACK_IMPORTED_MODULE_2__core__["a" /* User */].deserialize(cursor.value));
                        cursor.continue();
                    } else {
                        resolve(retusrs);
                    }
                };
            } else {
                const keyRange = IDBKeyRange.only(type),
                      index = store.index("type");

                index.openCursor(keyRange).onsuccess = event => {
                    const cursor = event.target.result;

                    if (cursor) {
                        retusrs.push(__WEBPACK_IMPORTED_MODULE_2__core__["a" /* User */].deserialize(cursor.value));
                        cursor.continue();
                    } else {
                        resolve(retusrs);
                    }
                };
            }
        });
    }

    /**
     * Get all users that have the given channel as a favorite.
     *
     * @param {module:channel/core.Channel} channel - Channel to search users's
     *                                                  favorites for.
     * @returns {Array.<module:channel/core.User>}
     */
    async getUsersByFavorite(channel) {
        const users = await this.getUsersByType(channel.type);
        return users.filter(user => {
            console.log("Scanning user " + user.login + " with the favorites " + user.favorites);
            return user.favorites.indexOf(channel.login) !== -1;
        });
    }

    /**
     * Remove all users that have the given channel as favorite.
     *
     * @param {number} channelId - ID of the channel that users have favorited.
     * @fires module:channel/list.ChannelList#userdeleted
     * @returns {Array.<module:channel/core.User>}
     */
    async removeUsersWithFavorite(channelId) {
        const channel = await this.getChannel(channelId);
        const users = await this.getUsersByFavorite(channel);
        return Promise.all(users.map(user => {
            console.log("Removing user " + user.login + " because he follows " + channel.login);
            return this.removeUser(user.id);
        }));
    }

    /**
     * Get all channels that are favorited by a user.
     *
     * @param {module:channel/core.User} user - User to get the favorites of.
     * @returns {Array.<module:channel/core.Channel>}
     */
    async getChannelsByUserFavorites(user) {
        const channels = await this.getChannelsByType(user.type);
        return channels.filter(channel => {
            return user.favorites.some(channame => channame == channel.login);
        });
    }

    /**
     * Remove all channels that are favorited by a user.
     *
     * @param {number} userId - ID of the user whose favorites should be removed.
     * @fires module:channel/list.ChannelList#channeldeleted
     * @fires module:channel/list.ChannelList#beforechanneldeleted
     * @returns {Array.<module:channel/core.Channel>}
     */
    async removeChannelsByUserFavorites(userId) {
        const user = await this.getUser(userId),
              channels = await this.getChannelsByUserFavorites(user);
        return Promise.all(channels.map(channel => {
            return this.removeChannel(channel.id);
        }));
    }

    /**
     * Clear all contents of the ChannelList. Sometimes reinitializes the DB from
     * scratch.
     *
     * @fires module:channel/list.ChannelList#clear
     * @fires module:channel/list.ChannelList#ready
     * @async
     * @returns {boolean} If true the DB was deleted.
     */
    clear() {
        console.info("ChannelList.clear");

        const done = (hard = false) => {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "clear", hard);
            return Promise.resolve(hard);
        };

        if (this.db) {
            console.info("Clearing object stores");
            const transaction = this.db.transaction(["channels", "users"], "readwrite"),
                  channels = transaction.objectStore("channels"),
                  users = transaction.objectStore("users"),
                  chanPromise = new Promise((resolve, reject) => {
                const chanReq = channels.clear();
                chanReq.onerror = reject;
                chanReq.onsuccess = resolve;
            }),
                  usrPromise = new Promise((resolve, reject) => {
                const usrReq = users.clear();
                usrReq.onerror = reject;
                usrReq.onsuccess = resolve;
            });
            return Promise.all([chanPromise, usrPromise]).then(() => done(false));
        } else {
            console.log("Deleting and reinitializing the DB");
            /*
             * This is the slower path, so we avoid it. It needs all transactions
             * to be done in order to slowly erase the whole DB from the disk, just
             * to reinitialize it afterward.
             */
            const promise = new Promise((resolve, reject) => {
                const request = indexedDB.deleteDatabase(NAME);

                request.onerror = reject;
                request.onsuccess = () => resolve();
                /* istanbul ignore next */
                request.onblocked = () => console.log("Deleting database was blocked");
            });

            // Reopen the DB after it's been cleared. Don't try to fix it, if it
            // doesn't want to open.
            return promise.then(() => done(true)).then(() => this.openDB(NAME, true)).then(() => true);
        }
    }

    /**
     * Close the DB.
     *
     * @async
     * @returns {undefined} DB is being deleted, or may already be deleted.
     */
    close() {
        return new Promise(resolve => {
            if (this.db) {
                this.db.close();
                this.db = null;
                resolve();
            } else {
                resolve();
            }
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ChannelList;


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_event_target_shim__);
/**
 * Model for the channels manager component.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module channel/manager
 */



/**
 * Store a channel. Listeners should call
 * {@link module:channel/manager.ChannelsManager#onChannelAdded} once the
 * channel was added.
 *
 * @event module:channel/manager.ChannelsManager#addchannel
 * @type {string}
 */
/**
 * Remove a channel (given by its ID) and all users that have it as favorite.
 * Listeners should call
 * {@link module:channel/manager.ChannelsManager#onChannelRemoved} once the
 * channel has been removed.
 *
 * @event module:channel/manager.ChannelsManager#removechannel
 * @type {number}
 */
/**
 * Update a channel (given by its ID). Listeners shoudl call
 * {@link module:channel/manager.ChannelsManager#onChannelUpdated} once the
 * channels has been updated.
 *
 * @event module:channel/manager.ChannelsManager#updatechannel
 * @type {number}
 */
/**
 * Store a user. Listeners should call
 * {@link module:channel/manager.ChannelsManager#onUserAdded} once the user has
 * been added.
 *
 * @event module:channel/manager.ChannelsManager#adduser
 * @type {string}
 */
/**
 * Remove a user (given by it ID). If the second argument is true, delete all
 * its favorited channels, too. Listeners should call
 * {@link module:channel/manager.ChannelsManager#onUserRemoved} once the user
 * was removed.
 *
 * @event module:channel/manager.ChannelsManager#removeuser
 * @type {number}
 */
/**
 * Update the favorites of the given user (by ID) or all users, if no ID was
 * specified. Should call the approriate update callbacks on the ChannelsManager
 * once done.
 *
 * @event module:channel/manager.ChannelsManager#updatefavorites
 * @type {number}
 */
/**
 * Search for accounts of the user on supported sites.
 *
 * @event module:channel/manager.ChannelsManager#autoadd
 *
 */
/**
 * Add all existing channels and users via the on callbacks.
 *
 * @event module:channel/manager.ChannelsManager#getdata
 */
/**
 * Shift clicked help button to export debug info.
 *
 * @event module:channel/manager.ChannelsManager#debugdump
 */
/**
 * Show add-on options.
 *
 * @event module:channel/manager.ChannelsManager#showoptions
 */

/**
 * @class
 * @extends external:EventTarget
 */
class ChannelsManager extends __WEBPACK_IMPORTED_MODULE_1_event_target_shim___default.a {
    /**
     * @constructs
     * @fires module:channel/manager.ChannelsManager#addchannel
     * @fires module:channel/manager.ChannelsManager#removechannel
     * @fires module:channel/manager.ChannelsManager#updatechannel
     * @fires module:channel/manager.ChannelsManager#adduser
     * @fires module:channel/manager.ChannelsManager#removeuser
     * @fires module:channel/manager.ChannelsManager#updatefavorites
     * @fires module:channel/manager.ChannelsManager#autoadd
     * @fires module:channel/manager.ChannelsManager#getdata
     * @fires module:channel/manager.ChannelsManager#debugdump
     * @fires module:channel/manager.ChannelsManager#showoptions
     */
    constructor() {
        super();

        this._loading = true;
        this.port = null;
        this.tabID = null;
        this.cancelingValues = new Map();

        browser.runtime.onConnect.addListener(port => {
            if (port.name == "manager") {
                this._setupPort(port);
            }
        });
    }
    /**
     * @type {boolean}
     * @private
     */
    get loading() {
        return this._loading;
    }
    set loading(val) {
        if (this._loading != val) {
            this._loading = val;
            if (val) {
                this._emitToWorker("isloading");
            } else {
                this._emitToWorker("doneloading");
            }
        }
    }
    _setupPort(port) {
        console.log("[Manager]> Attached");
        const isSecondary = this.port !== null;

        if (!isSecondary) {
            this.port = port;
            this.tabID = port.sender.tab.id;
            this.loading = true;
        }

        port.onDisconnect.addListener(() => {
            this.port = null;
            this.tabID = null;
        });

        port.onMessage.addListener(message => {
            if (message.target == "ready") {
                if (isSecondary) {
                    this._emitToWorker("secondary");
                } else {
                    console.log("[Manager]> Page ready");
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "getdata");
                }
            } else if (isSecondary && message.target == "focus") {
                if (this.tabID !== null) {
                    this.open();
                } else {
                    this._emitToWorker("reload");
                }
            } else if (message.target == "adduser") {
                if (message.username !== null) {
                    this.loading = true;
                    this.cancelingValues.set("user" + message.type + message.username, false);
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "adduser", message.username, message.type, () => this.cancelingValues.get("user" + message.type + message.username));
                }
            } else if (message.target == "autoadd") {
                this.loading = true;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "autoadd");
            } else if (message.target == "addchannel") {
                if (message.username !== null) {
                    this.loading = true;
                    this.cancelingValues.set("channel" + message.type + message.username, false);
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "addchannel", message.username, message.type, () => this.cancelingValues.get("channel" + message.type + message.username));
                }
            } else if (message.target == "cancel") {
                this.loading = false;
                this.cancelingValues.set(message.values.join(""), true);
            } else if (message.target == "removechannel") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "removechannel", message.channelId);
            }
            if (message.target == "removeuser") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "removeuser", message.userId, message.removeFavorites);
            }
            if (message.target == "updatechannel") {
                this.loading = true;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatechannel", message.channelId);
            } else if (message.target == "updatefavorites") {
                this.loading = true;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatefavorites", message.userId);
            } else if (message.target == "debugdump" || message.target == "showoptions") {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, message.target);
            }
        });
    }
    /**
     * Cleans up the canceling value for a request.
     *
     * @param {string} type - Object type (user or channel).
     * @param {string} provider - Object provider name.
     * @param {string} name - Object login.
     * @returns {undefined}
     */
    _deleteCancelingValue(type, provider, name) {
        this.cancelingValues.delete(type + provider + name);
    }
    /**
     * Only emits to the worker if it actually exists (isn't null).
     *
     * @param {string} target - Name of the event to emit.
     * @param {?} data - Data to send.
     * @returns {undefined}
     */
    _emitToWorker(target, ...data) {
        if (this.port !== null) {
            if (data.length == 1) {
                data = data[0];
            }
            this.port.postMessage({
                target,
                data
            });
        }
    }
    /**
     * Selects a manager tab, if one's already opened, else opens one.
     *
     * @async
     * @returns {?} The tab with the channels manager.
     */
    open() {
        if (this.tabID === null) {
            return browser.tabs.create({
                url: "./manager/index.html"
            }).then(tab => {
                this.tabID = tab.id;
                return tab;
            });
        } else {
            return browser.tabs.update(this.tabID, {
                active: true
            });
        }
    }
    /**
     * Add providers to the list of available providers in the manager.
     *
     * @param {Object.<module:providers/generic-provider.GenericProvider>} providers
     *                                  - Availabe providers in serialized form.
     * @returns {undefined}
     */
    addProviders(providers) {
        this._emitToWorker("addproviders", providers);
    }
    /**
     * Event callback if a channel was added. Callers should call
     * _deleteCancelingValue if invoked from the manager.
     *
     * @param {module:channel/core.Channel} channelObj - The added channel.
     * @returns {undefined}
     */
    onChannelAdded(channelObj) {
        this.loading = false;
        this._emitToWorker("add", channelObj.serialize());
    }
    /**
     * Callback when a channel was removed.
     *
     * @param {number} channelId - ID of the removed channel.
     * @returns {undefined}
     */
    onChannelRemoved(channelId) {
        this._emitToWorker("remove", channelId);
    }
    /**
     * Callback when a channel was updated.
     *
     * @param {module:channel/core.Channel} channelObj - The updated channel.
     * @returns {undefined}
     */
    onChannelUpdated(channelObj) {
        this.loading = false;
        this._emitToWorker("update", channelObj.serialize());
    }
    /**
     * Callback when a user was added. Callers should call _deleteCancelingValue
     * if invoked from the manager.
     *
     * @param {module:channel/core.User} user - The added user.
     * @returns {undefined}
     */
    onUserAdded(user) {
        this.loading = false;
        this._emitToWorker("adduser", user.serialize());
    }
    /**
     * Callback when a user was removed.
     *
     * @param {number} userId - The ID of the removed user.
     * @returns {undefined}
     */
    onUserRemoved(userId) {
        this._emitToWorker("removeuser", userId);
    }
    /**
     * Callback when a user was updated.
     *
     * @param {module:channel/core.User} user - The user that was updated.
     * @returns {undefined}
     */
    onUserUpdated(user) {
        this.loading = false;
        this._emitToWorker("updateuser", user.serialize());
    }
    /**
     * Callback when an error occurs while adding something.
     *
     * @param {string} [name] - Name of the object that was to be added.
     * @param {string} [type] - Type of the object that was to be added.
     * @param {string} [itemType] - Type of the object that had an error
     *                            (user/channel).
     * @returns {undefined}
     */
    onError(name, type, itemType) {
        this.loading = false;
        if (name) {
            this._deleteCancelingValue(itemType, type, name);
            //TODO move i18n to content
            this._emitToWorker("error", name, type);
        } else {
            this._emitToWorker("error");
        }
    }
    /**
     * Listener to be called when an action is canceled.
     *
     * @param {string} [name] - Name of the object whose action was canceled.
     * @param {string} [type] - Type/provider of the object whose action was
     *        canceled.
     * @param {string} [itemType] - Type of the object whoese action was cacneled.
     * @returns {undefined}
     */
    onCancel(name, type, itemType) {
        this.loading = false;
        this._deleteCancelingValue(itemType, type, name);
    }

    /**
     * Set the theme of the channel manager.
     *
     * @param {string} theme - Theme ID of the theme to use.
     * @returns {undefined}
     */
    setTheme(theme) {
        this._emitToWorker("theme", theme);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ChannelsManager;


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sdk__ = __webpack_require__(10);
/**
 * Credentials search wrapper.
 *
 * @author Martin Giger
 * @license MPL-2.0
 */



const search = ({ url }) => {
    return __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].doAction({
        target: "passwords-search",
        url
    });
};
/* harmony export (immutable) */ __webpack_exports__["a"] = search;


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__querystring__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pagination_helper__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__generic_provider__ = __webpack_require__(3);
/*
 * Created by Martin Giger
 * Licensed under MPL 2.0
 */






const type = "azubu",
      baseURL = 'https://api.azubu.tv/public/',
      pageSize = 100;

function getChannelFromJSON(jsonChannel) {
    console.info("Azubu:getChannelFromJSON");
    const ret = new __WEBPACK_IMPORTED_MODULE_2__channel_core__["b" /* Channel */](jsonChannel.user.username, type),
          channelUrl = jsonChannel.url_channel || "http://www.azubu.tv/" + ret.login;
    if ("display_name" in jsonChannel.user) {
        ret.uname = jsonChannel.user.display_name;
    }
    ret.url.push(channelUrl);
    ret.archiveUrl = channelUrl;
    ret.chatUrl = jsonChannel.url_chat;
    ret.image = {
        50: jsonChannel.user.profile.url_photo_small,
        260: jsonChannel.user.profile.url_photo_large
    };
    ret.live.setLive(jsonChannel.is_live);
    ret.thumbnail = jsonChannel.url_thumbnail;
    ret.viewers = jsonChannel.view_count;
    if (ret.title !== null) {
        ret.title = jsonChannel.title;
    }
    ret.category = jsonChannel.category.title;
    return ret;
}

class Azubu extends __WEBPACK_IMPORTED_MODULE_4__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://www.azubu.tv"], this._supportsFavorites = true, this._supportsCredentials = true, this._supportsFeatured = true, _temp;
    }

    async getUserFavorites(username) {
        const [follows, userdata] = await Promise.all([__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
            url: baseURL + "user/" + username + "/followings/list?limit=" + pageSize + "&offset=",
            pageSize,
            request: url => {
                return this._qs.queueRequest(url);
            },
            fetchNextPage(data) {
                return data.parsedJSON && "data" in data.parsedJSON && data.parsedJSON.data.length == data.parsedJSON.limit;
            },
            getItems(data) {
                if (data.parsedJSON && "data" in data.parsedJSON) {
                    return data.parsedJSON.data;
                } else {
                    return [];
                }
            }
        }), this._qs.queueRequest(baseURL + "user/" + username + "/profile")]);
        if (userdata.parsedJSON && "data" in userdata.parsedJSON) {
            const user = new __WEBPACK_IMPORTED_MODULE_2__channel_core__["a" /* User */](userdata.parsedJSON.data.user.username, this._type);
            if ("display_name" in userdata.parsedJSON.data.user) {
                user.uname = userdata.parsedJSON.data.user.display_name;
            }
            user.image = {
                50: userdata.parsedJSON.data.url_photo_small,
                260: userdata.parsedJSON.data.url_photo_large
            };
            user.favorites = follows.map(follow => follow.follow.username);

            const channels = await this.updateChannels(follows.map(follow => {
                return { login: follow.follow.username };
            }));

            return [user, channels];
        } else {
            throw "Couldn't fetch the details for the azubu user " + username;
        }
    }

    getChannelDetails(channelname) {
        return this._qs.queueRequest(baseURL + "channel/" + channelname).then(data => {
            if (data.status == 200 && data.parsedJSON && data.parsedJSON.data) {
                return getChannelFromJSON(data.parsedJSON.data);
            } else {
                throw "Error getting channel details for channel " + channelname;
            }
        });
    }
    updateFavsRequest(users) {
        const urls = users.map(user => baseURL + "user/" + user.login + "/profile");
        this._qs.queueUpdateRequest(urls, this._qs.LOW_PRIORITY, data => {
            if (data.parsedJSON && data.parsedJSON.data) {
                const user = new __WEBPACK_IMPORTED_MODULE_2__channel_core__["a" /* User */](data.parsedJSON.data.user.username, this._type);
                if ("display_name" in data.parsedJSON.data.user) {
                    user.uname = data.parsedJSON.data.user.display_name;
                }
                user.image = {
                    50: data.parsedJSON.data.url_photo_small,
                    260: data.parsedJSON.data.url_photo_large
                };

                const oldUser = users.find(u => u.login === user.login);
                user.id = oldUser.id;

                new __WEBPACK_IMPORTED_MODULE_3__pagination_helper__["b" /* PaginationHelper */]({
                    url: baseURL + "user/" + user.login + "/followings/list?limit=" + pageSize + "&offset=",
                    pageSize,
                    request: url => {
                        return this._qs.queueRequest(url);
                    },
                    fetchNextPage(data) {
                        return data.parsedJSON && "data" in data.parsedJSON && data.parsedJSON.data.length == data.parsedJSON.limit;
                    },
                    getItems(data) {
                        if (data.parsedJSON && "data" in data.parsedJSON) {
                            return data.parsedJSON.data;
                        } else {
                            return [];
                        }
                    },
                    onComplete: follows => {
                        user.favorites = follows.map(follow => follow.follow.username);
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", user);

                        // only add the channels the user wasn't following already.
                        this.updateChannels(follows.filter(follow => oldUser.favorites.every(fav => fav !== follow.follow.username)).map(follow => ({ login: follow.follow.username }))).then(channels => {
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", channels);
                        });

                        oldUser.favorites = user.favorites;
                    }
                });
            }
        });
    }
    updateRequest(channels) {
        const channelnames = channels.map(ch => ch.login).join(",");

        new __WEBPACK_IMPORTED_MODULE_3__pagination_helper__["b" /* PaginationHelper */]({
            url: baseURL + "channel/list?channels=" + channelnames + "&limit=" + pageSize + "&offset=",
            pageSize,
            request: (url, callback, initial) => {
                if (initial) {
                    this._qs.queueUpdateRequest([url], this._qs.HIGH_PRIORITY, callback);
                } else {
                    return this._qs.queueRequest(url);
                }
            },
            fetchNextPage(data) {
                return data.parsedJSON && "data" in data.parsedJSON && data.parsedJSON.data.length === data.parsedJSON.limit;
            },
            onComplete: chans => {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", chans.map(getChannelFromJSON));
            },
            getItems(data) {
                if (data.parsedJSON && data.parsedJSON.data) {
                    return data.parsedJSON.data;
                } else {
                    return [];
                }
            }
        });
    }
    updateChannels(channels) {
        console.info("Azubu.updateChannels");
        if (channels.length === 0) {
            return Promise.resolve([]);
        }

        const channelnames = channels.map(ch => ch.login).join(",");

        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
            url: baseURL + "channel/list?channels=" + channelnames + "&limit=" + pageSize + "&offset=",
            pageSize,
            request: url => {
                return this._qs.queueRequest(url);
            },
            fetchNextPage(data) {
                return data.parsedJSON && "data" in data.parsedJSON && data.parsedJSON.data.length === data.parsedJSON.limit;
            },
            getItems(data) {
                if (data.parsedJSON && data.parsedJSON.data) {
                    return data.parsedJSON.data;
                } else {
                    return [];
                }
            }
        }).then(chans => chans.map(getChannelFromJSON));
    }
    getFeaturedChannels() {
        return this._qs.queueRequest(baseURL + "channel/live/list?limit=60").then(data => {
            if (data.parsedJSON && "data" in data.parsedJSON && data.parsedJSON.data.length) {
                return data.parsedJSON.data.map(getChannelFromJSON);
            } else {
                throw "No featured channels found for " + this.name;
            }
        });
    }
    search(query) {
        return this._qs.queueRequest(baseURL + 'modules/search/channel?' + __WEBPACK_IMPORTED_MODULE_1__querystring__["a" /* default */].stringify({
            orderBy: '{"channel.updatedAt":"desc"}',
            "access_token": '',
            _format: "json",
            q: query
        })).then(data => {
            if (data.parsedJSON && "data" in data.parsedJSON && data.parsedJSON.data.length) {
                return data.parsedJSON.data.map(getChannelFromJSON);
            } else {
                throw "No results found for " + query + " on " + this.name;
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Azubu(type));

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_underscore__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_underscore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_underscore__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pagination_helper__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logic__ = __webpack_require__(15);
/**
 * Beam provider.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/beam
 * @todo checkout socket based events
 */







const type = "beam",
      chatURL = "https://beam.pro/embed/chat/",
      baseURL = 'https://beam.pro/api/v1/',
      pageSize = 50,
      DEFAULT_AVATAR_URL = "https://beam.pro/_latest/img/media/profile.jpg",
      SIZES = ['50', '70', '150', '300'],
      getImageFromUserID = id => {
    const image = {};
    SIZES.forEach(s => {
        image[s] = `${ baseURL }users/${ id }/avatar?w=${ s }&h=${ s }`;
    });
    return image;
};

function getChannelFromJSON(jsonChannel) {
    const ret = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](jsonChannel.token, type);
    ret.live.setLive(jsonChannel.online);
    ret.title = jsonChannel.name;
    ret.viewers = jsonChannel.viewersCurrent;
    // this is the actual thumbnail and not just the default channel thumbnail thing.
    ret.thumbnail = "https://thumbs.beam.pro/channel/" + jsonChannel.id + ".big.jpg";
    ret.url.push("https://beam.pro/" + jsonChannel.token);
    ret.archiveUrl = "https://beam.pro/" + jsonChannel.token;
    ret.chatUrl = chatURL + jsonChannel.token;
    ret.mature = jsonChannel.audience === "18+";
    ret.image = getImageFromUserID(jsonChannel.user.id);
    if (jsonChannel.type !== null) {
        ret.category = jsonChannel.type.name;
    }
    return ret;
}

function getImageFromAvatars(avatars) {
    const image = {};
    if (Array.isArray(avatars) && avatars.length) {
        avatars.forEach(avatar => {
            /*
             * The URL given by the API doesn't work at this point. Reconstruct
             * the one used on the site.
             */
            image[avatar.meta.size.split("x")[0]] = `https://images.beam.pro/${ avatar.meta.size }/https://uploads.beam.pro/avatar/${ avatar.relid }.jpg`;
        });
    } else {
        image["220"] = DEFAULT_AVATAR_URL;
    }
    return image;
}

class Beam extends __WEBPACK_IMPORTED_MODULE_4__generic_provider__["a" /* default */] {

    constructor(type) {
        super(type);
        this.authURL = ["https://beam.pro"];
        this._supportsFavorites = true;
        this._supportsCredentials = true;
        this._supportsFeatured = true;
        this._getUserIdFromUsername = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_underscore__["memoize"])(username => {
            return this._qs.queueRequest(baseURL + "users/search?query=" + username).then(response => {
                if (response.ok && response.parsedJSON) {
                    return response.parsedJSON.find(val => val.username == username).id;
                }
                throw `Could not find user for ${ username }`;
            });
        });
    }
    async getUserFavorites(username) {
        const userid = await this._getUserIdFromUsername(username),
              user = await this._qs.queueRequest(baseURL + "users/" + userid);

        if (user.parsedJSON) {
            const ch = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["a" /* User */](user.parsedJSON.username, this._type);
            if ("avatars" in user.parsedJSON) {
                ch.image = getImageFromAvatars(user.parsedJSON.avatars);
            } else {
                ch.image = getImageFromUserID(user.parsedJSON.id);
            }

            const subscriptions = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
                url: baseURL + "users/" + userid + "/follows?limit=" + pageSize + "&page=",
                pageSize,
                initialPage: 0,
                request: url => this._qs.queueRequest(url),
                getPageNumber(page) {
                    return ++page;
                },
                fetchNextPage(data, pageSize) {
                    return data.parsedJSON && data.parsedJSON.length == pageSize;
                },
                getItems(data) {
                    return data.parsedJSON || [];
                }
            });

            ch.favorites = subscriptions.map(sub => sub.token);

            const channels = await Promise.all(subscriptions.map(sub => this.getChannelDetails(sub.token)));

            return [ch, channels];
        } else {
            throw `Could not get favorites for user ${ username } on ${ this.name }`;
        }
    }
    async updateFavsRequest(users) {
        const urls = await Promise.all(users.map(user => this._getUserIdFromUsername(user.login).then(id => baseURL + "users/" + id)));

        this._qs.queueUpdateRequest(urls, this._qs.LOW_PRIORITY, (data, url) => {
            if (data.parsedJSON) {
                const ch = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["a" /* User */](data.parsedJSON.username, this._type);
                if ("avatars" in data.parsedJSON) {
                    ch.image = getImageFromAvatars(data.parsedJSON.avatars);
                } else {
                    ch.image = getImageFromUserID(data.parsedJSON.id);
                }

                const oldUser = users.find(usr => usr.login === ch.login);
                ch.id = oldUser.id;

                new __WEBPACK_IMPORTED_MODULE_3__pagination_helper__["b" /* PaginationHelper */]({
                    url: url + "/follows?limit=" + pageSize + "&page=",
                    pageSize,
                    initialPage: 0,
                    request: url => this._qs.queueRequest(url),
                    getPageNumber: page => page + 1,
                    fetchNextPage(data, pageSize) {
                        return data.parsedJSON && data.parsedJSON.length == pageSize;
                    },
                    getItems: data => data.parsedJSON || [],
                    onComplete: follows => {
                        ch.favorites = follows.map(sub => sub.token);
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", ch);

                        Promise.all(follows.filter(sub => {
                            return oldUser.favorites.every(fav => fav !== sub.token);
                        }).map(sub => this.getChannelDetails(sub.token))).then(channels => {
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", channels);
                            oldUser.favorites = ch.favorites;
                        });
                    }
                });
            }
        });
    }
    getChannelDetails(channelname) {
        return this._qs.queueRequest(baseURL + "channels/" + channelname).then(response => {
            if (response.parsedJSON) {
                return getChannelFromJSON(response.parsedJSON);
            } else {
                throw "Error getting the details for the beam channel " + channelname;
            }
        });
    }
    updateRequest(channels) {
        const urls = channels.map(channel => `${ baseURL }channels/${ channel.login }`);
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, data => {
            if (data.parsedJSON) {
                const channel = getChannelFromJSON(data.parsedJSON);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", channel);
            }
        });
    }
    async getFeaturedChannels() {
        const data = await this._qs.queueRequest(baseURL + "channels?limit=8&page=0&order=online%3Adesc%2CviewersCurrent%3Adesc%2CviewersTotal%3Adesc&where=suspended.eq.0%2Conline.eq.1");
        if (data.parsedJSON && data.parsedJSON.length) {
            let chans = data.parsedJSON;
            if (await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__logic__["a" /* not */])(this._mature())) {
                chans = chans.filter(ch => ch.audience !== "18+");
            }

            return chans.map(chan => getChannelFromJSON(chan));
        } else {
            throw "Didn't find any featured channels for " + this.name;
        }
    }
    async search(query) {
        const data = await this._qs.queueRequest(baseURL + "channels?where=online.eq.1%2Ctoken.eq." + query);
        if (data.parsedJSON && data.parsedJSON.length) {
            let chans = data.parsedJSON;
            if (await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__logic__["a" /* not */])(this._mature())) {
                chans = chans.filter(ch => ch.audience !== "18+");
            }

            return chans.map(chan => getChannelFromJSON(chan));
        } else {
            throw "No results for " + query + " on " + this.name;
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Beam(type));

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pagination_helper__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__querystring__ = __webpack_require__(8);
/**
 * Dailymotion provider.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/dailymotion
 */






const type = "dailymotion",
      baseUrl = "https://api.dailymotion.com/",
      AVATAR_SIZES = [25, 60, 80, 120, 190, 240, 360, 480, 720],
      USER_FIELDS = "screenname,url,id," + AVATAR_SIZES.map(s => "avatar_" + s + "_url").join(","),
      getChannelFromJSON = (json, doUser = false) => {
    let ch;
    if (doUser) {
        ch = new __WEBPACK_IMPORTED_MODULE_2__channel_core__["a" /* User */](json.id, type);
    } else {
        ch = new __WEBPACK_IMPORTED_MODULE_2__channel_core__["b" /* Channel */](json.id, type);
        ch.url.push(json.url);
        ch.archiveUrl = json.url;
    }
    ch.uname = json.screenname;
    ch.image = AVATAR_SIZES.reduce((p, c) => {
        p[c] = json['avatar_' + c + '_url'];
        return p;
    }, {});

    return ch;
};

class Dailymotion extends __WEBPACK_IMPORTED_MODULE_1__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this._supportsFavorites = true, this._supportsFeatured = true, _temp;
    }

    _getChannelByID(id, doUser = false) {
        return this._qs.queueRequest(baseUrl + "user/" + id + "?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
            fields: USER_FIELDS
        })).then(result => {
            if (result.ok && result.parsedJSON) {
                if ("list" in result.parsedJSON) {
                    return getChannelFromJSON(result.parsedJSON.list[0], doUser);
                } else {
                    return getChannelFromJSON(result.parsedJSON, doUser);
                }
            } else {
                throw `Could not get details for ${ id } on ${ this._type }`;
            }
        });
    }
    _getStreamDetailsForChannel(channel) {
        return this._qs.queueRequest(baseUrl + "user/" + channel.login + "/videos?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
            id: channel.login,
            fields: "chat_embed_url,title,url,channel.name,onair,thumbnail_240_url",
            sort: "live-audience",
            limit: 1
        })).then(response => {
            if (response.ok && response.parsedJSON) {
                if (response.parsedJSON.list.length) {
                    const item = response.parsedJSON.list[0];
                    channel.chatUrl = item.chat_embed_url;
                    channel.thumbnail = item.thumbnail_url;
                    channel.url = [item.url];
                    channel.category = item['channel.name'];
                    channel.live.setLive(item.onair);
                    channel.title = item.title;
                } else {
                    channel.live.setLive(false);
                }
                return channel;
            } else {
                throw `Could not update ${ channel.login } on ${ this._type }`;
            }
        });
    }
    _getFavs(userId) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
            url: baseUrl + "user/" + userId + "/following?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
                fields: USER_FIELDS,
                limit: 100
            }) + "&page=",
            pageSize: 1,
            initialPage: 1,
            request: url => this._qs.queueRequest(url),
            fetchNextPage(data) {
                return data.json && data.parsedJSON.has_more;
            },
            getItems(data) {
                if (data.ok && data.parsedJSON && data.parsedJSON.list) {
                    return data.parsedJSON.list.map(getChannelFromJSON);
                } else {
                    return [];
                }
            }
        });
    }
    getUserFavorites(username) {
        return this.getChannelDetails(username, true).then(user => {
            return this._getFavs(user.login).then(channels => {
                user.favorites = channels.map(ch => ch.login);

                return [user, channels];
            });
        });
    }
    getChannelDetails(username, doUser = false) {
        return this._qs.queueRequest(baseUrl + "users?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
            usernames: username,
            fields: USER_FIELDS
        }), {}).then(result => {
            if (result.ok && result.parsedJSON && result.parsedJSON.list && result.parsedJSON.list.length) {
                return getChannelFromJSON(result.parsedJSON.list[0], doUser);
            } else {
                return this._getChannelByID(username, doUser);
            }
        });
    }
    updateFavsRequest(users) {
        new __WEBPACK_IMPORTED_MODULE_3__pagination_helper__["b" /* PaginationHelper */]({
            url: baseUrl + "users?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
                ids: users.map(ch => ch.login).join(","),
                fields: USER_FIELDS,
                limit: 100
            }) + "&page=",
            initialPage: 1,
            pageSize: 1,
            request: (url, callback, initial) => {
                if (initial) {
                    this._qs.queueUpdateRequest([url], this._qs.LOW_PRIORITY, callback);
                } else {
                    return this._qs.queueRequest(url);
                }
            },
            fetchNextPage(data) {
                return data.parsedJSON && data.parsedJSON.has_more;
            },
            getItems(data) {
                if (data.ok && data.parsedJSON && data.parsedJSON.list) {
                    return data.parsedJSON.list;
                } else {
                    return [];
                }
            },
            onComplete: data => {
                data = data.map(d => getChannelFromJSON(d, true));

                data.forEach(user => {
                    const oldUser = users.find(u => u.login == user.login);
                    this._getFavs(user.login).then(channels => {
                        user.favorites = channels.map(ch => ch.login);
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", user);

                        channels = channels.filter(ch => !oldUser.favorites.some(c => c == ch.login));
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", channels);

                        oldUser.favorites = user.favorites;
                    });
                });
            }
        });
    }
    updateRequest(channels) {
        new __WEBPACK_IMPORTED_MODULE_3__pagination_helper__["b" /* PaginationHelper */]({
            url: baseUrl + "users?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
                ids: channels.map(ch => ch.login).join(","),
                fields: USER_FIELDS,
                limit: 100
            }) + "&page=",
            initialPage: 1,
            pageSize: 1,
            request: (url, callback, initial) => {
                if (initial) {
                    this._qs.queueUpdateRequest([url], this._qs.HIGH_PRIORITY, callback);
                } else {
                    return this._qs.queueRequest(url);
                }
            },
            fetchNextPage(data) {
                return data.parsedJSON && data.parsedJSON.has_more;
            },
            getItems(data) {
                if (data.ok && data.parsedJSON && data.parsedJSON.list) {
                    return data.parsedJSON.list;
                } else {
                    return [];
                }
            },
            onComplete: data => {
                data = data.map(v => getChannelFromJSON(v));

                Promise.all(data.map(ch => this._getStreamDetailsForChannel(ch))).then(channels => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", channels));
            }
        });
    }
    updateChannel(username) {
        return this.getChannelDetails(username).then(channel => {
            return this._getStreamDetailsForChannel(channel);
        });
    }
    async updateChannels(channels) {
        const response = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
            url: baseUrl + "users?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
                ids: channels.map(ch => ch.login).join(","),
                fields: USER_FIELDS,
                limit: 100
            }) + "&page=",
            pageSize: 1,
            initialPage: 1,
            request: url => this._qs.queueRequest(url),
            fetchNextPage(data) {
                return data.parsedJSON && data.parsedJSON.has_more;
            },
            getItems(data) {
                if (data.parsedJSON && data.parsedJSON.list) {
                    return data.parsedJSON.list;
                } else {
                    return [];
                }
            }
        });

        return Promise.all(response.map(ch => this._getStreamDetailsForChannel(getChannelFromJSON(ch))));
    }
    search(query) {
        const q = {
            fields: "owner.id,owner.screenname,owner.url,chat_embed_url,title,url,channel.name,thumbnail_240_url," + AVATAR_SIZES.map(s => "owner.avatar_" + s + "_url").join(","),
            sort: "live-audience",
            "live_onair": 1
        };
        if (query) {
            q.search = query;
        }
        return this._qs.queueRequest(baseUrl + "videos?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify(q)).then(data => {
            if (data.ok && data.parsedJSON && data.parsedJSON.list && data.parsedJSON.list.length) {
                return data.parsedJSON.list.map(json => {
                    const ch = new __WEBPACK_IMPORTED_MODULE_2__channel_core__["b" /* Channel */](json['owner.id'], this._type);
                    ch.live.setLive(true);
                    ch.title = json.title;
                    ch.uname = json['owner.screenname'];
                    ch.url.push(json.url, json['owner.url']);
                    ch.archiveUrl = json['owner.url'];
                    ch.chatUrl = json.chat_embed_url;
                    ch.category = json['channel.name'];
                    ch.thumbnail = json.thumbnail_240_url;
                    ch.image = AVATAR_SIZES.reduce((p, s) => {
                        p[s] = json['owner.avatar_' + s + '_url'];
                        return p;
                    }, {});

                    return ch;
                });
            } else {
                throw "Didn't find any search results channels with " + query + " for " + this._type;
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Dailymotion(type));

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_md5__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_md5__);
/**
 * Douyutv provider. API reverseengineering is in #125.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/douyutv
 * @todo support adding by url slug name
 */





const type = "douyutv",
      baseURL = "http://www.douyutv.com/api/v1/",
      roomURL = "http://www.douyutv.com",
      getChannelFromJSON = json => {
    const chan = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](json.room_id, type);
    chan.uname = json.room_name;
    chan.title = json.subject;
    chan.url.push(roomURL + json.url);
    chan.image = {
        200: json.owner_avatar
    };
    chan.archiveUrl = roomURL + json.url;
    chan.live.setLive(json.show_status == "1");
    chan.thumbnail = json.room_src;
    chan.category = json.game_name;
    chan.viewers = json.online;
    return chan;
},
      signAPI = (endpoint, id) => {
    const argument = endpoint + id + "?aid=android&client_sys=android&time=" + Date.now(),
          sign = __WEBPACK_IMPORTED_MODULE_3_md5___default()(argument + '1231');
    return argument + "&auth=" + sign;
};

class Douyutv extends __WEBPACK_IMPORTED_MODULE_2__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://www.douyutv.com"], _temp;
    }

    getChannelDetails(username) {
        return this._qs.queueRequest(baseURL + signAPI("room/", username)).then(data => {
            if (data.parsedJSON && data.parsedJSON.error === 0) {
                return getChannelFromJSON(data.parsedJSON.data);
            } else {
                throw "Couldn't get room info for douyutv channel with ID " + username;
            }
        });
    }
    updateRequest(channels) {
        const urls = channels.map(ch => baseURL + signAPI("room/", ch.login));
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, data => {
            if (data.parsedJSON && data.parsedJSON.error === 0) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", getChannelFromJSON(data.parsedJSON.data));
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Douyutv(type));

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_event_target_shim__);
/**
 * Re-emits events from all providers.
 *
 * @author Martin Giger
 * @license MPL-2.0
 */




const USER_EVENTS = ["updateduser", "newchannels"],
      BASE_EVENTS = ["updatedchannels"];

class EventSink extends __WEBPACK_IMPORTED_MODULE_2_event_target_shim___default.a {
    constructor() {
        super();

        for (const p in __WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */]) {
            const provider = __WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */][p];
            for (const e of BASE_EVENTS) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["e" /* pipe */])(provider, e, this);
            }

            if (provider.supports.favorites) {
                for (const e of USER_EVENTS) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["e" /* pipe */])(provider, e, this);
                }
            }
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = EventSink;

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pagination_helper__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__querystring__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logic__ = __webpack_require__(15);
/*
 * Created by Martin Giger
 * Licensed under MPL 2.0
 *
 * Hitbox provider
 */







const type = "hitbox",
      archiveURL = "/videos",
      chatURL = "https://hitbox.tv/embedchat/",
      pageSize = 100,
      baseURL = "https://api.hitbox.tv",
      cdnURL = "http://edge.sf.hitbox.tv";

function getChannelFromJson(json) {
    const cho = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](json.channel.user_name, type);
    cho.uname = json.media_display_name;
    cho.url.push(json.channel.channel_link);
    cho.archiveUrl = json.channel.channel_link + archiveURL;
    cho.chatUrl = chatURL + json.channel.user_name;
    cho.image = {
        "200": cdnURL + json.channel.user_logo,
        "50": cdnURL + json.channel.user_logo_small
    };
    cho.title = json.media_status;
    cho.category = json.category_name;
    cho.viewers = json.media_views;
    cho.thumbnail = cdnURL + json.media_thumbnail;
    cho.live.setLive(json.media_is_live != "0");
    cho.mature = json.media_mature === "1";
    return cho;
}

class Hitbox extends __WEBPACK_IMPORTED_MODULE_2__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://www.hitbox.tv"], this._supportsFavorites = true, this._supportsCredentials = true, this._supportsFeatured = true, _temp;
    }

    _getChannels(channels) {
        return Promise.all(channels.map(channel => {
            return this._qs.queueRequest(baseURL + '/media/live/' + channel).then(data => {
                if (data.ok && data.parsedJSON && "livestream" in data.parsedJSON) {
                    return getChannelFromJson(data.parsedJSON.livestream[0]);
                } else {
                    return null;
                }
            });
        })).then(channels => channels.filter(channel => channel !== null));
    }
    async getUserFavorites(username) {
        const [follows, user] = await Promise.all([__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
            url: baseURL + '/following/user?user_name=' + username + '&limit=' + pageSize + '&offset=',
            pageSize,
            request: url => this._qs.queueRequest(url),
            fetchNextPage(data, pageSize) {
                return data.parsedJSON && "following" in data.parsedJSON && data.parsedJSON.following.length == pageSize;
            },
            getItems(data) {
                if (data.parsedJSON && "following" in data.parsedJSON) {
                    return data.parsedJSON.following;
                } else {
                    return [];
                }
            }
        }), this._qs.queueRequest(baseURL + '/user/' + username)]);

        if (user.ok && user.parsedJSON && user.parsedJSON.user_name !== null) {
            const usr = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["a" /* User */](user.parsedJSON.user_name, this._type);
            usr.image = {
                "200": cdnURL + user.parsedJSON.user_logo,
                "50": cdnURL + user.parsedJSON.user_logo_small
            };
            usr.favorites = follows.map(follow => follow.user_name);

            const channels = await this._getChannels(usr.favorites);
            return [usr, channels];
        } else {
            throw "Error getting info for Hitbox user " + username;
        }
    }
    getChannelDetails(channelname) {
        return this._qs.queueRequest(baseURL + '/media/live/' + channelname).then(data => {
            if (data.ok && data.parsedJSON && data.parsedJSON.livestream) {
                return getChannelFromJson(data.parsedJSON.livestream[0]);
            } else {
                throw "Error getting details for Hitbox channel " + channelname;
            }
        });
    }
    updateFavsRequest(users) {
        const urls = users.map(user => baseURL + '/user/' + user.login);
        this._qs.queueUpdateRequest(urls, this._qs.LOW_PRIORITY, data => {
            if (data.ok && data.parsedJSON) {
                const user = users.find(user => user.login == data.parsedJSON.user_name);
                user.image = {
                    "200": cdnURL + data.parsedJSON.user_logo,
                    "50": cdnURL + data.parsedJSON.user_logo_small
                };

                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
                    url: baseURL + '/following/user?user_name=' + user.login + '&limit=' + pageSize + '&offset=',
                    pageSize,
                    request: url => this._qs.queueRequest(url),
                    fetchNextPage(data, pageSize) {
                        return data.parsedJSON && "following" in data.parsedJSON && data.parsedJSON.following.length == pageSize;
                    },
                    getItems(data) {
                        if (data.parsedJSON && "following" in data.parsedJSON) {
                            return data.parsedJSON.following;
                        } else {
                            return [];
                        }
                    }
                }).then(follows => {
                    const newChannels = follows.filter(follow => user.favorites.every(fav => fav != follow.user_name));
                    user.favorites = follows.map(follow => follow.user_name);
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", user);
                    return this._getChannels(newChannels.map(follow => follow.user_name));
                }).then(channels => {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", channels);
                });
            }
        });
    }
    updateRequest(channels) {
        const urls = channels.map(channel => baseURL + '/media/live/' + channel.login);
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, data => {
            if (data.ok && data.parsedJSON && data.parsedJSON.livestream) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", getChannelFromJson(data.parsedJSON.livestream[0]));
            }
        });
    }
    async search(query) {
        const data = await this._qs.queueRequest(baseURL + "/media/live/list?" + __WEBPACK_IMPORTED_MODULE_4__querystring__["a" /* default */].stringify({
            publicOnly: true,
            filter: "popular",
            search: query
        }));
        if (data.ok && data.parsedJSON && data.parsedJSON.livestream && data.parsedJSON.livestream.length) {
            let chans = data.parsedJSON.livestream;
            if (await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__logic__["a" /* not */])(this._mature())) {
                chans = chans.filter(m => m.media_mature !== "1");
            }

            return chans.map(chan => getChannelFromJson(chan));
        } else {
            throw "Couldn't find any channels for the search on " + this.name + " that match " + query;
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Hitbox(type));

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__generic_provider__ = __webpack_require__(3);
/**
 * @todo implement favorites stuff
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/livestream
 */




const type = "livestream",
      baseURL = ".api.channel.livestream.com/2.0/";

function getChannelAPIUrl(channellogin) {
    return "http://x" + channellogin.replace(/_/g, "-") + "x" + baseURL;
}

class Livestream extends __WEBPACK_IMPORTED_MODULE_2__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://new.livestream.com", "https://secure.livestream.com"], _temp;
    }

    async getChannelDetails(username) {
        const ch = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](username.toLowerCase(), this._type),
              [data, response] = await Promise.all([this._qs.queueRequest(getChannelAPIUrl(ch.login) + "info.json"), this._qs.queueRequest(getChannelAPIUrl(ch.login) + "latestclips.json?maxresults=1")]);

        if (data.parsedJSON && data.parsedJSON.channel) {
            console.info("Creating livestream channel");
            ch.uname = data.parsedJSON.channel.title;
            ch.title = "";
            ch.url.push(data.parsedJSON.channel.link);
            ch.image = { "100": data.parsedJSON.channel.image.url };
            ch.category = data.parsedJSON.channel.category;
            ch.live.setLive(data.parsedJSON.channel.isLive);
            ch.viewers = data.parsedJSON.channel.currentViewerCount;
            ch.archiveUrl = data.parsedJSON.channel.link;
            ch.chatUrl = data.parsedJSON.channel.link + "/chat";

            if (response.parsedJSON && response.parsedJSON.channel.item && response.parsedJSON.channel.item.length > 0) {
                ch.thumbnail = response.parsedJSON.channel.item[0].thumbnail["@url"];
            }

            return ch;
        } else {
            throw "Error getting details for the Livestream channel " + username;
        }
    }
    updateRequest(channels) {
        const urls = channels.map(channel => getChannelAPIUrl(channel.login) + "livestatus.json");
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, (data, url) => {
            if (data.parsedJSON && data.parsedJSON.channel) {
                const requestLogin = url.match(/http:\/\/x([a-zA-Z0-9-]+)x\./)[1].replace("-", "_"),
                      channel = channels.find(channel => requestLogin == channel.login);
                channel.live.setLive(data.parsedJSON.channel.isLive);
                channel.viewers = data.parsedJSON.channel.currentViewerCount;
                this._qs.queueRequest(getChannelAPIUrl(channel.login) + "latestclips.json?maxresults=1").then(data => {
                    if (data.parsedJSON && "channel" in data.parsedJSON && data.parsedJSON.channel.item.length) {
                        channel.thumbnail = data.parsedJSON.channel.item[0].thumbnail["@url"];
                    }
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", channel);
                });
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Livestream(type));

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__channel_live_state__ = __webpack_require__(6);
/**
 * MLG.tv Provider
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/mlg
 */
/*
Inofficial MLG.tv (major league gaming streams) API doc:

Username: cleartext username used in the channel URL
stream_name: mlg[0-9]+, which seems to be the stream ID
channel_id: [0-9]+, which seems to be the ID for the channel (used in image URLs and chat)


http://tv.majorleaguegaming.com/channel/{username}
http://chat.majorleaguegaming.com/{channel_id}


all of these seem to also support JSONP with the callback= parameter.
http://www.majorleaguegaming.com/player/config.json?id={username} username -> media[0].channel
http://streamapi.majorleaguegaming.com/service/streams/all status of all streams with stream_name and channel_id
http://streamapi.majorleaguegaming.com/service/streams/status/{stream_name} status and viewer count of just the specified stream
    status: -1 for offline, 1 for live, 2 for rebroadcast
http://www.majorleaguegaming.com/api/channels/all.js All the info about all the channels
    field parameter can limit the fields. You'll find the available fields if you don't specify any
http://www.majorleaguegaming.com/api/games/all.js All names and images for all game_id values
http://streamapi.majorleaguegaming.com/service/streams/playback/{stream name}?format=all playback URL + name & id

https://accounts.majorleaguegaming.com/follows/retrieve returns all the channel ids the currently logged in user (cookie mlg_login for username, mlg_id for the id) follows
There are also the actions to follow and unfollow a channel, but I am not sure how they work, as I don't care.

*/






const type = "mlg",
      chatURL = "https://chat.majorleaguegaming.com/",
      baseURL = 'https://streamapi.majorleaguegaming.com/service/streams/',
      infoURL = 'https://www.majorleaguegaming.com/api/channels/all.js',
      gameURL = 'https://www.majorleaguegaming.com/api/games/all.js',
      infoArgs = "?fields=id,slug,name,stream_name,subtitle,image_1_1,image_16_9_medium,url,bracket_url,game_id";

/**
 * @enum {number}
 * @name Status
 * @readonly
 * @property {number} Offline=-1
 * @property {number} Live=1
 * @property {number} Rebroadcast=2
 */
/**
 * @param {module:providers/mlg~Status} status - State of the channel.
 * @returns {boolean} If the channel should be considered live.
 * @async
 */
function isLive(status) {
    return __WEBPACK_IMPORTED_MODULE_2__preferences__["a" /* default */].get("mlg_showRebroadcasts").then(showRebroadcasts => status != -1 && (showRebroadcasts || status != 2));
}

// Takes a game_id
let games = [];

class MLG extends __WEBPACK_IMPORTED_MODULE_3__generic_provider__["a" /* default */] {
    async _getGame(id) {
        const game = games.find(g => g.id == id);
        if (!game) {
            const data = await this._qs.queueRequest(gameURL);
            if (data.parsedJSON && data.parsedJSON.data.items && data.parsedJSON.data.items.length) {
                games = data.parsedJSON.data.items;
                return data.parsedJSON.data.items.find(g => g.id == id).name;
            } else {
                throw data.parsedJSON ? data.parsedJSON.errors : "Could not fetch games for " + this.name;
            }
        } else {
            return game.name;
        }
    }
    async _getChannelFromJSON(jsonChannel) {
        console.info("MLG:getChannelFromJSON");
        const ret = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](jsonChannel.stream_name, this._type);
        ret.uname = jsonChannel.name;
        ret.url.push(jsonChannel.url);
        ret.archiveUrl = jsonChannel.bracket_url ? jsonChannel.bracket_url : jsonChannel.url;
        ret.chatUrl = chatURL + jsonChannel.id;
        ret.image = { "200": jsonChannel.image_1_1 };
        ret.title = jsonChannel.subtitle;
        ret.thumbnail = jsonChannel.image_16_9_medium;
        try {
            const game = await this._getGame(jsonChannel.game_id);
            ret.category = game;
        } catch (e) {
            // ingore
        }

        return ret;
    }
    async getChannelDetails(channelname) {
        const data = await this._qs.queueRequest(infoURL + infoArgs);
        if (data.ok && data.parsedJSON.status_code == 200) {
            const cho = data.parsedJSON.data.items.find(ch => ch.slug.toLowerCase() == channelname.toLowerCase());
            if (cho) {
                return this._getChannelFromJSON(cho);
            }
        }
        throw "Couldn't get the channel details for " + channelname + " for " + this.name;
    }
    updateRequest(channels) {
        this._qs.queueUpdateRequest([baseURL + "all"], this._qs.HIGH_PRIORITY, async data => {
            const info = await this._qs.queueRequest(infoURL + infoArgs);

            if (data.parsedJSON && data.parsedJSON.status_code == 200 && info.parsedJSON && info.parsedJSON.status_code == 200) {
                let chans = data.parsedJSON.data.items.filter(status => {
                    return channels.some(channel => status.stream_name == channel.login);
                });

                chans = await Promise.all(chans.map(async status => {
                    const channel = await this._getChannelFromJSON(info.parsedJSON.data.items.find(ch => ch.id == status.channel_id));
                    if (status.status == 2) {
                        channel.live = new __WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */].REBROADCAST);
                    } else {
                        channel.live.setLive((await isLive(status.status)));
                    }
                    return channel;
                }));
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", chans);
            }
        });
    }
    async updateChannel(channelname) {
        console.info("MLG.updateChannel");
        const [data, info] = await Promise.all([this._qs.queueRequest(baseURL + 'status/' + channelname), this._qs.queueRequest(infoURL + infoArgs)]);
        console.info("MLG.updateChannel.requestCallback");
        if (data.parsedJSON && data.parsedJSON.status_code == 200 && info.parsedJSON && info.parsedJSON.status_code == 200) {
            const id = info.parsedJSON.data.items.find(ch => ch.id == data.parsedJSON.data.channel_id),
                  channel = await this._getChannelFromJSON(id);
            if (data.parsedJSON.data.status == 2) {
                channel.live = new __WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */].REBROADCAST);
            } else {
                channel.live.setLive((await isLive(data.parsedJSON.data.status)));
            }
            channel.viewers = data.parsedJSON.data.viewers;

            return channel;
        } else {
            throw "Something went wrong when updating " + channelname;
        }
    }
    async updateChannels(channels) {
        console.info("MLG.updateChannels");
        const [data, info] = await Promise.all([this._qs.queueRequest(baseURL + "all"), this._qs.queueRequest(infoURL + infoArgs)]);

        if (data.parsedJSON && data.parsedJSON.status_code == 200 && info.parsedJSON && info.parsedJSON.status_code == 200) {
            const followedChannels = data.parsedJSON.data.items.filter(status => {
                return channels.some(channel => status.stream_name == channel.login);
            });
            return Promise.all(followedChannels.map(async status => {
                const id = info.parsedJSON.data.items.find(ch => ch.id == status.channel_id);
                const channel = await this._getChannelFromJSON(id);
                if (status.status == 2) {
                    channel.live = new __WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */].REBROADCAST);
                } else {
                    channel.live.setLive((await isLive(status.status)));
                }
                return channel;
            }));
        }
        throw "Could not update channels";
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new MLG(type));

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pagination_helper__ = __webpack_require__(7);
/**
 * New livestream provider. For API reverseenigneering see Issue #99
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/new-livestream
 */





const type = "newlivestream",
      baseURL = "http://livestream.com/api/accounts/",
      getChannelFromJSON = json => {
    const chan = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](json.short_name || json.id, type);
    chan.uname = json.full_name;
    chan.image = {
        [json.picture.width]: json.picture.url,
        "170": json.picture.small_url,
        "50": json.picture.thumb_url
    };
    chan.category = json.category_name;
    chan.archiveUrl = "http://livestream.com/" + chan.login;
    chan.chatUrl = "http://livestream.com/" + chan.login;
    return chan;
};

class NewLivestream extends __WEBPACK_IMPORTED_MODULE_2__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://livestream.com"], this.supportsFavorites = true, _temp;
    }

    async _getChannelStatus(json, channel) {
        // Checks if there are any upcoming or past events and if yes, if one is currently being broadcast.
        const event = Array.isArray(json.upcoming_events.data) && json.upcoming_events.data.find(event => event.broadcast_id != -1) || Array.isArray(json.past_events.data) && json.past_events.data.find(event => event.broadcast_id != -1);

        if (event) {
            channel.title = event.full_name;
            channel.viewers = event.viewer_count;
            channel.url.push("http://livestream.com/" + channel.login + "/events/" + event.id);
            const info = await this._qs.queueRequest(baseURL + json.id + "/events/" + event.id + "/stream_info");

            if (info.parsedJSON && !("message" in info.parsedJSON)) {
                channel.live.setLive(info.parsedJSON.is_live);
                channel.thumbnail = info.parsedJSON.thumbnail_url;
            }
        }
        return channel;
    }
    async getUserFavorites(username) {
        const user = await this._qs.queueRequest(baseURL + username);

        if (user.parsedJSON && "id" in user.parsedJSON) {
            const usr = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["a" /* User */](user.parsedJSON.short_name || user.parsedJSON.id, this._type);
            usr.uname = user.parsedJSON.full_name;
            usr.image = {
                [user.parsedJSON.picture.width]: user.parsedJSON.picture.url,
                "170": user.parsedJSON.picture.small_url,
                "50": user.parsedJSON.picture.thumb_url
            };
            const follows = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
                url: baseURL + user.parsedJSON.id + "/following?maxItems=50&page=",
                pageSize: 50,
                request: url => {
                    return this._qs.queueRequest(url);
                },
                fetchNextPage(data) {
                    return data.parsedJSON && data.parsedJSON.total > this.result.length;
                },
                getItems(data) {
                    if (data.parsedJSON && "data" in data.parsedJSON) {
                        return data.parsedJSON.data;
                    } else {
                        return [];
                    }
                },
                getPageNumber(page) {
                    return page + 1;
                }
            }),
                  channels = follows.map(follow => getChannelFromJSON(follow));

            usr.favorites = channels.map(channel => channel.login);
            return [usr, channels];
        } else {
            throw "Couldn't get favorites for the channel " + username + " on " + this.name;
        }
    }
    getChannelDetails(channelname) {
        return this._qs.queueRequest(baseURL + channelname).then(data => {
            if (data.parsedJSON && "id" in data.parsedJSON) {
                return getChannelFromJSON(data.parsedJSON);
            } else {
                throw "Couldn't get details for the " + this.name + " channel " + channelname;
            }
        });
    }
    updateFavsRequest(users) {
        const urls = users.map(user => baseURL + user.login);
        this._qs.queueUpdateRequest(urls, this._qs.LOW_PRIORITY, user => {
            if (user.parsedJSON && "id" in user.parsedJSON) {
                const usr = users.find(u => u.login == user.parsedJSON.id || u.login == user.parsedJSON.short_name);
                usr.uname = user.parsedJSON.full_name;
                usr.image = {
                    [user.parsedJSON.picture.width]: user.parsedJSON.picture.url,
                    "170": user.parsedJSON.picture.small_url,
                    "50": user.parsedJSON.picture.thumb_url
                };
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__pagination_helper__["a" /* promisedPaginationHelper */])({
                    url: baseURL + user.parsedJSON.id + "/following?maxItems=50&page=",
                    pageSize: 50,
                    request: url => {
                        return this._qs.queueRequest(url);
                    },
                    fetchNextPage(data) {
                        return data.parsedJSON && data.parsedJSON.total > this.result.length;
                    },
                    getItems(data) {
                        if (data.parsedJSON && "data" in data.parsedJSON) {
                            return data.parsedJSON.data;
                        } else {
                            return [];
                        }
                    },
                    getPageNumber(page) {
                        return page + 1;
                    }
                }).then(follows => {
                    const channels = follows.map(follow => getChannelFromJSON(follow)),
                          newChannels = channels.filter(channel => usr.favorites.some(ch => ch.login == channel.login));
                    if (newChannels.length > 0) {
                        usr.favorites = channels.map(channel => channel.login);
                    }
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", usr);
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", newChannels);
                });
            }
        });
    }
    updateRequest(channels) {
        const urls = channels.map(channel => baseURL + channel.login);
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, data => {
            if (data.parsedJSON && "id" in data.parsedJSON) {
                const channel = getChannelFromJSON(data.parsedJSON);

                this._getChannelStatus(data.parsedJSON, channel).then(channel => {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", channel);
                });
            }
        });
    }
    async updateChannel(channelname) {
        const data = await this._qs.queueRequest(baseURL + channelname);

        if (data.parsedJSON && "id" in data.parsedJSON) {
            const channel = getChannelFromJSON(data.parsedJSON);

            return this._getChannelStatus(data.parsedJSON, channel);
        } else {
            throw "Couldn't get details for the new livestream channel " + channelname;
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new NewLivestream(type));

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__generic_provider__ = __webpack_require__(3);
/**
 * Provider for picarto.
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/picarto
 * @todo Fix live status detection. Probably not possible before picarto gets an API.
 */




const type = "picarto",
      baseURL = 'https://ptvappapi.picarto.tv',
      apiKey = '03e26294-b793-11e5-9a41-005056984bd4';

function getChannelFromJSON(jsonChan) {
    const ret = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](jsonChan.channel.toLowerCase(), type);
    ret.uname = jsonChan.channel;
    ret.image = { 101: jsonChan.avatar_url };
    ret.thumbnail = jsonChan.thumbnail_url;
    ret.url.push("https://picarto.tv/" + ret.login);
    ret.archiveUrl = "https://picarto.tv/" + ret.login;
    ret.chatUrl = "https://picarto.tv/chatpopout/" + ret.login;
    ret.live.setLive(jsonChan.is_online);
    ret.mature = jsonChan.is_nsfw;
    ret.viewers = jsonChan.current_viewers;
    ret.title = jsonChan.channel_title;
    ret.category = jsonChan.is_multistream ? browser.i18n.getMessage("providerPicartoMultistream") : jsonChan.content_type;
    return ret;
}

class Picarto extends __WEBPACK_IMPORTED_MODULE_2__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["https://picarto.tv"], _temp;
    }

    getChannelDetails(channelname) {
        return this._qs.queueRequest(`${ baseURL }/channel/${ channelname.toLowerCase() }?key=${ apiKey }`).then(resp => {
            if (resp.ok) {
                return getChannelFromJSON(resp.parseJSON);
            } else {
                throw `Channel ${ channelname } does not exist for ${ this.name }`;
            }
        });
    }
    updateRequest(channels) {
        const urls = channels.map(channel => `${ baseURL }/channel/${ channel.login }?key=${ apiKey }`);
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, page => {
            if (page.ok) {
                const channel = getChannelFromJSON(page.parseJSON);
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", channel);
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Picarto(type));

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__querystring__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__channel_live_state__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pagination_helper__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__generic_provider__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logic__ = __webpack_require__(15);
/**
 * Twitch Provider.
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/twitch
 * @todo investigate delayed title updates
 */
//TODO properly wait for clientID









const type = "twitch",
      archiveURL = "/videos/all",
      chatURL = "/chat",
      baseURL = 'https://api.twitch.tv/kraken',
      headers = { 'Client-ID': '', 'Accept': 'application/vnd.twitchtv.v3+json' },
      defaultAvatar = "https://static-cdn.jtvnw.net/jtv_user_pictures/xarth/404_user_300x300.png",
      itemsPerPage = 100,
      idOfChannel = new Map(),
      SIZES = ['50', '70', '150', '300'],
      urlForSize = (imgURL, size) => imgURL.replace("300x300", size + "x" + size),
      getImageObj = (imgURL = defaultAvatar) => {
    const ret = {};
    SIZES.forEach(s => {
        ret[s] = urlForSize(imgURL, s);
    });
    return ret;
},
      dedupe = (a, b) => {
    return a.filter(c => b.every(d => c.id !== d.id));
};
__WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get('twitch_clientId').then(id => {
    headers['Client-ID'] = id;
});

function getChannelFromJSON(jsonChannel) {
    const ret = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["b" /* Channel */](jsonChannel.name, type);
    ret.uname = jsonChannel.display_name;
    ret.url.push(jsonChannel.url);
    ret.archiveUrl = jsonChannel.url + archiveURL;
    ret.chatUrl = jsonChannel.url + chatURL;
    ret.image = getImageObj(jsonChannel.logo ? jsonChannel.logo : defaultAvatar);
    ret.title = jsonChannel.status;
    ret.category = jsonChannel.game;
    ret.mature = jsonChannel.mature;

    return ret;
}

function getStreamTypeParam(delim = "&") {
    return __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get('twitch_showPlaylist').then(showPlaylist => {
        if (showPlaylist) {
            return delim + "stream_type=all";
        } else {
            return delim + "&stream_type=live";
        }
    });
}

class Twitch extends __WEBPACK_IMPORTED_MODULE_6__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://www.twitch.tv", "https://secure.twitch.tv", "https://passport.twitch.tv"], this._supportsFavorites = true, this._supportsCredentials = true, this._supportsFeatured = true, _temp;
    }

    async getUserFavorites(username) {
        const data = await this._qs.queueRequest(baseURL + '/users/' + username, headers);

        if (data.json && !data.json.error) {
            const channels = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__pagination_helper__["a" /* promisedPaginationHelper */])({
                url: baseURL + '/users/' + username + '/follows/channels?limit=' + itemsPerPage + '&offset=',
                pageSize: itemsPerPage,
                request: url => {
                    return this._qs.queueRequest(url, headers);
                },
                fetchNextPage(data) {
                    return data.parsedJSON && "follows" in data.parsedJSON && data.parsedJSON.follows.length == itemsPerPage;
                },
                getItems(data) {
                    if (data.parsedJSON && "follows" in data.parsedJSON) {
                        return data.parsedJSON.follows.map(c => getChannelFromJSON(c.channel));
                    } else {
                        return [];
                    }
                }
            }),
                  user = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["a" /* User */](data.parsedJSON.name, this._type);
            user.uname = data.parsedJSON.display_name;
            user.image = getImageObj(data.parsedJSON.logo ? data.parsedJSON.logo : defaultAvatar);
            user.favorites = channels.map(channel => channel.login);

            return [user, channels];
        } else {
            throw "Couldn't fetch twitch user " + username;
        }
    }
    getChannelDetails(channelname) {
        console.info("twitch.getChannelDetails");
        return this._qs.queueRequest(baseURL + '/channels/' + channelname, headers).then(data => {
            if (data.parsedJSON && !data.parsedJSON.error) {
                idOfChannel.set(data.parsedJSON.name, data.parsedJSON._id);
                return getChannelFromJSON(data.parsedJSON);
            } else {
                throw data.parsedJSON ? data.parsedJSON.error : "Could not fetch details for " + this.name + " channel " + channelname;
            }
        });
    }
    updateFavsRequest(users) {
        const urls = users.map(user => baseURL + '/users/' + user.login);

        this._qs.queueUpdateRequest(urls, this._qs.LOW_PRIORITY, data => {
            if (data.parsedJSON && !data.parsedJSON.error) {
                const user = users.find(user => user.login == data.parsedJSON.name);
                user.uname = data.parsedJSON.display_name;
                user.image = getImageObj(data.parsedJSON.logo ? data.parsedJSON.logo : defaultAvatar);

                new __WEBPACK_IMPORTED_MODULE_5__pagination_helper__["b" /* PaginationHelper */]({
                    url: baseURL + '/users/' + user.login + '/follows/channels?limit=' + itemsPerPage + '&offset=',
                    pageSize: itemsPerPage,
                    request: url => {
                        return this._qs.queueRequest(url, headers);
                    },
                    fetchNextPage(data) {
                        return data.parsedJSON && "follows" in data.parsedJSON && data.parsedJSON.follows.length == itemsPerPage;
                    },
                    getItems(data) {
                        if (data.parsedJSON && "follows" in data.parsedJSON) {
                            return data.parsedJSON.follows.map(c => getChannelFromJSON(c.channel));
                        } else {
                            return [];
                        }
                    },
                    onComplete: follows => {
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", follows.filter(c => user.favorites.every(name => name !== c.login)));

                        user.favorites = follows.map(c => c.login);
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", user);
                    }
                });
            }
        }, headers);
    }
    updateRequest(channels) {
        const channelsString = channels.map(c => c.login).join(",");
        new __WEBPACK_IMPORTED_MODULE_5__pagination_helper__["b" /* PaginationHelper */]({
            url: baseURL + "/streams?channel=" + channelsString + "&stream_type=all&limit=" + itemsPerPage + "&offset=",
            pageSize: itemsPerPage,
            request: (url, callback, initial) => {
                if (initial) {
                    this._qs.queueUpdateRequest([url], this._qs.HIGH_PRIORITY, callback, headers);
                } else {
                    return this._qs.queueRequest(url, headers);
                }
            },
            fetchNextPage(data, pageSize) {
                return data.parsedJSON && "streams" in data.parsedJSON && data.parsedJSON.streams.length == pageSize;
            },
            getItems: data => {
                if (data.parsedJSON && "streams" in data.parsedJSON) {
                    let streams = data.parsedJSON.streams;
                    if (!__WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].twitch_showPlaylist) {
                        streams = streams.filter(s => !s.is_playlist);
                    }
                    return streams.map(obj => {
                        const cho = getChannelFromJSON(obj.channel);
                        cho.viewers = obj.viewers;
                        cho.thumbnail = obj.preview.medium;
                        if (obj.is_playlist) {
                            cho.live = new __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST);
                        } else {
                            cho.live.setLive(true);
                        }

                        let oldChan = channels.find(ch => cho.login == ch.login);
                        if (oldChan === undefined) {
                            const findChan = (chan, ch) => ch.login == chan;
                            for (const i of idOfChannel.entries()) {
                                if (i[1] == obj.channel._id) {
                                    oldChan = channels.find(findChan.bind(null, i[0]));
                                    if (oldChan !== undefined) {
                                        break;
                                    }
                                }
                            }
                        }
                        if (oldChan !== undefined) {
                            cho.id = oldChan.id;
                            oldChan.live = cho.live;
                        }
                        return cho;
                    });
                } else {
                    return [];
                }
            },
            onComplete: async data => {
                const liveChans = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* filterAsync */])(data, cho => cho.live.isLive(__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].TOWARD_OFFLINE));
                if (liveChans.length) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", liveChans);
                }
                if (liveChans.length != channels.length) {
                    let offlineChans = dedupe(channels, data);
                    const playlistChans = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* filterAsync */])(data, cho => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__logic__["a" /* not */])(cho.live.isLive(__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].TOWARD_OFFLINE)));
                    offlineChans = offlineChans.concat(playlistChans);
                    let chans = await this._getHostedChannels(offlineChans, liveChans);
                    chans = await Promise.all(chans.map(chan => {
                        if (chan.live.state == __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST) {
                            return this._getActivePlaylistInfo(chan).then(meta => {
                                chan.title = meta.title;
                                chan.category = meta.game;
                                chan.thumbnail = meta.thumbnail;
                                return chan;
                            }, () => chan);
                        } else {
                            return chan;
                        }
                    }));
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", chans);
                }
            }
        });
    }
    async updateChannel(channelname, ignoreHosted = false) {
        const [data, channel] = await Promise.all([getStreamTypeParam("?").then(p => this._qs.queueRequest(baseURL + '/streams/' + channelname + p, headers)), this.getChannelDetails(channelname)]);

        if (data.parsedJSON && data.parsedJSON.stream !== null && (!ignoreHosted || !data.parsedJSON.stream.is_playlist)) {
            channel.viewers = data.parsedJSON.stream.viewers;
            channel.thumbnail = data.parsedJSON.stream.preview.medium;
            if (data.parsedJSON.stream.is_playlist) {
                channel.live = new __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST);
                try {
                    const meta = await this._getActivePlaylistInfo(channel);
                    channel.title = meta.title;
                    channel.category = meta.game;
                    channel.thumbnail = meta.thumbnail;
                } catch (e) {
                    // empty
                }
            } else {
                channel.live.setLive(true);
            }
        }

        if (await channel.live.isLive(__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].TOWARD_OFFLINE)) {
            return channel;
        } else {
            if (!ignoreHosted) {
                return this._getHostedChannel(channel);
            } else {
                return channel;
            }
        }
    }
    async updateChannels(channels) {
        const logins = channels.map(c => c.login),
              channelsString = logins.join(","),
              streamTypeParam = await getStreamTypeParam(),
              liveChannels = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__pagination_helper__["a" /* promisedPaginationHelper */])({
            url: baseURL + '/streams?channel=' + channelsString + streamTypeParam + '&limit=' + itemsPerPage + '&offset=',
            pageSize: itemsPerPage,
            request: url => {
                return this._qs.queueRequest(url, headers);
            },
            fetchNextPage(data) {
                return data.parsedJSON && !data.parsedJSON.error && data.parsedJSON.streams.length == itemsPerPage;
            },
            getItems(data) {
                if (data.parsedJSON && !data.parsedJSON.error) {
                    return data.parsedJSON.streams;
                } else {
                    return [];
                }
            }
        });

        let cho,
            ret = await Promise.all(liveChannels.map(obj => {
            cho = getChannelFromJSON(obj.channel);
            cho.viewers = obj.viewers;
            cho.thumbnail = obj.preview.medium;
            if (obj.is_playlist) {
                cho.live = new __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST);
            } else {
                cho.live.setLive(true);
            }

            if (logins.includes(cho.login)) {
                cho.id = channels[logins.indexOf(cho.login)].id;
                return Promise.resolve(cho);
            } else {
                return Promise.all(channels.map(c => this._getChannelId(c))).then(ids => {
                    ids.some((id, i) => {
                        if (id === obj.channel._id) {
                            cho.id = channels[i].id;
                            return true;
                        }
                        return false;
                    });
                    return cho;
                });
            }
        }));

        const liveChans = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* filterAsync */])(ret, cho => cho.live.isLive(__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].TOWARD_OFFLINE));

        if (liveChans.length != channels.length) {
            const playlistChans = (await Promise.all(ret.map(async cho => {
                if (await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__logic__["a" /* not */])(cho.live.isLive(__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].TOWARD_OFFLINE))) {
                    try {
                        const meta = await this._getActivePlaylistInfo(cho);
                        cho.title = meta.title;
                        cho.category = meta.game;
                        cho.thumbnail = meta.thumbnail;
                    } catch (e) {/* emtpy */}
                    return cho;
                }
                return null;
            }))).filter(c => c !== null);
            let offlineChans = dedupe(channels, ret);
            offlineChans = offlineChans.concat(playlistChans);
            const offChans = await this._getHostedChannels(offlineChans, liveChans);
            ret = liveChans.concat(offChans);
        }

        return ret;
    }
    async getFeaturedChannels() {
        const data = await this._qs.queueRequest(baseURL + "/streams/featured", headers);
        if (data.parsedJSON && "featured" in data.parsedJSON && data.parsedJSON.featured.length) {
            let chans = data.parsedJSON.featured;
            if (await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__logic__["a" /* not */])(this._mature())) {
                chans = chans.filter(chan => !chan.stream.channel.mature);
            }

            return chans.map(chan => {
                const channel = getChannelFromJSON(chan.stream.channel);
                channel.viewers = chan.stream.viewers;
                channel.thumbnail = chan.stream.preview.medium;
                channel.live.setLive(true);
                return channel;
            });
        } else {
            throw "Could not get any featured channel for " + this.name;
        }
    }
    async search(query) {
        const data = await this._qs.queueRequest(baseURL + "/search/streams?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({ q: query }), headers);
        if (data.parsedJSON && "streams" in data.parsedJSON && data.parsedJSON.streams.length) {
            let chans = data.parsedJSON.streams;
            if (await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__logic__["a" /* not */])(this._mature())) {
                chans = chans.filter(chan => !chan.channel.mature);
            }

            return chans.map(chan => {
                const channel = getChannelFromJSON(chan.channel);
                channel.viewers = chan.viewers;
                channel.thumbnail = chan.preview.medium;
                channel.live.setLive(true);
                return channel;
            });
        } else {
            throw "No results for the search " + query + " on " + this.name;
        }
    }
    _getChannelId(channel) {
        // get the internal id for each channel.
        if (idOfChannel.has(channel.login)) {
            return Promise.resolve(idOfChannel.get(channel.login));
        } else {
            return this._qs.queueRequest(baseURL + "/channels/" + channel.login, headers).then(resp => {
                if (resp.parsedJSON && "_id" in resp.parsedJSON) {
                    idOfChannel.set(channel.login, resp.parsedJSON._id);
                    if (channel.login != resp.parsedJSON.name) {
                        idOfChannel.set(resp.parsedJSON.name, resp.parsedJSON._id);
                    }
                    return resp.parsedJSON._id;
                } else {
                    return null;
                }
            }, () => null);
        }
    }
    async _getHostedChannels(channels, liveChans) {
        if (await __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get("twitch_showHosting")) {
            let channelIds = await Promise.all(channels.map(channel => this._getChannelId(channel)));
            channelIds = channelIds.filter(id => id !== null);

            const existingChans = Array.isArray(liveChans) ? channels.concat(liveChans) : channels,
                  data = await this._qs.queueRequest("https://tmi.twitch.tv/hosts?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                "include_logins": 1,
                host: channelIds.join(",")
            }), headers);

            if (data.parsedJSON && "hosts" in data.parsedJSON && data.parsedJSON.hosts.length) {
                // Check each hosted channel for his status
                return Promise.all(data.parsedJSON.hosts.map(async hosting => {
                    let chan = channels.find(ch => ch.login === hosting.host_login);
                    if (chan === undefined) {
                        chan = await this.updateChannel(hosting.host_login, true);
                        chan.id = await Promise.all(channels.map(c => this._getChannelId(c))).then(ids => {
                            let chid;
                            ids.some((id, i) => {
                                if (id === hosting.host_login) {
                                    chid = channels[i].id;
                                    return true;
                                }
                                return false;
                            });
                            return chid;
                        });
                    }

                    if (hosting.target_login && existingChans.every(ch => ch.login !== hosting.target_login)) {

                        // Check the hosted channel's status, since he isn't a channel we already have in our lists.
                        try {
                            const hostedChannel = await this.updateChannel(hosting.target_login, true);
                            if (await hostedChannel.live.isLive(__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].TOWARD_OFFLINE)) {
                                chan.title = hostedChannel.title;
                                chan.thumbnail = hostedChannel.thumbnail;
                                chan.viewers = hostedChannel.viewers;
                                chan.category = hostedChannel.category;
                                chan.live = new __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REDIRECT);
                                chan.live.alternateUsername = hostedChannel.uname;
                                chan.live.alternateURL = hostedChannel.url[0];
                            } else {
                                chan.live.setLive(false);
                            }

                            return chan;
                        } catch (e) {
                            if (chan.live.state != __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST) {
                                chan.live.setLive(false);
                            }
                            return chan;
                        }
                    } else {
                        if (chan.live.state != __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST) {
                            chan.live.setLive(false);
                        }

                        return chan;
                    }
                }));
            }
        }
        channels.forEach(chan => {
            if (chan.live.state != __WEBPACK_IMPORTED_MODULE_3__channel_live_state__["a" /* default */].REBROADCAST) {
                chan.live.setLive(false);
            }
        });
        return channels;
    }
    _getHostedChannel(channel) {
        return this._getHostedChannels([channel]).then(chs => chs[0]);
    }
    async _getActivePlaylistInfo(channel) {
        const id = await this._getChannelId(channel),
              playlist = await this._qs.queueRequest("https://api.twitch.tv/api/playlists/channels/" + id, headers);

        if (playlist.parsedJSON && playlist.parsedJSON.enabled && playlist.parsedJSON.active && playlist.parsedJSON.playhead) {
            const playhead = playlist.parsedJSON.playhead,
                  vod = await this._qs.queueRequest(baseURL + "/videos/v" + playhead.vods[playhead.active_vod_index].id, headers);
            if (vod.parsedJSON) {
                return {
                    title: vod.parsedJSON.title,
                    game: vod.parsedJSON.game,
                    thumbnail: vod.parsedJSON.preview
                };
            } else {
                throw "VOD not found";
            }
        } else {
            throw "Not a channel with an active playlist";
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Twitch(type));

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__generic_provider__ = __webpack_require__(3);
/*
 * Created by Martin Giger
 * Licensed under MPL 2.0
 */




const type = "ustream",
      chatURL = "http://ustream.tv/socialstream/",
      baseURL = 'https://api.ustream.tv/';

function getChannelFromJSON(jsonChannel) {
    console.info("ustream:getChannelFromJSON");
    const ret = new __WEBPACK_IMPORTED_MODULE_1__channel_core__["b" /* Channel */](jsonChannel.id, type);
    ret.uname = jsonChannel.title;

    // Url stuff. It's pretty fun.
    if ("originalUrl" in jsonChannel) {
        ret.url.push(jsonChannel.originalUrl);
        ret.archiveUrl = jsonChannel.originalUrl;
    }
    if ("url" in jsonChannel) {
        ret.url.push("http://www.ustream.tv/channel/" + jsonChannel.url);
        if (!ret.archiveUrl) {
            ret.archiveUrl = "http://www.ustream.tv/channel/" + jsonChannel.url;
        }
    }
    if ("tinyurl" in jsonChannel) {
        ret.url.push(jsonChannel.tinyurl);
        if (!ret.archiveUrl) {
            ret.archiveUrl = "http://www.ustream.tv/channel/" + jsonChannel.url;
        }
    }
    ret.chatUrl = chatURL + jsonChannel.id;

    if ("picture" in jsonChannel) {
        ret.image = {};
        let size;
        Object.keys(jsonChannel.picture).forEach(s => {
            size = s.split("x")[0];
            ret.image[size] = jsonChannel.picture[s];
        });
    } else {
        ret.image = { "48": jsonChannel.owner.picture };
    }
    if ("tags" in jsonChannel && jsonChannel.tags.length > 0) {
        ret.category = jsonChannel.tags[0];
    }
    ret.live.setLive(jsonChannel.status == "live");
    if ("thumbnail" in jsonChannel) {
        ret.thumbnail = jsonChannel.thumbnail.live;
    }
    if ("stats" in jsonChannel) {
        ret.viewers = jsonChannel.status == "live" ? jsonChannel.stats.viewer : jsonChannel.stats.viewer_total;
    }
    return ret;
}

class Ustream extends __WEBPACK_IMPORTED_MODULE_2__generic_provider__["a" /* default */] {
    constructor(...args) {
        var _temp;

        return _temp = super(...args), this.authURL = ["http://ustream.tv"], _temp;
    }

    async getChannelDetails(channelname) {
        let data = await this._qs.queueRequest("http://www.ustream.tv/" + channelname),
            retried = false;

        if (!data.ok) {
            data = await this._qs.queueRequest("http://www.ustream.tv/channel/" + channelname);
            if (!data.ok) {
                throw "Error getting channel details for channel " + channelname;
            }
            retried = true;
        }

        const page = await data.text(),
              channelId = page.match(/<meta name="ustream:channel_id" content="([0-9]+)">/)[1],
              response = await this._qs.queueRequest(baseURL + "channels/" + channelId + ".json");

        if (response.parsedJSON && "channel" in response.parsedJSON) {
            const jsonChannel = response.parsedJSON.channel;

            if (!retried) {
                jsonChannel.originalUrl = "http://ustream.tv/" + channelname;
            }

            return getChannelFromJSON(jsonChannel);
        } else {
            throw "Error getting channel details for channel " + channelname;
        }
    }
    updateRequest(channels) {
        const urls = channels.map(channel => baseURL + "channels/" + channel.login + ".json");
        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, data => {
            if (data.parsedJSON && data.parsedJSON.channel) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", getChannelFromJSON(data.parsedJSON.channel));
            }
        });
    }
    updateChannel(channelname) {
        console.info("Ustream.updateChannel");
        return this._qs.queueRequest(baseURL + 'channels/' + channelname + ".json").then(data => {
            console.info("Ustream.updateChannel.requestCallback");
            if (data.parsedJSON && data.parsedJSON.channel) {
                return getChannelFromJSON(data.parsedJSON.channel);
            } else {
                throw "Could not update channel " + channelname + " for " + this.name;
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new Ustream(type));

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__querystring__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_underscore__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_underscore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_underscore__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__channel_core__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pagination_helper__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__generic_provider__ = __webpack_require__(3);
/**
 * YouTube provider
 * @author Martin Giger
 * @license MPL-2.0
 * @module providers/youtube
 */








const type = "youtube",
      apiKey = __WEBPACK_IMPORTED_MODULE_1__preferences__["a" /* default */].get('youtube_apiKey'),
      baseURL = "https://www.googleapis.com/youtube/v3/",
      getLocale = () => {
    return browser.i18n.getUILanguage();
};

class YouTube extends __WEBPACK_IMPORTED_MODULE_6__generic_provider__["a" /* default */] {
    constructor(type) {
        super(type);
        /**
         * Get the name for a category. Does caching.
         *
         * @argument {string} categoryId
         * @return {string}
         * @async
         * @todo Handle locale changes -> use memoize and make lang an argument?
         * @method
         */
        this.authURL = ["https://accounts.google.com"];
        this._supportsFavorites = true;
        this._supportsFeatured = true;
        this._getCategory = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_underscore__["memoize"])(async categoryId => {
            console.info(this.name + "._getCategory(", categoryId, ")");
            const data = await this._qs.queueRequest(baseURL + "videoCategories?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                "part": "snippet",
                "id": categoryId,
                "hl": getLocale(),
                "key": await apiKey
            }));

            if (data.parsedJSON && "items" in data.parsedJSON && data.parsedJSON.items.length) {
                return data.parsedJSON.items[0].snippet.title;
            } else {
                return '';
            }
        }, id => id + "|" + getLocale());
    }

    async _getChannelById(channelId) {
        const data = await this._qs.queueRequest(baseURL + "channels?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "snippet",
            id: channelId,
            fields: "items(snippet/title,snippet/thumbnails)",
            key: await apiKey
        }));
        if (data.parsedJSON && data.parsedJSON.items && data.parsedJSON.items.length) {
            const ch = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["b" /* Channel */](channelId, this._type);
            ch.url.push("https://youtube.com/channel/" + ch.login + "/live");
            ch.url.push("https://gaming.youtube.com/channel/" + ch.login + "/live");
            ch.archiveUrl = "https://youtube.com/channel/" + ch.login + "/videos";
            ch.chatUrl = "https://youtube.com/channel/" + ch.login + "/discussion";
            ch.image = {
                "88": data.parsedJSON.items[0].snippet.thumbnails.default.url,
                "240": data.parsedJSON.items[0].snippet.thumbnails.high.url
            };
            ch.uname = data.parsedJSON.items[0].snippet.title;
            return ch;
        } else {
            throw "Getting channel details failed: " + data.status;
        }
    }

    async getUserFavorites(username) {
        const data = await this._qs.queueRequest(baseURL + "channels?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "id,snippet",
            forUsername: username,
            fields: "items(id,snippet/title,snippet/thumbnails)",
            key: await apiKey
        }));

        if (data.parsedJSON && data.parsedJSON.items && data.parsedJSON.items.length) {
            const ch = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["a" /* User */](data.parsedJSON.items[0].id, this._type),
                  subsOptions = {
                part: "snippet",
                channelId: data.parsedJSON.items[0].id,
                maxResults: 50,
                key: await apiKey
            };
            let page = 0;
            ch.image = {
                "88": data.parsedJSON.items[0].snippet.thumbnails.default.url,
                "240": data.parsedJSON.items[0].snippet.thumbnails.high.url
            };
            ch.uname = data.parsedJSON.items[0].snippet.title;

            const subscriptions = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__pagination_helper__["a" /* promisedPaginationHelper */])({
                url: baseURL + "subscriptions?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify(subsOptions),
                pageSize: subsOptions.maxResults,
                initialPage: "",
                request: url => {
                    return this._qs.queueRequest(url);
                },
                getPageNumber(page, pageSize, data) {
                    return data.parsedJSON.nextPageToken;
                },
                fetchNextPage(data) {
                    return data.parsedJSON && data.parsedJSON.items && data.parsedJSON.pageInfo.totalResults > data.parsedJSON.pageInfo.resultsPerPage * ++page;
                },
                getItems(data) {
                    if (data.parsedJSON && data.parsedJSON.items) {
                        return data.parsedJSON.items;
                    } else {
                        return [];
                    }
                }
            });

            if (subscriptions.length) {
                ch.favorites = subscriptions.map(sub => sub.snippet.resourceId.channelId);

                const channels = subscriptions.map(sub => {
                    const ret = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["b" /* Channel */](sub.snippet.resourceId.channelId, this._type);
                    ret.archiveUrl = "https://youtube.com/channel/" + ret.login + "/videos";
                    ret.chatUrl = "https://youtube.com/channel/" + ret.login + "/discussion";
                    ret.image = {
                        "88": sub.snippet.thumbnails.default.url,
                        "240": sub.snippet.thumbnails.high.url
                    };
                    ret.uname = sub.snippet.title;
                    return ret;
                });

                return [ch, channels];
            } else {
                /** @todo Sometimes needs oAuth for some reason, I guess privacy
                  * settings. This also triggers when the user follows noone. */
                throw "Can't get favorites for youtube user " + username + " without oAuth as somebody with reading rights of this user's subs.";
            }
        } else {
            throw "Error getting details for youtube user " + username;
        }
    }
    async getChannelDetails(username) {
        const data = await this._qs.queueRequest(baseURL + "channels?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "id,snippet",
            forUsername: username,
            fields: "items(id,snippet/title,snippet/thumbnails)",
            key: await apiKey
        }));
        if (data.parsedJSON && data.parsedJSON.items && data.parsedJSON.items.length) {
            const ch = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["b" /* Channel */](data.parsedJSON.items[0].id, this._type);
            ch.url.push("https://youtube.com/channel/" + ch.login);
            ch.archiveUrl = "https://youtube.com/channel/" + ch.login + "/videos";
            ch.chatUrl = "https://youtube.com/channel/" + ch.login + "/discussion";
            ch.image = {
                "88": data.parsedJSON.items[0].snippet.thumbnails.default.url,
                "240": data.parsedJSON.items[0].snippet.thumbnails.high.url
            };
            ch.uname = data.parsedJSON.items[0].snippet.title;
            return ch;
        } else {
            // Try to get the channel by ID if we can't get it by username.
            return this._getChannelById(username);
        }
    }
    async updateFavsRequest(users) {
        const urls = await Promise.all(users.map(async user => {
            return baseURL + "channels?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                part: "id,snippet",
                id: user.login,
                fields: "items(id,snippet/title,snippet/thumbnails)",
                key: await apiKey
            });
        }));
        this._qs.queueUpdateRequest(urls, this._qs.LOW_PRIORITY, async data => {
            if (data.parsedJSON && data.parsedJSON.items && data.parsedJSON.items.length) {
                const ch = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["a" /* User */](data.parsedJSON.items[0].id, this._type),
                      subsOptions = {
                    part: "snippet",
                    channelId: data.parsedJSON.items[0].id,
                    maxResults: 50,
                    key: await apiKey
                };
                let page = 0;
                ch.image = {
                    "88": data.parsedJSON.items[0].snippet.thumbnails.default.url,
                    "240": data.parsedJSON.items[0].snippet.thumbnails.high.url
                };
                ch.uname = data.parsedJSON.items[0].snippet.title;
                const subscriptions = await __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__pagination_helper__["a" /* promisedPaginationHelper */])({
                    url: baseURL + "subscriptions?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify(subsOptions),
                    pageSize: subsOptions.maxResults,
                    initialPage: "",
                    request: url => {
                        return this._qs.queueRequest(url);
                    },
                    getPageNumber(page, pageSize, data) {
                        return data.parsedJSON.nextPageToken;
                    },
                    fetchNextPage(data) {
                        return data.parsedJSON && data.parsedJSON.items && data.parsedJSON.pageInfo.totalResults > data.parsedJSON.pageInfo.resultsPerPage * ++page;
                    },
                    getItems(data) {
                        if (data.parsedJSON && data.parsedJSON.items) {
                            return data.parsedJSON.items;
                        } else {
                            return [];
                        }
                    }
                });
                if (subscriptions.length) {
                    const oldUser = users.find(usr => usr.login === ch.login);
                    ch.id = oldUser.id;
                    ch.favorites = subscriptions.map(sub => sub.snippet.resourceId.channelId);
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updateduser", ch);
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "newchannels", subscriptions.filter(follow => {
                        return !oldUser.favorites.some(fav => fav === follow.snippet.resourceId.channelId);
                    }).map(sub => {
                        const ret = new __WEBPACK_IMPORTED_MODULE_4__channel_core__["b" /* Channel */](sub.snippet.resourceId.channelId, this._type);
                        ret.archiveUrl = "https://youtube.com/channel/" + ch.login + "/videos";
                        ret.chatUrl = "https://youtube.com/channel/" + ch.login + "/discussion";
                        ret.image = {
                            "88": sub.snippet.thumbnails.default.url,
                            "240": sub.snippet.thumbnails.high.url
                        };
                        ret.uname = sub.snippet.title;
                        return ret;
                    }));

                    oldUser.favorites = ch.favorites;
                } else {
                    /** @todo Sometimes needs oAuth for some reason, I guess privacy settings. */
                    console.warn("Can't get favorites for youtube user " + ch.uname + " without oAuth as somebody with reading rights of this user's subs.");
                }
            }
        });
    }
    async updateRequest(channels) {
        let offlineCount = 0;
        const ids = [],
              urls = await Promise.all(channels.map(async channel => {
            return baseURL + "search?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                part: "id",
                channelId: channel.login,
                fields: "items(id/videoId)",
                maxResults: 1,
                eventType: "live",
                type: "video",
                key: await apiKey
            });
        })),
              getLiveStreams = async ids => {
            const videos = await this._qs.queueRequest(baseURL + "videos?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                part: "id, snippet, liveStreamingDetails",
                id: ids,
                fields: "items(id,snippet(channelId,title,thumbnails/medium/url,categoryId),liveStreamingDetails/concurrentViewers)",
                key: await apiKey,
                hl: getLocale()
            }));
            if (videos.parsedJSON && videos.parsedJSON.items) {
                return Promise.all(videos.parsedJSON.items.map(video => {
                    return this._getCategory(video.snippet.categoryId).then(category => {
                        const channel = channels.find(channel => channel.login == video.snippet.channelId);
                        channel.live.setLive(true);
                        channel.url = ["https://youtube.com/watch?v=" + video.id, "https://gaming.youtube.com/watch?v=" + video.id, "https://youtube.com/channel/" + channel.login + "/live", "https://gaming.youtube.com/channel/" + channel.login + "/live"];
                        channel.title = video.snippet.title;
                        channel.thumbnail = video.snippet.thumbnails.medium.url;
                        channel.viewers = video.liveStreamingDetails.concurrentViewers;
                        channel.category = category;
                        return channel;
                    });
                }));
            } else {
                throw "Could not find the given stream";
            }
        },
              done = id => {
            if (id) {
                ids.push(id);
            } else {
                offlineCount++;
            }
            if (ids.length + offlineCount == channels.length) {
                getLiveStreams(ids.join(",")).then(chans => {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", chans);
                });
                ids.length = 0;
                offlineCount = 0;
            }
        };

        //TODO there should be a way to do this with a generator.

        this._qs.queueUpdateRequest(urls, this._qs.HIGH_PRIORITY, (data, url) => {
            const channelLogin = url.match(/channelId=([\w-]+)?&/)[1],
                  channel = channels.find(channel => channelLogin == channel.login);
            if (data.parsedJSON && data.parsedJSON.items && data.parsedJSON.items.length) {
                done(data.parsedJSON.items[0].id.videoId);
            } else {
                channel.live.setLive(false);
                channel.url = ["https://youtube.com/channel/" + channel.login];
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "updatedchannels", channel);
                done();
            }
        });
    }
    async updateChannel(channellogin) {
        const [ch, response] = await Promise.all([this._getChannelById(channellogin), apiKey.then(key => this._qs.queueRequest(baseURL + "search?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "id",
            channelId: channellogin,
            fields: "items(id/videoId)",
            maxResults: 1,
            eventType: "live",
            type: "video",
            key
        })))]);

        if (response.parsedJSON && response.parsedJSON.items) {
            if (response.parsedJSON.items.length) {
                ch.live.setLive(true);
                ch.url.push("https://youtube.com/watch?v=" + response.parsedJSON.items[0].id.videoId);
                ch.url.push("https://gaming.youtube.com/watch?v=" + response.parsedJSON.items[0].id.videoId);

                const video = await this._qs.queueRequest(baseURL + "videos?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                    part: "snippet, liveStreamingDetails",
                    id: response.parsedJSON.items[0].id.videoId,
                    fields: "items(snippet(categoryId,title,thumbnails/medium/url),liveStreamingDetails/concurrentViewers)",
                    key: await apiKey,
                    hl: getLocale()
                }));
                if (video.parsedJSON && video.parsedJSON.items) {
                    ch.title = video.parsedJSON.items[0].snippet.title;
                    ch.thumbnail = video.parsedJSON.items[0].snippet.thumbnails.medium.url;
                    ch.viewers = video.parsedJSON.items[0].liveStreamingDetails.concurrentViewers;
                    ch.category = await this._getCategory(video.parsedJSON.items[0].snippet.categoryId);
                }
            } else {
                ch.live.setLive(false);
                ch.url.push("https://youtube.com/channel/" + ch.login);
            }

            return ch;
        }
    }
    async updateChannels(channels) {
        let streamIds = await Promise.all(channels.map(async channel => {
            const response = await this._qs.queueRequest(baseURL + "search?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
                part: "id",
                channelId: channel.login,
                fields: "items(id/videoId)",
                maxResults: 1,
                eventType: "live",
                type: "video",
                key: await apiKey
            }));
            if (!response.parsedJSON || !response.parsedJSON.items || !response.parsedJSON.items.length) {
                channel.live.setLive(false);
                channel.url = ["https://youtube.com/channel/" + channel.login];
                return null;
            }
            return response.parsedJSON.items[0].id.videoId;
        }));

        streamIds = streamIds.filter(id => id !== null);

        const videos = await this._qs.queueRequest(baseURL + "videos?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "id, snippet, liveStreamingDetails",
            id: streamIds.join(","),
            fields: "items(id,snippet(channelId,title,thumbnails/medium/url,categoryId),liveStreamingDetails/concurrentViewers)",
            key: await apiKey,
            hl: getLocale()
        }));

        if (videos.parsedJSON && videos.parsedJSON.items) {
            await Promise.all(videos.parsedJSON.items.map(video => {
                return this._getCategory(video.snippet.categoryId).then(category => {
                    const channel = channels.find(channel => channel.login == video.snippet.channelId);
                    channel.live.setLive(true);
                    channel.url = ["https://youtube.com/watch?v=" + video.id, "https://gaming.youtube.com/watch?v=" + video.id, "https://youtube.com/channel/" + channel.login + "/live", "https://gaming.youtube.com/channel/" + channel.login + "/live"];
                    channel.title = video.snippet.title;
                    channel.thumbnail = video.snippet.thumbnails.medium.url;
                    channel.viewers = video.liveStreamingDetails.concurrentViewers;
                    channel.category = category;
                    return channel;
                });
            }));
        }

        return channels;
    }
    async search(query) {
        const response = await this._qs.queueRequest(baseURL + "search?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "id",
            fields: "items(id/videoId)",
            eventType: "live",
            type: "video",
            order: "relevance",
            relevanceLanguage: browser.i18n.getUILanguage().substr(0, 2),
            safeSearch: await this._mature() ? "moderate" : "strict",
            q: query,
            key: await apiKey
        }));

        let streamIds;
        if (response.parsedJSON && response.parsedJSON.items && response.parsedJSON.items.length) {
            streamIds = response.parsedJSON.items.map(entry => entry.id.videoId);
        } else {
            throw "No search results found for " + this.name + " with " + query;
        }

        const videos = await this._qs.queueRequest(baseURL + "videos?" + __WEBPACK_IMPORTED_MODULE_2__querystring__["a" /* default */].stringify({
            part: "id,snippet,liveStreamingDetails",
            id: streamIds.join(","),
            fields: "items(id,snippet(channelId,title,thumbnails/medium/url,categoryId),liveStreamingDetails/concurrentViewers)",
            key: await apiKey,
            hl: getLocale()
        }));

        if (videos.parsedJSON && videos.parsedJSON.items) {
            return Promise.all(videos.parsedJSON.items.map(async video => {
                const channel = await this._getChannelById(video.snippet.channelId);
                channel.live.setLive(true);
                channel.url = ["https://youtube.com/watch?v=" + video.id, "https://gaming.youtube.com/watch?v=" + video.id];
                channel.title = video.snippet.title;
                channel.thumbnail = video.snippet.thumbnails.medium.url;
                if ("liveStreamingDetails" in video) {
                    channel.viewers = video.liveStreamingDetails.concurrentViewers;
                }
                channel.category = await this._getCategory(video.snippet.categoryId);

                return channel;
            }));
        }

        throw "None of the searchresults exist for " + this.name;
    }
}

/* harmony default export */ __webpack_exports__["a"] = Object.freeze(new YouTube(type));

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_event_target_shim__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_event_target_shim___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_event_target_shim__);
/**
 * Queue infrastructure for updating info
 * @author Martin Giger
 * @license MPL-2.0
 * @module queue
 */


/**
 * @typedef {Object} external:sdk/request.RequestOptions
 * @see {@link https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/request#Request%28options%29}
 */

/**
 * @typedef {external:sdk/request.RequestOptions} RequestInfo
 * @property {number} id
 */
/**
 * @class module:queue.RequestQueue
 * @extends external:EventTarget
 */
class RequestQueue extends __WEBPACK_IMPORTED_MODULE_0_event_target_shim___default.a {
    /**
     * RequestQueue Object.
     *
     * @constructs
     */

    /**
     * Last ID assigned to a request.
     *
     * @type {number}
     * @default -1
     * @protected
     */
    constructor() {
        super();
        /**
         * @type {array.<module:queue~RequestInfo>}
         * @protected
         */
        this._alarmName = "main-queue";
        this.lastID = -1;
        this.interval = 0;
        this.amount = 0.5;
        this.maxSize = 10;
        this.queue = [];

        browser.alarms.onAlarm.addListener(alarm => {
            if (alarm.name == this._alarmName) {
                const size = Math.max(1, Math.min(this.queue.length * this.amount, this.maxSize));
                this.getRequestBatch(size);
            }
        });
    }
    /**
     * Add a request to the queue.
     *
     * @param {external:sdk/request.RequestOptions} requestOptions - Options for
     *                                                              the request.
     * @returns {number} ID of the added request.
     */

    /**
     * Time interval between fetched requests.
     *
     * @type {number}
     * @default 0
     * @readonly
     */

    /**
     * ID of the queue interval.
     *
     * @type {number?}
     * @private
     */
    addRequest(requestOptions) {
        this.queue.push(Object.assign({ id: ++this.lastID, method: "GET" }, requestOptions));
        return this.lastID;
    }
    /**
     * Fetch the request with the given index in the queue.
     *
     * @param {number} index - Index of the request to fetch.
     * @returns {undefined}
     */
    getRequest(index) {
        const spec = this.queue.splice(index, 1)[0];
        fetch(spec.url, {
            headers: spec.headers,
            redirect: "follow"
        }).then(response => {
            const jsonClone = response.clone();
            return jsonClone.json().then(json => {
                response.parsedJSON = json;
                spec.onComplete(response);
            }, () => {
                spec.onComplete(response);
            });
        }, error => {
            console.error(error);
            if (spec.onError) {
                spec.onError(error);
            } else {
                throw error;
            }
        });
        return spec;
    }
    /**
     * Fetch the request with the given ID.
     *
     * @param {number|string} query - ID or URL of the request to fetch.
     * @returns {undefined}
     */
    getRequestById(query) {
        return this.getRequest(this.getRequestIndex(query));
    }
    /**
     * Fetch multiple requests from the top of the queue.
     *
     * @param {number} [batchSize=this.queue.length] - Number of requests to get.
     * @returns {undefined}
     */
    getRequestBatch(batchSize = this.queue.length) {
        if (batchSize > this.queue.length) {
            batchSize = this.queue.length;
        }

        for (let i = 0; i < batchSize; i++) {
            this.getRequest(0);
        }
    }
    /**
     * Set up an interval to fetch a certain amount of requests periodically.
     * Can also be used to change the interval.
     *
     * @param {number} interval - Interval in milliseconds.
     * @param {number} amount - A percentage of requests to get per batch.
     * @param {number} maxSize - The max number of requests to get per batch.
     * @returns {undefined}
     */
    async autoFetch(interval, amount, maxSize) {
        this.interval = interval;
        this.amount = amount;
        this.maxSize = maxSize;
        if (this.workingOnQueue()) {
            await browser.alarms.clear(this._alarmName);
        }
        if (interval > 0) {
            browser.alarms.create(this._alarmName, {
                periodInMinutes: interval / 60000
            });
        }
    }
    /**
     * Remove all requests and ongoing intervals.
     *
     * @returns {undefined}
     */
    clear() {
        if (this.workingOnQueue()) {
            browser.alarms.clear(this._alarmName);
        }
        this.interval = 0;
        if (this.queue.length > 0) {
            this.queue.length = 0;
        }
    }
    /**
     * Check if a request is still in the queue.
     *
     * @param {number|string} query - ID or URL of the request.
     * @returns {boolean} Wether the request is still queued.
     */
    requestQueued(query) {
        return this.getRequestIndex(query) > -1;
    }
    /**
     * Get the index of a request.
     *
     * @param {number|string} query - ID or URL of the request.
     * @returns {number} Index of the request. -1 if the request couldn't be
     * found.
     */
    getRequestIndex(query) {
        if (typeof query === 'string') {
            return this.queue.findIndex(req => req.url === query);
        } else if (typeof query === 'number') {
            return this.queue.findIndex(req => req.id === query);
        }
        return -1;
    }
    /**
     * Check if the queue is currently peridoically fetching requests.
     *
     * @returns {boolean} Whether there is an interval set up.
     */
    workingOnQueue() {
        return this.interval !== 0;
    }
    /**
     * Remove a request from the queue.
     *
     * @param {number|string} query - ID or URL of the request.
     * @returns {boolean} Whether or not the request has been removed.
     */
    removeRequest(query) {
        if (this.requestQueued(query)) {
            console.log("[Queue]> removing request");
            this.queue.splice(this.getRequestIndex(query), 1);
            return true;
        }
        return false;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RequestQueue;


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);
/* eslint-disable jsdoc/require-param */
/**
 * @author Martin Giger
 * @license MPL-2.0
 * @module queue/pauseable
 * @requires module:queue
 */



/**
 * @typedef {Object} QueueOptions
 * @property {number} interval - Interval to fetch batches in.
 * @property {number} amount - Percentage of the queue to fetch per batch.
 * @property {number} maxSize - Maximum number of requests per batch.
 */

/**
 * @event module:queue/pauseable.PauseableQueue#pause
 */
/**
 * @event module:queue/pauseable.PauseableQueue#resume
 */

/**
 * @class
 * @extends module:queue.RequestQueue
 */
class PauseableQueue extends __WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */] {
  /**
   * Pauseable queue, pauses based on the network status.
   *
   * @constructs
   * @extends module:queue.RequestQueue
   */
  constructor() {
    super();

    /**
     * @type {module:queue/pauseable~QueueOptions?}
     * @private
     */
    this._configured = false;
    this._queueState = {};

    window.addEventListener("offline", () => this.pause(), { passive: true });
    window.addEventListener("online", () => this.resume(), { passive: true });
  }
  /**
   * @type {boolean}
   * @default false
   * @readonly
   */

  /**
   * @type {boolean}
   * @default false
   */
  get paused() {
    return this.interval === 0;
  }
  /**
   * @override
   */
  autoFetch(interval, amount = this._queueState.amount, maxSize = this._queueState.maxSize) {
    if (interval > 0) {
      this._queueState = {
        interval,
        amount,
        maxSize
      };
      this._configured = true;
    }
    if (navigator.onLine || interval === 0) {
      super.autoFetch(interval, amount, maxSize);
    } else {
      this.pause();
    }
  }
  /**
   * Temporarily halt execution of the queue.
   *
   * @fires module:queue/pauseable.PauseableQueue#pause
   * @returns {undefined}
   */
  pause() {
    if (this._configured && this.interval !== 0) {
      this.autoFetch(0);
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* emit */])(this, "pause");
    }
  }
  /**
   * Resume the queue.
   *
   * @fires module:queue/pauseable.PauseableQueue#resume
   * @returns {undefined}
   */
  resume() {
    if (this._configured) {
      this.autoFetch(this._queueState.interval);
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* emit */])(this, "resume");
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PauseableQueue;


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pauseable__ = __webpack_require__(48);
/**
 * Queue with priorized, persistant and less often fetched requests.
 *
 * @author Martin Giger
 * @license MPL-2.0
 * @module queue/update
 * @requires module:queue/pauseable
 */



/**
 * Fired when there is a new priorized item added to the queue.
 *
 * @event module:queue/update.UpdateQueue#queuepriorized
 */
/**
 * Fired when all priorized items in the queue were fetched.
 *
 * @event module:queue/update.UpdateQueue#allpriorizedloaded
 */

/**
 * @class module:queue/update.UpdateQueue
 * @extends module:queue/pauseable.PauseableQueue
 */
class UpdateQueue extends __WEBPACK_IMPORTED_MODULE_1__pauseable__["a" /* default */] {
    /**
     * A queue with priorized, persistent and less often fetched requests.
     *
     * @constructs
     */
    constructor() {
        super();
    }
    /**
     * Add a request to the queue.
     *
     * @param {external:sdk/request.RequestOptions} requestArgs - Requst Arguments.
     * @param {boolean} [persistent=false] - If the request should be readded
     *                                         to the queue whenever it was
     *                                         fetched.
     * @param {boolean} [priorized=false] - If the request should be priorized
     *                                        over other requests in the queue.
     *                                        Can not be true when the request
     *                                        is persistent and not skipping.
     * @param {number} [skip=0] - Number of times to skip this request before
     *                            fetching it.
     * @returns {number} Request id.
     * @fires module:queue/update.UpdateQueue#queuepriorized
     */
    addRequest(requestArgs, persistent = false, priorized = false, skip = 0) {
        // only allow priorized if its either not a persistent request or it skips
        // skipping requests are only priorized for the first time the are actually sent
        // however they will the first time not skip.
        priorized = priorized && (!persistent || skip > 0);

        if (!this.containsPriorized() && priorized) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "queuepriorized");
        }
        return super.addRequest(Object.assign({
            persist: persistent,
            priorize: priorized,
            skip,
            skipped: 0
        }, requestArgs));
    }
    /**
     * Fetch multiple requests from the top of the queue.
     *
     * @param {number} index - Index of the request to fetch.
     * @fires module:queue/update.UpdateQueue#allpriorizedloaded
     * @returns {undefined}
     */
    getRequest(index) {
        if (this.getFirstPriorized()) {
            if (!this.containsPriorized()) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "allpriorizedloaded");
            }
        } else {
            this.getRequestByIndex(index);
        }
    }
    /**
     * Fetch the first priorized request in the queue.
     *
     * @returns {boolean} If a priorized request was fetched.
     */
    getFirstPriorized() {
        return this.queue.some((req, i) => {
            if (req.priorize) {
                this.getRequestByIndex(i);
                return true;
            }
            return false;
        });
    }
    /**
     * Fetch the request at the given index.
     *
     * @param {number} index - Index in the queue of the request.
     * @returns {undefined}
     */
    getRequestByIndex(index) {
        console.info(this.queue.length + " jobs left in the queue.");
        if (this.queue[index].skip > this.queue[index].skipped && !this.queue[index].priorize) {
            console.log("[Queue]> Skipping " + this.queue[index].url);
            this.queue[index].skipped++;

            this.queue.push(this.queue.splice(index, 1)[0]);
        } else {
            console.log("[Queue]> Getting " + this.queue[index].url);

            const req = super.getRequest(index);
            if (req.persist) {

                // explication of the skipping logic in the addRequest method
                if (req.skip > 0) {
                    req.skipped = 0;
                    if (req.priorize) {
                        req.priorize = false;
                    }
                }

                this.queue.push(req);
            }
        }
    }
    /**
     * Check if the queue has a priorized request waiting.
     *
     * @returns {boolean} Whether there is a priorized request in the queue.
     */
    containsPriorized() {
        return this.queue.some(item => item.priorize);
    }
    /**
     * Fetch all priorized requests.
     *
     * @fires module:queue/update.UpdateQueue#allpriorizedloaded
     * @returns {undefined}
     */
    getAllPriorized() {
        this.queue.filter(req => req.priorize).forEach(() => {
            this.getFirstPriorized();
        });
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* emit */])(this, "allpriorizedloaded");
    }
    /**
     * @override
     */
    resume() {
        super.resume();
        if (this.containsPriorized()) {
            this.getAllPriorized();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = UpdateQueue;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

var Commons = __webpack_require__(18)
var LISTENERS = Commons.LISTENERS
var ATTRIBUTE = Commons.ATTRIBUTE
var newNode = Commons.newNode

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

/**
 * Gets a specified attribute listener from a given EventTarget object.
 *
 * @param {EventTarget} eventTarget - An EventTarget object to get.
 * @param {string} type - An event type to get.
 * @returns {function|null} The found attribute listener.
 */
function getAttributeListener(eventTarget, type) {
    var node = eventTarget[LISTENERS][type]
    while (node != null) {
        if (node.kind === ATTRIBUTE) {
            return node.listener
        }
        node = node.next
    }
    return null
}

/**
 * Sets a specified attribute listener to a given EventTarget object.
 *
 * @param {EventTarget} eventTarget - An EventTarget object to set.
 * @param {string} type - An event type to set.
 * @param {function|null} listener - A listener to be set.
 * @returns {void}
 */
function setAttributeListener(eventTarget, type, listener) {
    if (typeof listener !== "function" && typeof listener !== "object") {
        listener = null // eslint-disable-line no-param-reassign
    }

    var prev = null
    var node = eventTarget[LISTENERS][type]
    while (node != null) {
        if (node.kind === ATTRIBUTE) {
            // Remove old value.
            if (prev == null) {
                eventTarget[LISTENERS][type] = node.next
            }
            else {
                prev.next = node.next
            }
        }
        else {
            prev = node
        }

        node = node.next
    }

    // Add new value.
    if (listener != null) {
        if (prev == null) {
            eventTarget[LISTENERS][type] = newNode(listener, ATTRIBUTE)
        }
        else {
            prev.next = newNode(listener, ATTRIBUTE)
        }
    }
}

//-----------------------------------------------------------------------------
// Public Interface
//-----------------------------------------------------------------------------

/**
 * Defines an `EventTarget` implementation which has `onfoobar` attributes.
 *
 * @param {EventTarget} EventTargetBase - A base implementation of EventTarget.
 * @param {string[]} types - A list of event types which are defined as attribute listeners.
 * @returns {EventTarget} The defined `EventTarget` implementation which has attribute listeners.
 */
module.exports.defineCustomEventTarget = function(EventTargetBase, types) {
    /**
     * The constructor of custom event target.
     * @constructor
     */
    function EventTarget() {
        EventTargetBase.call(this)
    }

    var descripter = {
        constructor: {
            value: EventTarget,
            configurable: true,
            writable: true,
        },
    }

    types.forEach(function(type) {
        descripter["on" + type] = {
            get: function() {
                return getAttributeListener(this, type)
            },
            set: function(listener) {
                setAttributeListener(this, type, listener)
            },
            configurable: true,
            enumerable: true,
        }
    })

    EventTarget.prototype = Object.create(EventTargetBase.prototype, descripter)

    return EventTarget
}


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

var createUniqueKey = __webpack_require__(18).createUniqueKey

//-----------------------------------------------------------------------------
// Constsnts
//-----------------------------------------------------------------------------

/**
 * The key of the flag which is turned on by `stopImmediatePropagation` method.
 *
 * @type {symbol|string}
 * @private
 */
var STOP_IMMEDIATE_PROPAGATION_FLAG =
    createUniqueKey("stop_immediate_propagation_flag")

/**
 * The key of the flag which is turned on by `preventDefault` method.
 *
 * @type {symbol|string}
 * @private
 */
var CANCELED_FLAG = createUniqueKey("canceled_flag")

/**
 * The key of the flag that it cannot use `preventDefault` method.
 *
 * @type {symbol|string}
 * @private
 */
var PASSIVE_LISTENER_FLAG = createUniqueKey("passive_listener_flag")

/**
 * The key of the original event object.
 *
 * @type {symbol|string}
 * @private
 */
var ORIGINAL_EVENT = createUniqueKey("original_event")

/**
 * Method definitions for the event wrapper.
 *
 * @type {object}
 * @private
 */
var wrapperPrototypeDefinition = Object.freeze({
    stopPropagation: Object.freeze({
        value: function stopPropagation() {
            var e = this[ORIGINAL_EVENT]
            if (typeof e.stopPropagation === "function") {
                e.stopPropagation()
            }
        },
        writable: true,
        configurable: true,
    }),

    stopImmediatePropagation: Object.freeze({
        value: function stopImmediatePropagation() {
            this[STOP_IMMEDIATE_PROPAGATION_FLAG] = true

            var e = this[ORIGINAL_EVENT]
            if (typeof e.stopImmediatePropagation === "function") {
                e.stopImmediatePropagation()
            }
        },
        writable: true,
        configurable: true,
    }),

    preventDefault: Object.freeze({
        value: function preventDefault() {
            if (this[PASSIVE_LISTENER_FLAG]) {
                return
            }
            if (this.cancelable === true) {
                this[CANCELED_FLAG] = true
            }

            var e = this[ORIGINAL_EVENT]
            if (typeof e.preventDefault === "function") {
                e.preventDefault()
            }
        },
        writable: true,
        configurable: true,
    }),

    defaultPrevented: Object.freeze({
        get: function defaultPrevented() {
            return this[CANCELED_FLAG]
        },
        enumerable: true,
        configurable: true,
    }),
})

//-----------------------------------------------------------------------------
// Public Interface
//-----------------------------------------------------------------------------

module.exports.STOP_IMMEDIATE_PROPAGATION_FLAG = STOP_IMMEDIATE_PROPAGATION_FLAG
module.exports.PASSIVE_LISTENER_FLAG = PASSIVE_LISTENER_FLAG

/**
 * Creates an event wrapper.
 *
 * We cannot modify several properties of `Event` object, so we need to create the wrapper.
 * Plus, this wrapper supports non `Event` objects.
 *
 * @param {Event|{type: string}} event - An original event to create the wrapper.
 * @param {EventTarget} eventTarget - The event target of the event.
 * @returns {Event} The created wrapper. This object is implemented `Event` interface.
 * @private
 */
module.exports.createEventWrapper = function createEventWrapper(event, eventTarget) {
    var timeStamp = (
        typeof event.timeStamp === "number" ? event.timeStamp : Date.now()
    )
    var propertyDefinition = {
        type: {value: event.type, enumerable: true},
        target: {value: eventTarget, enumerable: true},
        currentTarget: {value: eventTarget, enumerable: true},
        eventPhase: {value: 2, enumerable: true},
        bubbles: {value: Boolean(event.bubbles), enumerable: true},
        cancelable: {value: Boolean(event.cancelable), enumerable: true},
        timeStamp: {value: timeStamp, enumerable: true},
        isTrusted: {value: false, enumerable: true},
    }
    propertyDefinition[STOP_IMMEDIATE_PROPAGATION_FLAG] = {value: false, writable: true}
    propertyDefinition[CANCELED_FLAG] = {value: false, writable: true}
    propertyDefinition[PASSIVE_LISTENER_FLAG] = {value: false, writable: true}
    propertyDefinition[ORIGINAL_EVENT] = {value: event}

    // For CustomEvent.
    if (typeof event.detail !== "undefined") {
        propertyDefinition.detail = {value: event.detail, enumerable: true}
    }

    return Object.create(
        Object.create(event, wrapperPrototypeDefinition),
        propertyDefinition
    )
}


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

(function(){
  var crypt = __webpack_require__(50),
      utf8 = __webpack_require__(22).utf8,
      isBuffer = __webpack_require__(53),
      bin = __webpack_require__(22).bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sdk__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel_utils__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__channel_controller__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__preferences__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__channel_live_state__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__list__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_serialized__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__queue_service__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__notifier__ = __webpack_require__(26);










const S_TO_MS_FACTOR = 1000,


// Init things
notifier = new __WEBPACK_IMPORTED_MODULE_8__notifier__["a" /* default */](),
      controller = new __WEBPACK_IMPORTED_MODULE_2__channel_controller__["a" /* default */](),
      list = new __WEBPACK_IMPORTED_MODULE_5__list__["a" /* default */]();

list.addEventListener("ready", () => {
    controller.getChannelsByType().then(channels => list.addChannels(channels));

    list.setProviders(__WEBPACK_IMPORTED_MODULE_6__providers_serialized__["a" /* default */]);

    __WEBPACK_IMPORTED_MODULE_3__preferences__["a" /* default */].get(["updateInterval", "panel_style", "panel_extras", "theme"]).then(([updateInterval, style, extras, theme]) => {
        list.setQueueStatus(parseInt(updateInterval, 10) !== 0);
        list.setStyle(parseInt(style, 10));
        list.setExtrasVisibility(extras);
        list.setTheme(parseInt(theme, 10));
    });
});

list.addEventListener("opencm", () => controller.showManager());
list.addEventListener("addchannel", ({ detail: [login, type] }) => {
    controller.addChannel(login, type);
});
list.addEventListener("refresh", ({ detail: channelId }) => {
    if (channelId) {
        controller.updateChannel(channelId);
    } else {
        controller.updateChannels();
    }
});
list.addEventListener("open", ({ detail: [channelId, what] }) => {
    let p;
    if (typeof channelId === "string") {
        p = Promise.resolve({
            url: [channelId],
            live: new __WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */](__WEBPACK_IMPORTED_MODULE_4__channel_live_state__["a" /* default */].LIVE)
        });
    } else {
        p = controller.getChannel(channelId);
    }

    p.then(channel => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__channel_utils__["a" /* selectOrOpenTab */])(channel, what));
});
list.addEventListener("pause", () => __WEBPACK_IMPORTED_MODULE_7__queue_service__["a" /* pause */]());
list.addEventListener("resume", () => __WEBPACK_IMPORTED_MODULE_7__queue_service__["b" /* resume */]());
list.addEventListener("copy", ({ detail: [channel, type] }) => {
    controller.copyChannelURL(channel, type).then(channel => {
        notifier.notifyCopied(channel.uname);
    });
});

// Wire things up

notifier.addEventListener("click", async ({ detail: channelId }) => {
    const channel = await controller.getChannel(channelId);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__channel_utils__["a" /* selectOrOpenTab */])(channel);
});

controller.addEventListener("channelupdated", ({ detail: channel }) => {
    notifier.sendNotification(channel);
    list.onChannelChanged(channel);
});

controller.addEventListener("channelsadded", ({ detail: channels }) => {
    list.addChannels(channels);
    channels.forEach(channel => notifier.sendNotification(channel));
});

controller.addEventListener("channeldeleted", ({ detail: channelId }) => {
    notifier.onChannelRemoved(channelId);
    list.removeChannel(channelId);
});

controller.addEventListener("beforechanneldeleted", () => __WEBPACK_IMPORTED_MODULE_7__queue_service__["a" /* pause */]());
//TODO do counting instead of relying on randomness being in our favor ;)
controller.addEventListener("afterchanneldeleted", () => __WEBPACK_IMPORTED_MODULE_7__queue_service__["b" /* resume */]());

__WEBPACK_IMPORTED_MODULE_3__preferences__["a" /* default */].get(["theme", "panel_nonlive", "updateInterval", "queue_ratio", "queue_maxRequestBatchSize"]).then(([theme, nonlive, interval, ratio, batchSize]) => {
    controller.setTheme(parseInt(theme, 10));
    list.setNonLiveDisplay(nonlive);
    __WEBPACK_IMPORTED_MODULE_7__queue_service__["c" /* setOptions */]({
        interval: S_TO_MS_FACTOR * interval,
        amount: 1 / ratio,
        maxSize: batchSize
    });
});

__WEBPACK_IMPORTED_MODULE_7__queue_service__["d" /* addListeners */]({
    paused: () => list.setQueuePaused(true),
    resumed: () => list.setQueuePaused(false)
});

__WEBPACK_IMPORTED_MODULE_3__preferences__["a" /* default */].addEventListener("change", ({ detail: { pref, value } }) => {
    if (pref == "manageChannels") {
        controller.showManager();
    } else if (pref == "theme") {
        const theme = parseInt(value, 10);
        controller.setTheme(theme);
        list.setTheme(theme);
    } else if (pref == "panel_nonlive") {
        list.setNonLiveDisplay(parseInt(value, 10));
    } else if (pref == "panel_extras") {
        list.setExtrasVisibility(value);
    } else if (pref == "panel_style") {
        list.setStyle(parseInt(value, 10));
    } else if (pref == "updateInterval") {
        const interval = parseInt(value, 10);
        __WEBPACK_IMPORTED_MODULE_7__queue_service__["e" /* updateOptions */](S_TO_MS_FACTOR * interval);
        list.setQueueStatus(interval !== 0);
    }
});

// Do migration of channel data if necessary
browser.storage.local.get("migrated").then(value => {
    if (!value.migrated) {
        __WEBPACK_IMPORTED_MODULE_0__sdk__["a" /* default */].doAction("migrate-channels").then(([channels, users]) => {
            return Promise.all(users.map(user => controller.addUser(user.login, user.type))).then(() => Promise.all(channels.map(channel => controller.addChannel(channel.login, channel.type))));
        }).then(() => {
            return browser.storage.local.set({
                migrated: true
            });
        });
    }
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTJhNDM5MWNlMzhkMzA1ODYyYzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcmVmZXJlbmNlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2V2ZW50LXRhcmdldC1zaGltL2xpYi9ldmVudC10YXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvY2hhbm5lbC9saXZlLXN0YXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3BhZ2luYXRpb24taGVscGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3F1ZXJ5c3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3Nkay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9sb2dpYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpdmUtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudC10YXJnZXQtc2hpbS9saWIvY29tbW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvc2VyaWFsaXplZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9xdWV1ZS9zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3BhcmVudGFsLWNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL34vY2hhcmVuYy9jaGFyZW5jLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9jaGFubmVsL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvbm90aWZpZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvY2hhbm5lbC9kdW1wLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9jaGFubmVsL21hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvbG9naW5zLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9henVidS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvYmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvZGFpbHltb3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL2RvdXl1dHYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvaGl0Ym94LmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9saXZlc3RyZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9tbGcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL25ldy1saXZlc3RyZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9waWNhcnRvLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy90d2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL3VzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL3lvdXR1YmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcXVldWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvcXVldWUvcGF1c2VhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZ3JvdW5kL3F1ZXVlL3VwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyeXB0L2NyeXB0LmpzIiwid2VicGFjazovLy8uL34vZXZlbnQtdGFyZ2V0LXNoaW0vbGliL2N1c3RvbS1ldmVudC10YXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudC10YXJnZXQtc2hpbS9saWIvZXZlbnQtd3JhcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21kNS9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JhY2tncm91bmQvaW5kZXguanMiXSwibmFtZXMiOlsid2hlbiIsInRhcmdldCIsImV2ZW50IiwiRXZlbnRUYXJnZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwiY2FwdHVyZSIsInRvVXBwZXJDYXNlIiwic3Vic3RyIiwicHJvcGVydHkiLCJsaXN0ZW5lciIsImUiLCJyZW1vdmVMaXN0ZW5lciIsImFkZExpc3RlbmVyIiwiZW1pdCIsImRldGFpbCIsImxlbmd0aCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsIkV2ZW50IiwiaW52b2tlT25jZSIsIm5ld0lkIiwiZm4iLCJjdXJyZW50SWQiLCJhcmdzIiwiZmlsdGVyQXN5bmMiLCJhcnJheSIsImNhbGxiYWNrIiwicHJlZGljYXRlcyIsImFsbCIsIm1hcCIsImZpbHRlciIsImEiLCJpIiwicGlwZSIsInNvdXJjZSIsInBhc3NpdmUiLCJJVEVNX0FSR1MiLCJJdGVtIiwiY29uc3RydWN0b3IiLCJsb2dpbiIsInR5cGUiLCJpZCIsIl91bmFtZSIsIl9sb2dpbiIsIl90eXBlIiwiaW1hZ2UiLCJ1bmFtZSIsInZhbCIsImdldEJlc3RJbWFnZUZvclNpemUiLCJzaXplIiwiTWF0aCIsInJvdW5kIiwicGFyc2VJbnQiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiaGFzT3duUHJvcGVydHkiLCJ0b1N0cmluZyIsImluZGV4IiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiYmlnZ2VzdCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicyIsImNoYXJBdCIsInNsaWNlIiwic2VyaWFsaXplIiwib2JqIiwiVXNlciIsImRlc2VyaWFsaXplIiwicHJvcGVydGllcyIsInByb3BzIiwib21pdCIsImFzc2lnbiIsImZhdm9yaXRlcyIsIkNoYW5uZWwiLCJzdGF0ZSIsInRpdGxlIiwidmlld2VycyIsInRodW1ibmFpbCIsImFyY2hpdmVVcmwiLCJjaGF0VXJsIiwibGFzdE1vZGlmaWVkIiwiY2F0ZWdvcnkiLCJtYXR1cmUiLCJ1cmwiLCJEYXRlIiwibm93IiwibGl2ZSIsIkxpdmVTdGF0ZSIsIl9saXZlIiwiVHlwZUVycm9yIiwiUHJlZmVyZW5jZXMiLCJTREsiLCJtZXNzYWdlIiwiZ2V0IiwicHJlZiIsIkFycmF5IiwiaXNBcnJheSIsInAiLCJkb0FjdGlvbiIsInNldCIsInZhbHVlIiwib3BlbiIsInBvc3RNZXNzYWdlIiwiXyIsImJyb3dzZXIiLCJpMThuIiwiZ2V0TWVzc2FnZSIsIm1ldGhvZE5vdFN1cHBvcnRlZCIsIm1ldGhvZCIsInJlamVjdCIsInF1ZXVlcyIsIldlYWtNYXAiLCJxdWV1ZUZvciIsInByb3ZpZGVyIiwiUHJvdmlkZXJFcnJvciIsIkVycm9yIiwiY29kZSIsIm5hbWUiLCJHZW5lcmljUHJvdmlkZXIiLCJORVRXT1JLX0VSUk9SIiwiQVBJX0VSUk9SIiwiQUNDRVNTX0VSUk9SIiwiTk9SRVNVTFRfRVJST1IiLCJnZXRFcnJvckJ5SFRUUENvZGUiLCJfc3VwcG9ydHNGYXZvcml0ZXMiLCJfc3VwcG9ydHNDcmVkZW50aWFscyIsIl9zdXBwb3J0c0ZlYXR1cmVkIiwiX2VuYWJsZWQiLCJfcXMiLCJfc2V0UXMiLCJfbWF0dXJlIiwicHJlZnMiLCJ0aGVuIiwiUGFyZW50YWxDb250cm9scyIsImVuYWJsZWQiLCJzdXBwb3J0cyIsImZyZWV6ZSIsImNyZWRlbnRpYWxzIiwiZmVhdHVyZWQiLCJnZXRVc2VyRmF2b3JpdGVzIiwidXNlcm5hbWUiLCJnZXRDaGFubmVsRGV0YWlscyIsImNoYW5uZWxuYW1lIiwidXBkYXRlRmF2c1JlcXVlc3QiLCJ1c2VycyIsInJlbW92ZUZhdnNSZXF1ZXN0IiwidW5xdWV1ZVVwZGF0ZVJlcXVlc3QiLCJMT1dfUFJJT1JJVFkiLCJ1cGRhdGVSZXF1ZXN0IiwiY2hhbm5lbHMiLCJyZW1vdmVSZXF1ZXN0IiwiSElHSF9QUklPUklUWSIsInVwZGF0ZUNoYW5uZWwiLCJ1cGRhdGVDaGFubmVscyIsImNoYW5uZWwiLCJnZXRGZWF0dXJlZENoYW5uZWxzIiwic2VhcmNoIiwicXVlcnkiLCJhdXRoVVJMIiwiSUdOT1JFRF9QUk9QRVJUSUVTIiwiT0ZGTElORSIsIkxpdmVTdGF0ZUNvbnN0IiwiTElWRSIsIlJFRElSRUNUIiwiUkVCUk9BRENBU1QiLCJUT1dBUkRfTElWRSIsIlRPV0FSRF9PRkZMSU5FIiwiZ2V0RGVmYXVsdEludGVycHJldGF0aW9uIiwic2VyaWFsaXplZExpdmVTdGF0ZSIsImFsdGVybmF0ZVVzZXJuYW1lIiwiYWx0ZXJuYXRlVVJMIiwiX3N0YXRlIiwiZGVmYXVsdEludGVycHJldGF0aW9uIiwiaXNMaXZlIiwiaW50ZXJwcmV0YXRpb24iLCJzZXRMaXZlIiwiUGFnaW5hdGlvbkhlbHBlciIsIm9wdGlvbnMiLCJyZXF1ZXN0IiwiZmV0Y2hOZXh0UGFnZSIsIm9uQ29tcGxldGUiLCJnZXRJdGVtcyIsInBhZ2VTaXplIiwiZ2V0UGFnZU51bWJlciIsInBhZ2UiLCJpbml0aWFsUGFnZSIsInJlc3VsdCIsImdldFBhZ2UiLCJwcm90b3R5cGUiLCJpbml0aWFsIiwiY2JrIiwiZGF0YSIsImNvbmNhdCIsInJldCIsInByb21pc2VkUGFnaW5hdGlvbkhlbHBlciIsInN0cmluZ2lmeSIsInFzIiwiVVJMU2VhcmNoUGFyYW1zIiwicSIsImFwcGVuZCIsIlNES0NvbW11bmljYXRpb24iLCJwb3J0IiwicnVudGltZSIsImNvbm5lY3QiLCJvbk1lc3NhZ2UiLCJ3YWl0Rm9yQWN0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImVycm9yIiwicGF5bG9hZCIsImlkZW50aXR5IiwiYW5kIiwiZXZlcnkiLCJvciIsInNvbWUiLCJub3QiLCJwcm9taXNlIiwidHdpdGNoIiwiaGl0Ym94IiwidXN0cmVhbSIsInlvdXR1YmUiLCJsaXZlc3RyZWFtIiwibWxnIiwiYXp1YnUiLCJiZWFtIiwicGljYXJ0byIsIm5ld2xpdmVzdHJlYW0iLCJkb3V5dXR2IiwiZGFpbHltb3Rpb24iLCJzZXJpYWxpemVQcm92aWRlcnMiLCJwcm92aWRlcnMiLCJxdWV1ZSIsInNlcnZpY2VzIiwiZGVmYXVsdFJlcXVldWUiLCJyZXNwb25zZSIsIm9rIiwic3RhdHVzIiwiY29tcGxldGVDYWxsYmFjayIsInJlcXVldWUiLCJRdWV1ZVNlcnZpY2UiLCJoaWdoUHJpb3JpdHlSZXF1ZXN0SWRzIiwibG93UHJpb3JpdHlSZXF1ZXN0SWRzIiwiZ2V0UmVxdWVzdFByb3BlcnR5IiwicHJpb3JpdHkiLCJxdWV1ZVJlcXVlc3QiLCJoZWFkZXJzIiwiYXR0ZW1wdCIsImNvbnNvbGUiLCJsb2ciLCJhZGRSZXF1ZXN0IiwiSGVhZGVycyIsIm1heFJldHJpZXMiLCJvbkVycm9yIiwibmF2aWdhdG9yIiwib25MaW5lIiwiZ2V0UmVxdWVzdEJ5SWQiLCJyZXFJZCIsInF1ZXVlVXBkYXRlUmVxdWVzdCIsInVybHMiLCJyYXdIZWFkZXJzIiwicmVxdWVzdHMiLCJza2lwcyIsInB1c2giLCJiaW5kIiwiZ2V0U2VydmljZUZvclByb3ZpZGVyIiwicHJvdmlkZXJOYW1lIiwic2V0T3B0aW9ucyIsInRvU291cmNlIiwiYXV0b0ZldGNoIiwiaW50ZXJ2YWwiLCJhbW91bnQiLCJtYXhTaXplIiwidXBkYXRlT3B0aW9ucyIsInBhdXNlIiwicmVzdW1lIiwiYWRkTGlzdGVuZXJzIiwiY29udGFpbnNQcmlvcml6ZWQiLCJwcmlvcml6ZWRMb2FkZWQiLCJwYXVzZWQiLCJyZXN1bWVkIiwicmVtb3ZlTGlzdGVuZXJzIiwiZ2V0RW5hYmxlZCIsImZpbHRlckluYXByb3ByaWF0ZUNoYW5uZWxzIiwiYyIsImZpbHRlckV4aXN0aW5nRmF2cyIsInVzZXIiLCJjaCIsImluY2x1ZGVzIiwiQ2hhbm5lbENvbnRyb2xsZXIiLCJfcmVhZHkiLCJfcXVldWUiLCJtYW5hZ2VyRXJyb3IiLCJpdGVtVHlwZSIsImNhbmNlbGVkIiwiX21hbmFnZXIiLCJvbkNhbmNlbCIsIm1hbmFnZXJEb25lTG9hZGluZyIsImxvYWRpbmciLCJhZGRDaGFubmVsIiwiX2RlbGV0ZUNhbmNlbGluZ1ZhbHVlIiwicmVtb3ZlQ2hhbm5lbCIsImNhdGNoIiwiYWRkVXNlciIsInJlbW92ZVVzZXIiLCJ1cGRhdGVVc2VyIiwiYXV0b0FkZFVzZXJzIiwiZ2V0Q2hhbm5lbHNCeVR5cGUiLCJvbkNoYW5uZWxBZGRlZCIsImdldFVzZXJzQnlUeXBlIiwidXNyIiwib25Vc2VyQWRkZWQiLCJhZGRQcm92aWRlcnMiLCJkZWxldGVkVHlwZXMiLCJNYXAiLCJkZWJvdW5jZWRFdmVudCIsImRlYm91bmNlIiwiZGVsZXRlQ2FsbGJhY2siLCJfbGlzdCIsImRlbGV0ZSIsInIiLCJjaGFucyIsImNoYW4iLCJoYXMiLCJwYXJ0aWFsIiwib25DaGFubmVsUmVtb3ZlZCIsIm9uVXNlclJlbW92ZWQiLCJvbkNoYW5uZWxVcGRhdGVkIiwib25Vc2VyVXBkYXRlZCIsIl9ldmVudFNpbmsiLCJzZXRVc2VyIiwiYWRkQ2hhbm5lbHMiLCJzZXRDaGFubmVsIiwiY2hhbm5lbHNDYiIsInVzZXJzQ2IiLCJfZW5zdXJlUXVldWVSZWFkeSIsImNoYW5uZWxJZCIsImdldENoYW5uZWwiLCJ1IiwiX3VwZGF0ZVVzZXIiLCJ1cGRhdGVkVXNlciIsImZpbmFsVXNlciIsInVzZXJJZCIsImdldFVzZXIiLCJyZW1vdmVGYXZvcml0ZXMiLCJyZW1vdmVDaGFubmVsc0J5VXNlckZhdm9yaXRlcyIsIl9hZGRGb3VuZENyZWRlbnRpYWxzIiwiY3JlZGVudGlhbCIsIl9maW5kVXNlcnNCeVVSTCIsInNob3dNYW5hZ2VyIiwic2V0VGhlbWUiLCJ0aGVtZSIsImNvcHlDaGFubmVsVVJMIiwiZG9jdW1lbnQiLCJleGVjQ29tbWFuZCIsInBhdHRlcm4iLCJjbGlwYm9hcmREYXRhIiwic2V0RGF0YSIsInJlcGxhY2UiLCJwcmV2ZW50RGVmYXVsdCIsInNlbGVjdE9yT3BlblRhYiIsIndoYXQiLCJ0b0NoZWNrIiwidGFicyIsInVwZGF0ZSIsImFjdGl2ZSIsImNyZWF0ZSIsIkxJVkVfSUNPTlMiLCJPRkZMSU5FX0lDT05TIiwiTGlzdFZpZXciLCJyZWFkeSIsIl9saXZlU3RhdGUiLCJTZXQiLCJub25saXZlIiwib25Db25uZWN0IiwiX3NldHVwUG9ydCIsInVwZGF0ZUJhZGdlIiwic2V0Tm9uTGl2ZURpc3BsYXkiLCJzZXRGZWF0dXJlZCIsIl91bnJlZ2lzdGVyQ2hhbm5lbCIsIm9uRGlzY29ubmVjdCIsIl9lbWl0VG9MaXN0IiwiY291bnROb25saXZlIiwibm9uTGl2ZURpc3BsYXkiLCJESVNUSU5DVCIsImJyb3dzZXJBY3Rpb24iLCJzZXRCYWRnZVRleHQiLCJ0ZXh0Iiwic2V0SWNvbiIsInBhdGgiLCJzZXRUaXRsZSIsIl91cGRhdGVDaGFubmVsIiwiX3JlZ2lzdGVyQ2hhbm5lbCIsImFkZCIsImxpdmVTdGF0ZSIsImNsZWFyIiwic2V0U3R5bGUiLCJzdHlsZSIsIl9zdHlsZSIsInNldEV4dHJhc1Zpc2liaWxpdHkiLCJ2aXNpYmxlIiwiX2V4dHJhcyIsInNldENoYW5uZWxMaXZlIiwic2V0Q2hhbm5lbE9mZmxpbmUiLCJzZXRDaGFubmVsRGlzdGluY3QiLCJzZXRQcm92aWRlcnMiLCJzZXJpYWxpemVkUHJvdmlkZXJzIiwic2V0UXVldWVTdGF0dXMiLCJzZXRRdWV1ZVBhdXNlZCIsIm9uQ2hhbm5lbENoYW5nZWQiLCJMSVZFX0RJU1RJTkNUIiwiU1RZTEVfQ09NUEFDVCIsIlNUWUxFX05PUk1BTCIsIlNUWUxFX1RIVU1CTkFJTCIsIkxJVkVfQk9UVE9NIiwiTk9USUZJQ0FUSU9OX0lDT05fU0laRSIsIk5vdGlmaWVyIiwiY2hhbm5lbFRpdGxlcyIsImNoYW5uZWxTdGF0ZXMiLCJub3RpZmljYXRpb25zIiwib25DbGlja2VkIiwic3RhcnRzV2l0aCIsIm9ubGluZU5vdGlmaWNhdGlvbnMiLCJ0aXRsZU5vdGlmaWNhdGlvbnMiLCJvZmZsaW5lTm90aWZpY2F0aW9ucyIsIm5vbmxpdmVOb3RpZmljYXRpb25zIiwic2hvd05vdGlmaWNhdGlvbnMiLCJfc2V0Q2hhbm5lbFN0YXRlIiwiX2NoYW5uZWxTdGF0ZUNoYW5nZWQiLCJvbGRTdGF0ZSIsInVuZGVmaW5lZCIsIl9nZXRMaXZlSW50ZXJwcmV0YXRpb24iLCJzZW5kTm90aWZpY2F0aW9uIiwidGFiIiwiY3VycmVudFdpbmRvdyIsImxpdmVJbnRlcnByZXRhdGlvbiIsInN0YXRlTmFtZSIsIm9wdHMiLCJpY29uVXJsIiwibm90aWZ5Q29waWVkIiwiY2hhbm5lbE5hbWUiLCJpY29uVVJMIiwiUFJFRlNfTUFQUElORyIsInJhdGlvIiwibWF4QW1vdW50IiwicGFuZWwiLCJleHRyYXMiLCJ3aWR0aCIsImhlaWdodCIsImJhZGdlIiwibWlzYyIsImNhY2hlVGltZSIsImZpbmRNYXR1cmUiLCJwcm9taXNlcyIsImJyYW5jaCIsInBsYXRmb3JtIiwiZ2V0UGxhdGZvcm1JbmZvIiwibWFuaWZlc3QiLCJnZXRNYW5pZmVzdCIsImRlYnVnRHVtcCIsIm1ldGEiLCJ2ZXJzaW9uIiwib3MiLCJwbGF0Zm9ybUFyY2giLCJhcmNoIiwibGFuZ3VhZ2UiLCJnZXRVSUxhbmd1YWdlIiwibGFzdEVycm9yIiwiY29weSIsImV4cG9ydHMiLCJKU09OIiwibG9hZCIsIlZFUlNJT04iLCJOQU1FIiwiQ2hhbm5lbExpc3QiLCJkYiIsIl9vcGVuaW5nREIiLCJpZENhY2hlIiwib3BlbkRCIiwiZG9udFRyeSIsImluZGV4ZWREQiIsIm9udXBncmFkZW5lZWRlZCIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImF1dG9JbmNyZW1lbnQiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsIm9uc3VjY2VzcyIsInRyYW5zYWN0aW9uIiwic3RvcmUiLCJvYmplY3RTdG9yZSIsIm1pbkRhdGUiLCJyZXEiLCJvcGVuQ3Vyc29yIiwiY3Vyc29yIiwiY29udGludWUiLCJvbmVycm9yIiwiY2xvc2UiLCJnZXRDaGFubmVsSWQiLCJpbmZvIiwid2FybiIsImdldFVzZXJJZCIsImNoYW5uZWxFeGlzdHMiLCJhZGRlZENoYW5uZWxzIiwiaXJlcSIsIm9uY29tcGxldGUiLCJ1c2VyRXhpc3RzIiwicHV0IiwicmVtb3ZlVXNlcnNXaXRoRmF2b3JpdGUiLCJsaXZlU3RhdHVzIiwicmV0Y2hhbnMiLCJrZXlSYW5nZSIsIklEQktleVJhbmdlIiwib25seSIsInJldHVzcnMiLCJnZXRVc2Vyc0J5RmF2b3JpdGUiLCJpbmRleE9mIiwiZ2V0Q2hhbm5lbHNCeVVzZXJGYXZvcml0ZXMiLCJjaGFubmFtZSIsImRvbmUiLCJoYXJkIiwiY2hhblByb21pc2UiLCJjaGFuUmVxIiwidXNyUHJvbWlzZSIsInVzclJlcSIsImRlbGV0ZURhdGFiYXNlIiwib25ibG9ja2VkIiwiQ2hhbm5lbHNNYW5hZ2VyIiwiX2xvYWRpbmciLCJ0YWJJRCIsImNhbmNlbGluZ1ZhbHVlcyIsIl9lbWl0VG9Xb3JrZXIiLCJpc1NlY29uZGFyeSIsInNlbmRlciIsInZhbHVlcyIsImpvaW4iLCJjaGFubmVsT2JqIiwiYmFzZVVSTCIsImdldENoYW5uZWxGcm9tSlNPTiIsImpzb25DaGFubmVsIiwiY2hhbm5lbFVybCIsInVybF9jaGFubmVsIiwiZGlzcGxheV9uYW1lIiwidXJsX2NoYXQiLCJwcm9maWxlIiwidXJsX3Bob3RvX3NtYWxsIiwidXJsX3Bob3RvX2xhcmdlIiwiaXNfbGl2ZSIsInVybF90aHVtYm5haWwiLCJ2aWV3X2NvdW50IiwiQXp1YnUiLCJmb2xsb3dzIiwidXNlcmRhdGEiLCJwYXJzZWRKU09OIiwibGltaXQiLCJmb2xsb3ciLCJvbGRVc2VyIiwiZmluZCIsImZhdiIsImNoYW5uZWxuYW1lcyIsIm9yZGVyQnkiLCJfZm9ybWF0IiwiY2hhdFVSTCIsIkRFRkFVTFRfQVZBVEFSX1VSTCIsIlNJWkVTIiwiZ2V0SW1hZ2VGcm9tVXNlcklEIiwidG9rZW4iLCJvbmxpbmUiLCJ2aWV3ZXJzQ3VycmVudCIsImF1ZGllbmNlIiwiZ2V0SW1hZ2VGcm9tQXZhdGFycyIsImF2YXRhcnMiLCJhdmF0YXIiLCJzcGxpdCIsInJlbGlkIiwiQmVhbSIsIl9nZXRVc2VySWRGcm9tVXNlcm5hbWUiLCJtZW1vaXplIiwidXNlcmlkIiwic3Vic2NyaXB0aW9ucyIsInN1YiIsImJhc2VVcmwiLCJBVkFUQVJfU0laRVMiLCJVU0VSX0ZJRUxEUyIsImpzb24iLCJkb1VzZXIiLCJzY3JlZW5uYW1lIiwicmVkdWNlIiwiRGFpbHltb3Rpb24iLCJfZ2V0Q2hhbm5lbEJ5SUQiLCJmaWVsZHMiLCJsaXN0IiwiX2dldFN0cmVhbURldGFpbHNGb3JDaGFubmVsIiwic29ydCIsIml0ZW0iLCJjaGF0X2VtYmVkX3VybCIsInRodW1ibmFpbF91cmwiLCJvbmFpciIsIl9nZXRGYXZzIiwiaGFzX21vcmUiLCJ1c2VybmFtZXMiLCJpZHMiLCJkIiwidiIsInRodW1ibmFpbF8yNDBfdXJsIiwicm9vbVVSTCIsInJvb21faWQiLCJyb29tX25hbWUiLCJzdWJqZWN0Iiwib3duZXJfYXZhdGFyIiwic2hvd19zdGF0dXMiLCJyb29tX3NyYyIsImdhbWVfbmFtZSIsInNpZ25BUEkiLCJlbmRwb2ludCIsImFyZ3VtZW50Iiwic2lnbiIsIm1kNSIsIkRvdXl1dHYiLCJVU0VSX0VWRU5UUyIsIkJBU0VfRVZFTlRTIiwiRXZlbnRTaW5rIiwiYXJjaGl2ZVVSTCIsImNkblVSTCIsImdldENoYW5uZWxGcm9tSnNvbiIsImNobyIsInVzZXJfbmFtZSIsIm1lZGlhX2Rpc3BsYXlfbmFtZSIsImNoYW5uZWxfbGluayIsInVzZXJfbG9nbyIsInVzZXJfbG9nb19zbWFsbCIsIm1lZGlhX3N0YXR1cyIsImNhdGVnb3J5X25hbWUiLCJtZWRpYV92aWV3cyIsIm1lZGlhX3RodW1ibmFpbCIsIm1lZGlhX2lzX2xpdmUiLCJtZWRpYV9tYXR1cmUiLCJIaXRib3giLCJfZ2V0Q2hhbm5lbHMiLCJmb2xsb3dpbmciLCJuZXdDaGFubmVscyIsInF1ZXJ5c3RyaW5nIiwicHVibGljT25seSIsIm0iLCJnZXRDaGFubmVsQVBJVXJsIiwiY2hhbm5lbGxvZ2luIiwiTGl2ZXN0cmVhbSIsInRvTG93ZXJDYXNlIiwibGluayIsImN1cnJlbnRWaWV3ZXJDb3VudCIsInJlcXVlc3RMb2dpbiIsIm1hdGNoIiwiaW5mb1VSTCIsImdhbWVVUkwiLCJpbmZvQXJncyIsInNob3dSZWJyb2FkY2FzdHMiLCJnYW1lcyIsIk1MRyIsIl9nZXRHYW1lIiwiZ2FtZSIsImciLCJpdGVtcyIsImVycm9ycyIsIl9nZXRDaGFubmVsRnJvbUpTT04iLCJzdHJlYW1fbmFtZSIsImJyYWNrZXRfdXJsIiwiaW1hZ2VfMV8xIiwic3VidGl0bGUiLCJpbWFnZV8xNl85X21lZGl1bSIsImdhbWVfaWQiLCJzdGF0dXNfY29kZSIsInNsdWciLCJjaGFubmVsX2lkIiwiZm9sbG93ZWRDaGFubmVscyIsInNob3J0X25hbWUiLCJmdWxsX25hbWUiLCJwaWN0dXJlIiwic21hbGxfdXJsIiwidGh1bWJfdXJsIiwiTmV3TGl2ZXN0cmVhbSIsInN1cHBvcnRzRmF2b3JpdGVzIiwiX2dldENoYW5uZWxTdGF0dXMiLCJ1cGNvbWluZ19ldmVudHMiLCJicm9hZGNhc3RfaWQiLCJwYXN0X2V2ZW50cyIsInZpZXdlcl9jb3VudCIsInRvdGFsIiwiYXBpS2V5IiwianNvbkNoYW4iLCJhdmF0YXJfdXJsIiwiaXNfb25saW5lIiwiaXNfbnNmdyIsImN1cnJlbnRfdmlld2VycyIsImNoYW5uZWxfdGl0bGUiLCJpc19tdWx0aXN0cmVhbSIsImNvbnRlbnRfdHlwZSIsIlBpY2FydG8iLCJyZXNwIiwicGFyc2VKU09OIiwiZGVmYXVsdEF2YXRhciIsIml0ZW1zUGVyUGFnZSIsImlkT2ZDaGFubmVsIiwidXJsRm9yU2l6ZSIsImltZ1VSTCIsImdldEltYWdlT2JqIiwiZGVkdXBlIiwiYiIsImxvZ28iLCJnZXRTdHJlYW1UeXBlUGFyYW0iLCJkZWxpbSIsInNob3dQbGF5bGlzdCIsIlR3aXRjaCIsIl9pZCIsImNoYW5uZWxzU3RyaW5nIiwic3RyZWFtcyIsInR3aXRjaF9zaG93UGxheWxpc3QiLCJpc19wbGF5bGlzdCIsInByZXZpZXciLCJtZWRpdW0iLCJvbGRDaGFuIiwiZmluZENoYW4iLCJlbnRyaWVzIiwibGl2ZUNoYW5zIiwib2ZmbGluZUNoYW5zIiwicGxheWxpc3RDaGFucyIsIl9nZXRIb3N0ZWRDaGFubmVscyIsIl9nZXRBY3RpdmVQbGF5bGlzdEluZm8iLCJpZ25vcmVIb3N0ZWQiLCJzdHJlYW0iLCJfZ2V0SG9zdGVkQ2hhbm5lbCIsImxvZ2lucyIsInN0cmVhbVR5cGVQYXJhbSIsImxpdmVDaGFubmVscyIsIl9nZXRDaGFubmVsSWQiLCJvZmZDaGFucyIsImNoYW5uZWxJZHMiLCJleGlzdGluZ0NoYW5zIiwiaG9zdCIsImhvc3RzIiwiaG9zdGluZyIsImhvc3RfbG9naW4iLCJjaGlkIiwidGFyZ2V0X2xvZ2luIiwiaG9zdGVkQ2hhbm5lbCIsImNocyIsInBsYXlsaXN0IiwicGxheWhlYWQiLCJ2b2QiLCJ2b2RzIiwiYWN0aXZlX3ZvZF9pbmRleCIsIm9yaWdpbmFsVXJsIiwidGlueXVybCIsIm93bmVyIiwidGFncyIsInN0YXRzIiwidmlld2VyIiwidmlld2VyX3RvdGFsIiwiVXN0cmVhbSIsInJldHJpZWQiLCJnZXRMb2NhbGUiLCJZb3VUdWJlIiwiX2dldENhdGVnb3J5IiwiY2F0ZWdvcnlJZCIsInNuaXBwZXQiLCJfZ2V0Q2hhbm5lbEJ5SWQiLCJwYXJ0Iiwia2V5IiwidGh1bWJuYWlscyIsImRlZmF1bHQiLCJoaWdoIiwiZm9yVXNlcm5hbWUiLCJzdWJzT3B0aW9ucyIsIm1heFJlc3VsdHMiLCJuZXh0UGFnZVRva2VuIiwicGFnZUluZm8iLCJ0b3RhbFJlc3VsdHMiLCJyZXN1bHRzUGVyUGFnZSIsInJlc291cmNlSWQiLCJvZmZsaW5lQ291bnQiLCJldmVudFR5cGUiLCJnZXRMaXZlU3RyZWFtcyIsInZpZGVvcyIsImhsIiwidmlkZW8iLCJsaXZlU3RyZWFtaW5nRGV0YWlscyIsImNvbmN1cnJlbnRWaWV3ZXJzIiwiY2hhbm5lbExvZ2luIiwidmlkZW9JZCIsInN0cmVhbUlkcyIsIm9yZGVyIiwicmVsZXZhbmNlTGFuZ3VhZ2UiLCJzYWZlU2VhcmNoIiwiZW50cnkiLCJSZXF1ZXN0UXVldWUiLCJfYWxhcm1OYW1lIiwibGFzdElEIiwiYWxhcm1zIiwib25BbGFybSIsImFsYXJtIiwibWF4IiwibWluIiwiZ2V0UmVxdWVzdEJhdGNoIiwicmVxdWVzdE9wdGlvbnMiLCJnZXRSZXF1ZXN0Iiwic3BlYyIsInNwbGljZSIsImZldGNoIiwicmVkaXJlY3QiLCJqc29uQ2xvbmUiLCJjbG9uZSIsImdldFJlcXVlc3RJbmRleCIsImJhdGNoU2l6ZSIsIndvcmtpbmdPblF1ZXVlIiwicGVyaW9kSW5NaW51dGVzIiwicmVxdWVzdFF1ZXVlZCIsImZpbmRJbmRleCIsIlBhdXNlYWJsZVF1ZXVlIiwiX2NvbmZpZ3VyZWQiLCJfcXVldWVTdGF0ZSIsIlVwZGF0ZVF1ZXVlIiwicmVxdWVzdEFyZ3MiLCJwZXJzaXN0ZW50IiwicHJpb3JpemVkIiwic2tpcCIsInBlcnNpc3QiLCJwcmlvcml6ZSIsInNraXBwZWQiLCJnZXRGaXJzdFByaW9yaXplZCIsImdldFJlcXVlc3RCeUluZGV4IiwiZ2V0QWxsUHJpb3JpemVkIiwiU19UT19NU19GQUNUT1IiLCJub3RpZmllciIsImNvbnRyb2xsZXIiLCJ1cGRhdGVJbnRlcnZhbCIsInN0b3JhZ2UiLCJsb2Nh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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QUFqQyxDQUFzQyxDQUFDLENBQUVpQixRQUFGLEVBQVlMLEtBQVosQ0FBRCxLQUF5QjtBQUMzRCxtQkFBT2xKLFFBQVEyQixHQUFSLENBQVl1SCxNQUFNdEgsR0FBTixDQUFXa1EsSUFBRCxJQUFVa2lCLFdBQVdqaEIsT0FBWCxDQUFtQmpCLEtBQUt4UCxLQUF4QixFQUErQndQLEtBQUt2UCxJQUFwQyxDQUFwQixDQUFaLEVBQ0YrRixJQURFLENBQ0csTUFBTXRJLFFBQVEyQixHQUFSLENBQVk0SCxTQUFTM0gsR0FBVCxDQUFjZ0ksT0FBRCxJQUFhb3FCLFdBQVdyaEIsVUFBWCxDQUFzQi9JLFFBQVF0SCxLQUE5QixFQUFxQ3NILFFBQVFySCxJQUE3QyxDQUExQixDQUFaLENBRFQsQ0FBUDtBQUVILFNBSEQsRUFHRytGLElBSEgsQ0FHUSxNQUFNO0FBQ1YsbUJBQU81QixRQUFRd3RCLE9BQVIsQ0FBZ0JDLEtBQWhCLENBQXNCOXRCLEdBQXRCLENBQTBCO0FBQzdCK3RCLDBCQUFVO0FBRG1CLGFBQTFCLENBQVA7QUFHSCxTQVBEO0FBUUg7QUFDSixDQVhELEUiLCJmaWxlIjoiYmFja2dyb3VuZC9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDU1KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBhMmE0MzkxY2UzOGQzMDU4NjJjOCIsIi8qKlxuICogQ29uY3VycmVuY3kgdXRpbHMgZm9yIGV2ZW50cy5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICovXG5cbmV4cG9ydCBjb25zdCB3aGVuID0gKHRhcmdldCwgZXZlbnQpID0+IHtcbiAgICBpZih0YXJnZXQgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCByZXNvbHZlLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmKFwib25cIiArIGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zdWJzdHIoMSkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBcIm9uXCIgKyBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc3Vic3RyKDEpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XS5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0uYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVtaXQgPSAodGFyZ2V0LCBldmVudCwgLi4uZGV0YWlsKSA9PiB7XG4gICAgaWYoZGV0YWlsLmxlbmd0aCkge1xuICAgICAgICBpZihkZXRhaWwubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGRldGFpbCA9IGRldGFpbFswXTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHsgZGV0YWlsIH0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudCkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU28gdGhpcyBpcyBhIG1hZ2ljIGZ1bmN0aW9uLiBJdCBtYWtlcyB0aGluZ3Mgd29yayBieSBiZWluZyBraW5kIG9mIGEgcmV2ZXJzZWRcbiAqIG9uY2UuIEJ1dCBsZXQgbWUgZXhwbGFpbjogdGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgZXhlY3V0ZSB0aGUgZnVuY3Rpb24gaWYgaXRcbiAqIGlzIHRoZSBtb3N0IHJlY2VudGx5IHJlZ2lzdGVyZWQgb25lLiBUaGUgZmlyc3QgYXJndW1lbnQgaGFzIHRvIGJlIGFuIHVuaXF1ZVxuICogaWQsIHdoaWNoIGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIGNhbGxiYWNrIGlzIHRoZSBtb3N0IHJlY2VudCBvbmUuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdpdGggREIgY2FsbGJhY2tzIHdoZW4gY2hhbm5lbHMgYXJlXG4gKiBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gbmV3SWQgLSBBbiBpZCBmb3IgdGhpcyBuZXcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIE5lZWRzIHRvIGJlIHRoZSBzYW1lIGNhbGxiYWNrIHRvIHdvcmsuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaXMgXCJkZWJvdW5jZWRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IGludm9rZU9uY2UgPSAobmV3SWQsIGZuKSA9PiB7XG4gICAgZm4uY3VycmVudElkID0gbmV3SWQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYoZm4uY3VycmVudElkID09IG5ld0lkKSB7XG4gICAgICAgICAgICBkZWxldGUgZm4uY3VycmVudElkO1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgYW4gYXJyYXkgYmFzZWQgb24gYSBjb25kaXRpb24gdGhhdCBpcyByZXR1cm5lZCBhcyBwcm9taXNlLlxuICogTGlrZSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLCBqdXN0IHRoYXQgaXQgdGFrZXMgYSBwcm9taXNlIGZyb20gdGhlIGNhbGxiYWNrXG4gKiBpbnN0ZWFkIG9mIGEgYm9vbGVhbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFycmF5IHRvIGZpbHRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZmlsdGVyIG9uLiBTaG91bGQgcmV0dXJuIGEgcHJvbWlzZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgZmlsdGVyZWQgYmFzZWQgb24gdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXJBc3luYyA9IGFzeW5jIChhcnJheSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBwcmVkaWNhdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXJyYXkubWFwKGNhbGxiYWNrKSk7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcigoYSwgaSkgPT4gcHJlZGljYXRlc1tpXSk7XG59O1xuXG4vKipcbiAqIFBpcGUgYW4gZXZlbnQgZnJvbSBvbmUgdGFyZ2V0IHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6ZXZlbnQtdGFyZ2V0LkV2ZW50VGFyZ2V0fSBzb3VyY2UgLSBPYmplY3QgZW1pdHRpbmcgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gRXZlbnQgdG8gcGlwZSB0aHJvdWdoLlxuICogQHBhcmFtIHttb2R1bGU6ZXZlbnQtdGFyZ2V0LkV2ZW50VGFyZ2V0fSB0YXJnZXQgLSBUYXJnZXQgdG8gcGlwZSB0by5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBjb25zdCBwaXBlID0gKHNvdXJjZSwgZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoZSkgPT4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMuanMiLCIvKipcbiAqIENoYW5uZWwgYW5kIFVzZXIgT2JqZWN0cy5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBjaGFubmVsL2NvcmVcbiAqL1xuaW1wb3J0IHsgb21pdCB9IGZyb20gXCJ1bmRlcnNjb3JlXCI7XG5pbXBvcnQgTGl2ZVN0YXRlIGZyb20gXCIuL2xpdmUtc3RhdGVcIjtcblxuY29uc3QgSVRFTV9BUkdTID0gWyBcImxvZ2luXCIsIFwidHlwZVwiLCBcImlkXCIsIFwibGl2ZVwiIF07XG5cbi8qKlxuICogQSBnZW5lcmljIHRoaW5nLlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIEl0ZW0ge1xuICAgIF91bmFtZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvZ2luIC0gVW5pcXVlIGxvZ2luIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBQcm92aWRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaWRdIC0gRXh0ZW5zaW9uIGludGVybmFsIElEIGlmIGFscmVhZHkga25vd24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9naW4sIHR5cGUsIGlkKSB7XG4gICAgICAgIHRoaXMuX2xvZ2luID0gbG9naW47XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IHdpdGggdXNlciBhdmF0YXJzLCBieSB0aGVpciBzaXplIGluIHBpeGVscyBhcyBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0Ljwoc3RyaW5nfG51bWJlcik+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbWFnZSA9IHt9O1xuICAgICAgICBpZihpZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBWYWx1ZSBvZiB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvY29yZX5JdGVtI2xvZ2lufVxuICAgICAqL1xuICAgIGdldCB1bmFtZSgpIHtcbiAgICAgICAgaWYodGhpcy5fdW5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ2luO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCB1bmFtZSh2YWwpIHtcbiAgICAgICAgaWYodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl91bmFtZSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbG9naW4gbmFtZSBvZiB0aGUgdXNlciwgdGhpcyBzaG91bGQgYmUgYSB1bmlxdWUgc3RyaW5nIG9yIG51bWJlciB3aXRoaW5cbiAgICAgKiB0aGUgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgbG9naW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHByb3ZpZGVyIHR5cGUgdGhpcyB1c2VyIGlzIGZyb20uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgLy9tZXRob2RzXG4gICAgLyoqXG4gICAgICogUmV0dW5zIHRoZSBVUkwgdG8gdGhlIGJlc3QgaW1hZ2UgZm9yIGRpc3BsYXlpbmcgYXQgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgdGhlIGltYWdlIHdpbGwgYmUgZGlzcGxheWVkIGluIGluIHBpeGVscy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBbiBVUkwgdG8gYW4gaW1hZ2UuXG4gICAgICovXG4gICAgZ2V0QmVzdEltYWdlRm9yU2l6ZShzaXplKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLnJvdW5kKHBhcnNlSW50KHNpemUsIDEwKSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gc2hvcnRjdXQgaWYgdGhlcmUncyBhbiBpbWFnZSB3aXRoIHRoZSBzaXplIGRlbWFuZGVkXG4gICAgICAgIGlmKHRoaXMuaW1hZ2UuaGFzT3duUHJvcGVydHkoc2l6ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2Vbc2l6ZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggbmV4dCBiaWdnZXN0IGltYWdlXG4gICAgICAgIGxldCBpbmRleCA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBiaWdnZXN0ID0gMDtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbWFnZSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgcyA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgICAgIGlmKHMgPiBzaXplICYmIHMgPCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHMgPiBiaWdnZXN0KSB7XG4gICAgICAgICAgICAgICAgYmlnZ2VzdCA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGluZGV4ID4gYmlnZ2VzdCkge1xuICAgICAgICAgICAgaW5kZXggPSBiaWdnZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VbaW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB1c2VyIHdpdGggdGhlIGZpcnN0XG4gICAgICogICAgICAgICAgbGV0dGVyIGNhcGl0YWxpemVkLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRoaXMudW5hbWUuc2xpY2UoMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvY29yZX5JdGVtfVxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gU2VyaWFsaXplZEl0ZW1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbG9naW5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48KHN0cmluZ3xudW1iZXIpLHN0cmluZz59IGltYWdlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW2lkXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBpdGVtIGludG8gYSBub3JtYWwgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmV+U2VyaWFsaXplZEl0ZW19IEEgSlNPTiBzZXJpYWxpemFibGUgdmVyc2lvblxuICAgICAqICAgICAgICAgIG9mIHRoaXMgaXRlbS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgIHVuYW1lOiB0aGlzLnVuYW1lLFxuICAgICAgICAgICAgbG9naW46IHRoaXMubG9naW4sXG4gICAgICAgICAgICBpbWFnZTogdGhpcy5pbWFnZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgICB9O1xuICAgICAgICBpZih0aGlzLmlkKSB7XG4gICAgICAgICAgICBvYmouaWQgPSB0aGlzLmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyB1c2VyLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpjaGFubmVsL2NvcmV+SXRlbVxuICovXG5jbGFzcyBVc2VyIGV4dGVuZHMgSXRlbSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlflNlcmlhbGl6ZWRVc2VyfSBwcm9wZXJ0aWVzIC0gU2VyaWFsaXplZCBvYmplY3RcbiAgICAgKiAgICAgICAgdG8gdHVybiBpbnRvIGEgdXNlci5cbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyfSBVc2VyIGJhc2VkIG9uIHRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUocHJvcGVydGllcykge1xuICAgICAgICBjb25zdCBwcm9wcyA9IG9taXQocHJvcGVydGllcywgSVRFTV9BUkdTKTtcbiAgICAgICAgcHJvcHMuX3VuYW1lID0gcHJvcGVydGllcy51bmFtZTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVzZXIoLi4uSVRFTV9BUkdTLm1hcCgoYSkgPT4gcHJvcGVydGllc1thXSkpLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvZ2luIC0gTG9naW4gb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUeXBlL1Byb3ZpZGVyIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaWRdIC0gSUQgb2YgdGhlIHVzZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9naW4sIHR5cGUsIGlkKSB7XG4gICAgICAgIHN1cGVyKGxvZ2luLCB0eXBlLCBpZCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmYXZvcml0ZSBjaGFubmVscyBvZiB0aGlzIHVzZXIgYXMgYW4gYXJyYXkgb2YgbG9naW5zLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZhdm9yaXRlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIHZlcnNpb24gb2Yge0BsaW5rIG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn0uXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7bW9kdWxlOmNoYW5uZWwvY29yZX5TZXJpYWxpemVkSXRlbX0gU2VyaWFsaXplZFVzZXJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBmYXZvcml0ZXNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIHVzZXIgaW50byBhIG5vcm1hbCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNoYW5uZWwvY29yZX5TZXJpYWxpemVkVXNlcn0gQSBKU09OIHNlcmlhbGl6YWJsZSB2ZXJzaW9uXG4gICAgICogICAgICAgICAgb2YgdGhpcyB1c2VyLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3VwZXIuc2VyaWFsaXplKCksIHtcbiAgICAgICAgICAgIGZhdm9yaXRlczogdGhpcy5mYXZvcml0ZXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBDaGFubmVsIG9iamVjdC5cbiAqXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y2hhbm5lbC9jb3Jlfkl0ZW1cbiAqL1xuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIEl0ZW0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZX5TZXJpYWxpemVkQ2hhbm5lbH0gcHJvcGVydGllcyAtIFNlcmlhbHplZCBvYmplY3RcbiAgICAgKiAgICAgICAgdG8gZGVzZXJpYWxpemUgaW50byBhIGNoYW5uZWwuXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gRGVzZXJpYWxpemVkIGNoYW5uZWwgYmFzZWQgb24gdGhlXG4gICAgICogICAgICAgICAgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gb21pdChwcm9wZXJ0aWVzLCBJVEVNX0FSR1MpO1xuICAgICAgICBwcm9wcy5fdW5hbWUgPSBwcm9wZXJ0aWVzLnVuYW1lO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgQ2hhbm5lbCguLi5JVEVNX0FSR1MubWFwKChhKSA9PiBwcm9wZXJ0aWVzW2FdKSksIHByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIGxpdmUgYnJvYWRjYXN0LlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqL1xuICAgIHRpdGxlID0gJyc7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB2aWV3ZXJzIG9mIHRoZSBsaXZlIGJyb2FkY2FzdCwgLTEgaWYgdW5rbm93bi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB2aWV3ZXJzID0gLTE7XG4gICAgLyoqXG4gICAgICogVGh1bWJuYWlsIG9mIHRoZSBsaXZlIGJyb2FkY2FzdC4gVHlwaWNhbGx5IGRpc3BsYXllZCBhdCBhIHdpZHRoIG9mIDMyMHB4LlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqL1xuICAgIHRodW1ibmFpbCA9ICcnO1xuICAgIC8qKlxuICAgICAqIEEgVVJMIHBvaW50aW5nIHRvIGEgcGFnZSBsaXN0aW5nIHBhc3QgYnJvYWRjYXN0cy4gT3BlbmVkIHdoZW4gY2xpY2tlZCBvbiB0aGVcbiAgICAgKiBjaGFubmVsIHdoaWxlIG9mZmxpbmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICovXG4gICAgYXJjaGl2ZVVybCA9ICcnO1xuICAgIC8qKlxuICAgICAqIEEgVVJMIHRvIGEgcGFnZSBjb250YWluaW5nIG9ubHkgdGhlIGNoYXQgZm9yIGEgYnJvYWRjYXN0LlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqL1xuICAgIGNoYXRVcmwgPSAnJztcbiAgICAvKipcbiAgICAgKiBBIFVOSVggdGltZXN0YW1wLCBhdXRvbWF0aWNhbGx5IHNldCBieSB0aGUgQ2hhbm5lbExpc3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBkZWZhdWx0IERhdGUubm93KClcbiAgICAgKi9cbiAgICBsYXN0TW9kaWZpZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYXRlZ29yeSBvZiB0aGUgbGl2ZSBicm9hZGNhc3QgaWYga25vd24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICovXG4gICAgY2F0ZWdvcnkgPSAnJztcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY2hhbm5lbCdzIGNvbnRlbnQgaXMgcmF0ZWQgbWF0dXJlLiBPbmx5IHRydWUgaWYgdGhlIGNvbnRlbnQgcmF0aW5nXG4gICAgICogaXMga25vd24gYW5kIGl0IGlzIGZvciBtYXR1cmUgYXVkaWVuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBtYXR1cmUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dpbiAtIExvZ2luIG9mIHRoZSBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZS9Qcm92aWRlciBvZiB0aGUgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2lkXSAtIElEIG9mIHRoZSBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5TZXJpYWxpemVkTGl2ZVN0YXRlfSBbc3RhdGVdIC0gTGl2ZSBzdGF0ZVxuICAgICAqICAgICAgICBvZiB0aGUgY2hhbm5lbC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2dpbiwgdHlwZSwgaWQsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGxvZ2luLCB0eXBlLCBpZCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIFVSTHMgdGhhdCB3aWxsIGNvbnRhaW4gYSBwbGF5ZXIgb2YgdGhlIHN0cmVhbS4gVGhlIGZpcnN0IG9uZSBpc1xuICAgICAgICAgKiB0cmVhdGVkIGFzIHRoZSBtYWluIGNoYW5uZWwgcGFnZSBhbmQgb3BlbmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZVxuICAgICAgICAgKiBzdHJlYW0uXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsID0gW107XG5cbiAgICAgICAgdGhpcy5sYXN0TW9kaWZpZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZihzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5saXZlID0gTGl2ZVN0YXRlLmRlc2VyaWFsaXplKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBnZXQgbGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpdmU7XG4gICAgfVxuICAgIHNldCBsaXZlKHZhbCkge1xuICAgICAgICBpZih2YWwgaW5zdGFuY2VvZiBMaXZlU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpdmUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHJ5aW5nIHRvIHNldCB0aGUgbGl2ZSBzdGF0ZSB0byBzb21ldGhpbmcgdGhhdCBpc24ndCBhIExpdmVTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIHZlcnNpb24gb2Yge0BsaW5rIG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0uXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7bW9kdWxlOmNoYW5uZWwvY29yZX5TZXJpYWxpemVkSXRlbX0gU2VyaWFsaXplZENoYW5uZWxcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdmlld2Vyc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aHVtYm5haWxcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSB1cmxcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXJjaGl2ZVVybFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjaGF0VXJsXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RNb2RpZmllZFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYXRlZ29yeVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnRlbnRcbiAgICAgKiBAcHJvZXBydHkge2Jvb2xlYW59IG1hdHVyZVxuICAgICAqIEBwcm9wZXJ0eSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5TZXJpYWxpemVkTGl2ZVN0YXRlfSBsaXZlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBpdGVtIGludG8gYSBub3JtYWwgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmV+U2VyaWFsaXplZENoYW5uZWx9IEEgSlNPTiBzZXJpYWxpemFibGVcbiAgICAgKiAgICAgICAgICB2ZXJzaW9uIG9mIHRoaXMgY2hhbm5lbC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN1cGVyLnNlcmlhbGl6ZSgpLCB7XG4gICAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgICAgICAgIHZpZXdlcnM6IHRoaXMudmlld2VycyxcbiAgICAgICAgICAgIHRodW1ibmFpbDogdGhpcy50aHVtYm5haWwsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgYXJjaGl2ZVVybDogdGhpcy5hcmNoaXZlVXJsLFxuICAgICAgICAgICAgY2hhdFVybDogdGhpcy5jaGF0VXJsLFxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiB0aGlzLmxhc3RNb2RpZmllZCxcbiAgICAgICAgICAgIGNhdGVnb3J5OiB0aGlzLmNhdGVnb3J5LFxuICAgICAgICAgICAgbWF0dXJlOiB0aGlzLm1hdHVyZSxcbiAgICAgICAgICAgIGxpdmU6IHRoaXMubGl2ZS5zZXJpYWxpemUoKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENoYW5uZWwsIFVzZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvY29yZS5qcyIsImltcG9ydCBTREsgZnJvbSAnLi9zZGsnO1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJ2V2ZW50LXRhcmdldC1zaGltJztcblxuLy9UT0RPIG1vdmUgdG8gc3RvcmFnZS5sb2NhbCAmIG9wdGlvbnNfdWlcblxuY2xhc3MgUHJlZmVyZW5jZXMgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIFNESy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoeyBkZXRhaWw6IG1lc3NhZ2UgfSkgPT4ge1xuICAgICAgICAgICAgaWYobWVzc2FnZS50YXJnZXQgPT0gXCJwcmVmLWNoYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImNoYW5nZVwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0KHByZWYpIHtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShwcmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByZWYubWFwKChwKSA9PiB0aGlzLmdldChwKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFNESy5kb0FjdGlvbih7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcImdldC1wcmVmLVwiICsgcHJlZixcbiAgICAgICAgICAgICAgICBwcmVmXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldChwcmVmLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU0RLLmRvQWN0aW9uKHtcbiAgICAgICAgICAgIHRhcmdldDogXCJzZXQtcHJlZi1cIiArIHByZWYsXG4gICAgICAgICAgICBwcmVmLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3BlbigpIHtcbiAgICAgICAgU0RLLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHRhcmdldDogXCJwcmVmLW9wZW5cIlxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQcmVmZXJlbmNlcygpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcHJlZmVyZW5jZXMuanMiLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBBIGdlbmVyaWMgcHJvdmlkZXIgY2xhc3NcbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIHByb3ZpZGVycy9nZW5lcmljLXByb3ZpZGVyXG4gKiBAcmVxdWlyZXMgbW9kdWxlOnF1ZXVlL3NlcnZpY2VcbiAqL1xuaW1wb3J0IHByZWZzIGZyb20gXCIuLi9wcmVmZXJlbmNlc1wiO1xuaW1wb3J0IFBhcmVudGFsQ29udHJvbHMgZnJvbSBcIi4uL3BhcmVudGFsLWNvbnRyb2xzXCI7XG5pbXBvcnQgKiBhcyBxcyBmcm9tIFwiLi4vcXVldWUvc2VydmljZVwiO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJ2V2ZW50LXRhcmdldC1zaGltJztcblxuY29uc3QgXyA9IGJyb3dzZXIuaTE4bi5nZXRNZXNzYWdlLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZCA9ICh0eXBlLCBtZXRob2QpID0+IFByb21pc2UucmVqZWN0KHR5cGUgKyBcIi5cIiArIG1ldGhvZCArIFwiIGlzIG5vdCBzdXBwb3J0ZWRcIiksXG4gICAgcXVldWVzID0gbmV3IFdlYWtNYXAoKSxcbiAgICBxdWV1ZUZvciA9IChwcm92aWRlcikgPT4gcXVldWVzLmdldChwcm92aWRlcik7XG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjdXBkYXRlZHVzZXJcbiAqIEB0eXBlIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9XG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjbmV3Y2hhbm5lbHNcbiAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn1cbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnByb3ZpZGVycy9nZW5lcmljLXByb3ZpZGVyLkdlbmVyaWNQcm92aWRlciN1cGRhdGVkY2hhbm5lbHNcbiAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPnxtb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9XG4gKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyBleHRlcm5hbDpFcnJvclxuICovXG5jbGFzcyBQcm92aWRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMTogbWVzc2FnZSA9IFwiVGhlIEFQSSBkaWQgbm90IGFjY2VwdCB0aGUgZ2l2ZW4gcmVxdWVzdCBmb3JtYXRcIjsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbWVzc2FnZSA9IFwiQ291bGQgbm90IGFjY2VzcyB0aGUgcmVxdWVzdGVkIHJlc291cmNlXCI7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IG1lc3NhZ2UgPSBcIkNvdWxkIG5vdCBmaW5kIGFueSByZXN1bHQgZm9yIHRoZSBnaXZlbiB1c2VybmFtZVwiOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogbWVzc2FnZSA9IFwiQ291bGQgbm90IGxvYWQgdGhlIHJlcXVlc3RlZCByZXNvdXJjZVwiOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQcm92aWRlckVycm9yXCI7XG4gICAgfVxufVxuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgbW9kdWxlOmRpc3Bvc2FibGUtdGFyZ2V0LkRpc3Bvc2FibGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VuZXJpY1Byb3ZpZGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIHN0YXRpYyBnZXQgTkVUV09SS19FUlJPUigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckVycm9yKDApO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEFQSV9FUlJPUigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckVycm9yKDEpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEFDQ0VTU19FUlJPUigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckVycm9yKDIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5PUkVTVUxUX0VSUk9SKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyRXJyb3IoMyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFcnJvckJ5SFRUUENvZGUoY29kZSkge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgIGNhc2UgNDE1OlxuICAgICAgICBjYXNlIDQyMjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk5PUkVTVUxUX0VSUk9SO1xuICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgIGNhc2UgNTExOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQUNDRVNTX0VSUk9SO1xuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgY2FzZSA1MDE6XG4gICAgICAgIGNhc2UgNTAyOlxuICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgY2FzZSA1MDY6XG4gICAgICAgIGNhc2UgNTA3OlxuICAgICAgICBjYXNlIDUwODpcbiAgICAgICAgY2FzZSA1MTA6XG4gICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQVBJX0VSUk9SO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTkVUV09SS19FUlJPUjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHByb3BlcnR5IGlmIHRoZSBwcm92aWRlciBjYW4gZ2V0IHRoZSBmYXZvcml0ZXMgb2YgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgX3N1cHBvcnRzRmF2b3JpdGVzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgcHJvcGVydHkgc3BlY2lmeWluZywgaWYgdGhlIHByb3ZpZGVyIGNhbiBnZXQgdGhlIGZhdm9yaXRlc1xuICAgICAqIG9mIGEgdXNlciBiYXNlZCBvbiBzdG9yZWQgY3JlZGVudGlhbHMuIFRoZSBjcmVkZW50aWFscyBjaGVja2VkIGFyZVxuICAgICAqIGZvciB0aGUgVVJMcyBpbiB0aGUgYXJyYXkgdGhlXG4gICAgICoge0BsaW5rIG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjYXV0aFVSTH1cbiAgICAgKiBwcm9wZXJ0eSBzcGVjaWZpZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBfc3VwcG9ydHNDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIHByb3BlcnR5IHNwZWNpZnlpbmcsIGlmIHRoZSBwcm92aWRlciBjYW4gZ2V0IGEgZmVhdHVyZWRcbiAgICAgKiBjaGFubmVsIG9uIHRoZSBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIF9zdXBwb3J0c0ZlYXR1cmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIF9lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFVSTHMgdG8gc2VhcmNoIGNyZWRlbnRpYWxzIGZvci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXV0aFVSTCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBiYXNlLWNsYXNzIGZvciBhbGwgcHJvdmlkZXJzLiBJbXBsZW1lbnRzIGNvbW1vbiBwYXR0ZXJucyBhbmQgaGVscGVycy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBQcm92aWRlciB0eXBlIGRlc2NyaXB0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgc3BlY2lmaWVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgICAgICAgcXVldWVzLnNldCh0aGlzLCBxcy5nZXRTZXJ2aWNlRm9yUHJvdmlkZXIodGhpcy5fdHlwZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgUXVldWVTZXJ2aWNlIGZvciB0aGlzIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHR5cGUge3F1ZXVlc2VydmljZS5RdWV1ZVNlcnZpY2V9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBfcXMoKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZUZvcih0aGlzKTtcbiAgICB9XG4gICAgLy8gRm9yIHRlc3RpbmcuXG4gICAgX3NldFFzKHZhbCkge1xuICAgICAgICBxdWV1ZXMuc2V0KHRoaXMsIHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBleHBsb3JpbmcgZmVhdHVyZXMgc2hvdWxkIGhvbGQgbWF0dXJlIHJlc3VsdHMuIFJlc3BlY3RzXG4gICAgICogcGFyZW50YWwgY29udHJvbCBzZXR0aW5ncyBvZiB0aGUgT1MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gRXhwbG9yZSBmZWF0dXJlcyBzaG91bGQgaG9sZCBtYXR1cmUgcmVzdWx0cyBpZiB0cnVlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBfbWF0dXJlKCkge1xuICAgICAgICByZXR1cm4gcHJlZnMuZ2V0KFwiZmluZF9tYXR1cmVcIikudGhlbigodmFsdWUpID0+IHZhbHVlICYmICFQYXJlbnRhbENvbnRyb2xzLmVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcHJvdmlkZXIgaXMgZnVsbHkgZnVuY3Rpb25hbCBhbmQgc2hvdWxkIGJlIGVuYWJsZWQuIE1ha2VzIGl0XG4gICAgICogaW1wb3NzaWJsZSB0byBhZGQgbmV3IGNoYW5uZWxzIGFuZCB1c2VycyBhbmQgZGlzYWJsZXMgdGhlIHVwZGF0ZVxuICAgICAqIHJlcXVlc3QgcXVldWVpbmcuIEV4aXN0aW5nIGNoYW5uZWxzIHdpbGwgYmUga2VwdCBhcm91bmQsIGFuZCBjb3VsZFxuICAgICAqIHN0aWxsIGJlIHVwZGF0ZWQuIGdldENoYW5uZWxEZXRhaWxzIGlzIGFsc28gZXhwZWN0ZWQgdG8gcmV0dXJuIGFcbiAgICAgKiBjaGFubmVsIHRoYXQgYXQgbGVhc3Qgc2V0cyB0aGUgbG9naW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBodW1hbiByZWFkYWJsZSBuYW1lIG9mIHRoaXMgcHJvdmlkZXIsIGJ5IGRlZmF1bHQgbG9va3MgZm9yIGFcbiAgICAgKiB0cmFuc2xhdGVkIHN0cmluZyB3aXRoIHRoZSBpZCBcInByb3ZpZGVyX3R5cGVcIiB3aGVyZSB0eXBlIGlzIHRoZSB2YWx1ZSBvZlxuICAgICAqIF90eXBlLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIF8oXCJwcm92aWRlclwiICsgdGhpcy5fdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IExvY2FsaXplZCBuYW1lIG9mIHRoZSBwcm92aWRlci5cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6cHJvdmlkZXJzL2dlbmVyaWMtcHJvdmlkZXIuR2VuZXJpY1Byb3ZpZGVyI25hbWV9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZyb3plblxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvdmlkZXJTdXBwb3J0c1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmF2b3JpdGVzIC0gUHJvdmlkZXIgc3VwcG9ydHMgZ2V0dGluZyBhIHVzZXIncyBmYXZvcml0ZXNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNyZWRlbnRpYWxzIC0gUHJvdmlkZXIgc3VwcG9ydHMgY3JlZGVudGlhbCBiYXNlZCBhdXRvLWRldGVjdCBvZiB1c2Vyc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmVhdHVyZWQgLSBQcm92aWRlciBzdXBwb3J0cyBnZXR0aW5nIGZlYXR1cmVkIGNoYW5uZWxzIGFuZCBzZWFyY2hcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgYmFzZWQgb24gdGhlIF9zdXBwb3J0cyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHR5cGUge21vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlcn5Qcm92aWRlclN1cHBvcnRzfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBzdXBwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgZmF2b3JpdGVzOiB0aGlzLl9zdXBwb3J0c0Zhdm9yaXRlcyAmJiB0aGlzLl9lbmFibGVkLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuX3N1cHBvcnRzQ3JlZGVudGlhbHMgJiYgdGhpcy5fZW5hYmxlZCxcbiAgICAgICAgICAgIGZlYXR1cmVkOiB0aGlzLl9zdXBwb3J0c0ZlYXR1cmVkICYmIHRoaXMuX2VuYWJsZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmF2b3JpdGUgY2hhbm5lbHMgb2YgYSB1c2VyLiBBbHNvIGNhbGxlZCB0aGUgZm9sbG93ZWQgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgLSBUaGUgdXNlcm5hbWUgb2YgdGhlIHVzZXIgb24gdGhlIHBsYXRmb3JtXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzIGVudGVyZWQgYnkgdGhlIHVzZXIgaW4gdGhlIGNoYW5uZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlcikuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSB3aXRoIHRvIGVsZW1lbnRzIGluXG4gICAgICogICAgICAgICAgdGhpcyBvcmRlcjpcbiAgICAgKiAgICAgICAgICAgIC0gdGhlIHVzZXIgKGFuIGluc3RhbmNlIG9mIGEgVXNlciBvYmplY3QpLlxuICAgICAqICAgICAgICAgICAgLSB0aGUgZmF2b3JpdGUgY2hhbm5lbHMsIGFuIGFycmF5IG9mIENoYW5uZWxzIG9iamVjdHMuXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgZ2V0VXNlckZhdm9yaXRlcyh1c2VybmFtZSkge1xuICAgICAgICByZXR1cm4gbWV0aG9kTm90U3VwcG9ydGVkKHRoaXMubmFtZSwgXCJnZXRVc2VyRmF2b3JpdGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBDaGFubmVsIG9iamVjdCB3aXRob3V0IHRoZSByZXF1aXJlbWVudCBvZiBhbnkgbGl2ZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBhc3luY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsbmFtZSAtIFRoZSB1c2VybmFtZSBvZiB0aGUgY2hhbm5lbCB0byByZXR1cm5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAoYXMgZW50ZXJlZCBieSB0aGUgdXNlciBpbiB0aGUgY2hhbm5lbHMgbWFuYWdlcikuXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gQ2hhbm5lbCBvYmplY3Qgd2l0aCBhdCBsZWFzdFxuICAgICAqICAgICAgICAgIHVzZXJuYW1lLCB0eXBlLCBpbWFnZSBhbmQgdXJscyBzZXQuXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbERldGFpbHMoY2hhbm5lbG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZE5vdFN1cHBvcnRlZCh0aGlzLm5hbWUsIFwiZ2V0Q2hhbm5lbERldGFpbHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyBhIHJlb2N1cnJpbmcgdXBkYXRlIHJlcXVlc3QgZm9yIHVwZGF0aW5nIHRoZSBmYXZvcml0ZSBjaGFubmVsc1xuICAgICAqIG9mIHRoZSB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcj59IHVzZXJzIC0gVXNlcnMgdG8gdXBkYXRlIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmF2b3JpdGVzIG9mLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6cHJvdmlkZXJzL2dlbmVyaWMtcHJvdmlkZXIuR2VuZXJpY1Byb3ZpZGVyI3VwZGF0ZWR1c2VyXG4gICAgICogQGZpcmVzIG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjbmV3Y2hhbm5lbHNcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHVwZGF0ZUZhdnNSZXF1ZXN0KHVzZXJzKSB7XG4gICAgICAgIHRocm93IHRoaXMubmFtZSArIFwiLnVwZGF0ZUZhdnNSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWQuXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucXVldWVzIHRoZSByZW9jdXJyaW5nIHVwZGF0ZSByZXF1ZXN0IGZvciB1cGRhdGluZyB0aGUgZmF2b3JpdGVcbiAgICAgKiBjaGFubmVscyBvZiB0aGUgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHJlbW92ZUZhdnNSZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLl9xcy51bnF1ZXVlVXBkYXRlUmVxdWVzdCh0aGlzLl9xcy5MT1dfUFJJT1JJVFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgYSByZW9jdXJyaW5nIHVwZGF0ZSByZXF1ZXN0IGZvciB1cGRhdGluZyB0aGUgbGl2ZSBzdGF0dXMgb2YgYWxsXG4gICAgICogY2hhbm5lbHMgZm9yIHRoaXMgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWw+fSBjaGFubmVscyAtIFRoZSBDaGFubmVsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdHMgdG8gdXBkYXRlLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6cHJvdmlkZXJzL2dlbmVyaWMtcHJvdmlkZXIuR2VuZXJpY1Byb3ZpZGVyI3VwZGF0ZWRjaGFubmVsc1xuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgdXBkYXRlUmVxdWVzdChjaGFubmVscykge1xuICAgICAgICB0aHJvdyB0aGlzLm5hbWUgKyBcIi51cGRhdGVSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWQuXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucXVldWVzIHRoZSByZW9jdXJyaW5nIHVwZGF0ZSByZXF1ZXN0IGZvciB1cGRhdGluZyB0aGUgbGl2ZSBzdGF0dXMgb2ZcbiAgICAgKiBhbGwgY2hhbm5lbHMgZm9yIHRoaXMgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHJlbW92ZVJlcXVlc3QoKSB7XG4gICAgICAgIHRoaXMuX3FzLnVucXVldWVVcGRhdGVSZXF1ZXN0KHRoaXMuX3FzLkhJR0hfUFJJT1JJVFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFsbCBpbmZvIGZvciBhIGNoYW5uZWwsIGluY2x1ZGluZyBpdHMgbGl2ZSBtZXRhZGF0YS4gQnkgZGVmYXVsdFxuICAgICAqIGp1c3QgY2FsbHMge0BsaW5rIG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjZ2V0Q2hhbm5lbERldGFpbHN9LlxuICAgICAqXG4gICAgICogQGFzeW5jXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxuYW1lIC0gVGhlIGxvZ2luIG9mIHRoZSBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IFVwZGF0ZWQgQ2hhbm5lbCBvYmplY3QuXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbChjaGFubmVsbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGFubmVsRGV0YWlscyhjaGFubmVsbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGluZm9ybWF0aW9uIGZvciBhbiBhcnJheSBvZiBDaGFubmVsIG9iamVjdHMsIGluY2x1ZGluZ1xuICAgICAqIHRoZWlyIGxpdmUgbWV0YWRhdGEuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNhbGxzXG4gICAgICoge0BsaW5rIG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjdXBkYXRlQ2hhbm5lbH1cbiAgICAgKiBmb3IgZWFjaCBpdGVtLlxuICAgICAqXG4gICAgICogQGFzeW5jXG4gICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gY2hhbm5lbHMgLSBBbiBhcnJheSBvZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gVXBkYXRlZCBDaGFubmVsIG9iamVjdHMuXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gdGhpcy51cGRhdGVDaGFubmVsKGNoYW5uZWwubG9naW4pKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2hhbm5lbHMgdGhlIHByb3ZpZGVyIGlzIGZlYXR1cmluZy4gUmVzdWx0cyBzaG91bGQgYmVcbiAgICAgKiBmaWx0ZXJlZCBpZiBfbWF0dXJlIGlzIGZhbHNlLiBCeSBkZWZhdWx0IGNhbGxzXG4gICAgICoge0BsaW5rIG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjc2VhcmNofSB3aXRoXG4gICAgICogYW4gZW1wdHkgc3RyaW5nIGFzIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGFzeW5jXG4gICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWw+fSBBbiBhcnJheSBvZiBmZWF0dXJlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHMuXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmxpYi9wcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjX21hdHVyZX1cbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlZENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2goXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgbGl2ZSBjaGFubmVscy4gUmVzdWx0cyBzaG91bGQgYmUgZmlsdGVyZWQgaWYgX21hdHVyZSBpc1xuICAgICAqIGZhbHNlLlxuICAgICAqXG4gICAgICogQGFzeW5jXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gQSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59IEFuIGFycmF5IG9mIGNoYW5uZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZyB0aGUgcXVlcnkuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmxpYi9wcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXIjX21hdHVyZX1cbiAgICAgKi9cbiAgICBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZE5vdFN1cHBvcnRlZCh0aGlzLm5hbWUsIFwic2VhcmNoXCIpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9nZW5lcmljLXByb3ZpZGVyLmpzIiwiLyoqXG4gKiBAYXV0aG9yIFRvcnUgTmFnYXNoaW1hXG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTZWUgTElDRU5TRSBmaWxlIGluIHJvb3QgZGlyZWN0b3J5IGZvciBmdWxsIGxpY2Vuc2UuXG4gKi9cblwidXNlIHN0cmljdFwiXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qZ2xvYmFscyB3aW5kb3cgKi9cblxudmFyIENvbW1vbnMgPSByZXF1aXJlKFwiLi9jb21tb25zXCIpXG52YXIgQ3VzdG9tRXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9jdXN0b20tZXZlbnQtdGFyZ2V0XCIpXG52YXIgRXZlbnRXcmFwcGVyID0gcmVxdWlyZShcIi4vZXZlbnQtd3JhcHBlclwiKVxudmFyIGlzT2JqZWN0ID0gQ29tbW9ucy5pc09iamVjdFxudmFyIExJU1RFTkVSUyA9IENvbW1vbnMuTElTVEVORVJTXG52YXIgQ0FQVFVSRSA9IENvbW1vbnMuQ0FQVFVSRVxudmFyIEJVQkJMRSA9IENvbW1vbnMuQlVCQkxFXG52YXIgQVRUUklCVVRFID0gQ29tbW9ucy5BVFRSSUJVVEVcbnZhciBuZXdOb2RlID0gQ29tbW9ucy5uZXdOb2RlXG52YXIgZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQgPSBDdXN0b21FdmVudFRhcmdldC5kZWZpbmVDdXN0b21FdmVudFRhcmdldFxudmFyIGNyZWF0ZUV2ZW50V3JhcHBlciA9IEV2ZW50V3JhcHBlci5jcmVhdGVFdmVudFdyYXBwZXJcbnZhciBTVE9QX0lNTUVESUFURV9QUk9QQUdBVElPTl9GTEFHID0gRXZlbnRXcmFwcGVyLlNUT1BfSU1NRURJQVRFX1BST1BBR0FUSU9OX0ZMQUdcbnZhciBQQVNTSVZFX0xJU1RFTkVSX0ZMQUcgPSBFdmVudFdyYXBwZXIuUEFTU0lWRV9MSVNURU5FUl9GTEFHXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb25zdGFudHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQSBmbGFnIHdoaWNoIHNob3dzIHRoZXJlIGlzIHRoZSBuYXRpdmUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2Ugb2JqZWN0LlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xudmFyIEhBU19FVkVOVFRBUkdFVF9JTlRFUkZBQ0UgPSAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiB3aW5kb3cuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCJcbilcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpYyBJbnRlcmZhY2Vcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gZm9yIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRUYXJnZXQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgLy8gdGhpc1tMSVNURU5FUlNdIGlzIGEgTWFwLlxuICAgICAgICAvLyBJdHMga2V5IGlzIGV2ZW50IHR5cGUuXG4gICAgICAgIC8vIEl0cyB2YWx1ZSBpcyBMaXN0ZW5lck5vZGUgb2JqZWN0IG9yIG51bGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGludGVyZmFjZSBMaXN0ZW5lck5vZGUge1xuICAgICAgICAvLyAgICAgdmFyIGxpc3RlbmVyOiBGdW5jdGlvblxuICAgICAgICAvLyAgICAgdmFyIGtpbmQ6IENBUFRVUkV8QlVCQkxFfEFUVFJJQlVURVxuICAgICAgICAvLyAgICAgdmFyIG5leHQ6IExpc3RlbmVyTm9kZXxudWxsXG4gICAgICAgIC8vIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIExJU1RFTkVSUywge3ZhbHVlOiBPYmplY3QuY3JlYXRlKG51bGwpfSlcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KEV2ZW50VGFyZ2V0LCBhcmd1bWVudHNbMF0pXG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0eXBlcyA9IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gdXNlIHRvIGV4dGVuZCB3aXRoIGF0dHJpYnV0ZSBsaXN0ZW5lciBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBlLmcuXG4gICAgICAgIC8vICAgICBjbGFzcyBNeUN1c3RvbU9iamVjdCBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHtcbiAgICAgICAgLy8gICAgICAgICAvLy4uLlxuICAgICAgICAvLyAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoRXZlbnRUYXJnZXQsIHR5cGVzKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIH1cbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcbiAgICAoSEFTX0VWRU5UVEFSR0VUX0lOVEVSRkFDRSA/IHdpbmRvdy5FdmVudFRhcmdldCA6IE9iamVjdCkucHJvdG90eXBlLFxuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBFdmVudFRhcmdldCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgbGlzdGVuZXIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJsaXN0ZW5lclxcXCIgaXMgbm90IGFuIG9iamVjdC5cIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGlzT2JqZWN0KG9wdGlvbnMpID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpIDogQm9vbGVhbihvcHRpb25zKVxuICAgICAgICAgICAgICAgIHZhciBraW5kID0gKGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFKVxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpc1tMSVNURU5FUlNdW3R5cGVdXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0xJU1RFTkVSU11bdHlwZV0gPSBuZXdOb2RlKGxpc3RlbmVyLCBraW5kLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gbnVsbFxuICAgICAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIG5vZGUua2luZCA9PT0ga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGlnbm9yZSBhIGR1cGxpY2F0ZWQgbGlzdGVuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZShsaXN0ZW5lciwga2luZCwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKSA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSA6IEJvb2xlYW4ob3B0aW9ucylcbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IChjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRSlcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IG51bGxcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXNbTElTVEVORVJTXVt0eXBlXVxuICAgICAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIG5vZGUua2luZCA9PT0ga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTElTVEVORVJTXVt0eXBlXSA9IG5vZGUubmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3BhdGNoRXZlbnQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBldmVudC50eXBlXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzW0xJU1RFTkVSU11bdHlwZV1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgY2Fubm90IHJld3JpdGUgc2V2ZXJhbCBwcm9wZXJ0aWVzLCBzbyB3cmFwIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IGNyZWF0ZUV2ZW50V3JhcHBlcihldmVudCwgdGhpcylcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpc24ndCBwYXJ0aWNpcGF0aW5nIGluIGEgdHJlZS5cbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IG51bGxcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGl0J3Mgb25jZVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tMSVNURU5FUlNdW3R5cGVdID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZFtQQVNTSVZFX0xJU1RFTkVSX0ZMQUddID0gbm9kZS5wYXNzaXZlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5saXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmNhbGwodGhpcywgd3JhcHBlZClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmtpbmQgIT09IEFUVFJJQlVURSAmJiB0eXBlb2Ygbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50KHdyYXBwZWQpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlZFtTVE9QX0lNTUVESUFURV9QUk9QQUdBVElPTl9GTEFHXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gIXdyYXBwZWQuZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH1cbilcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ldmVudC10YXJnZXQtc2hpbS9saWIvZXZlbnQtdGFyZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUmVwcmVzZW50cyBpbmZvcm1hdGlvbiBmb3Igbm9uLWxpdmUgc3RyZWFtcy5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBjaGFubmVsL2xpdmUtc3RhdGVcbiAqIEB0b2RvIFJlcGxhY2UgYWx0ZXJuYXRlIHByb3BlcnRpZXMgd2l0aCBhIHNlcmlhbGl6ZWQgY2hhbm5lbCAodG8gYXZvaWQgcmVxdWlyZSBsb29wcylcbiAqL1xuaW1wb3J0IHsgb21pdCB9IGZyb20gXCJ1bmRlcnNjb3JlXCI7XG5pbXBvcnQgcHJlZnMgZnJvbSBcIi4uL3ByZWZlcmVuY2VzXCI7XG5pbXBvcnQgTGl2ZVN0YXRlQ29uc3QgZnJvbSAnLi4vLi4vbGl2ZS1zdGF0ZSc7XG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcn0gTGl2ZVN0YXRlSW5kaWNhdG9yXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VyaWFsaXplZExpdmVTdGF0ZVxuICogQHByb3BlcnR5IHttb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlfkxpdmVTdGF0ZUluZGljYXRvcn0gc3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhbHRlcm5hdGVVc2VybmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFsdGVybmF0ZVVSTFxuICogQHNlZSB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGV9XG4gKi9cbi8qKlxuICogQ29uc3RhbnQgZm9yIGhvdyB0aGUgbGl2ZSBzdGF0ZSBpcyB0byBiZSBpbnRlcnByZXRlZCBpbiBhIGJvb2xlYW4gc2NlbmFyaW8uXG4gKlxuICogQHR5cGVkZWYge251bWJlcn0gTGl2ZVN0YXRlSW50ZXJwcmV0YXRpb25cbiAqL1xuXG5jb25zdCBJR05PUkVEX1BST1BFUlRJRVMgPSBbIFwic3RhdGVcIiwgXCJpc0xpdmVcIiBdLFxuICAgIE9GRkxJTkUgPSBMaXZlU3RhdGVDb25zdC5PRkZMSU5FLFxuICAgIExJVkUgPSBMaXZlU3RhdGVDb25zdC5MSVZFLFxuICAgIFJFRElSRUNUID0gTGl2ZVN0YXRlQ29uc3QuUkVESVJFQ1QsXG4gICAgUkVCUk9BRENBU1QgPSBMaXZlU3RhdGVDb25zdC5SRUJST0FEQ0FTVCxcbiAgICBUT1dBUkRfTElWRSA9IExpdmVTdGF0ZUNvbnN0LlRPV0FSRF9MSVZFLFxuICAgIFRPV0FSRF9PRkZMSU5FID0gTGl2ZVN0YXRlQ29uc3QuVE9XQVJEX09GRkxJTkUsXG4gICAgZ2V0RGVmYXVsdEludGVycHJldGF0aW9uID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZnMuZ2V0KFwicGFuZWxfbm9ubGl2ZVwiKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCkgPCAzID8gVE9XQVJEX0xJVkUgOiBUT1dBUkRfT0ZGTElORTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuLyoqXG4gKiBVc2VkIHRvIGRlc2NyaWJlIHRoZSBleGFjdCBzdGF0ZSBvZiBhIHN0cmVhbS4gU29tZXRpbWVzIHN0cmVhbXMgYXJlIG1hcmtlZFxuICogYXMgcmVicm9hZGNhc3RzIG9yIGFyZSBhIHJlLXN0cmVhbSBmcm9tIGEgZGlmZmVyZW50IHNvdXJjZS5cbiAqXG4gKiBAY2xhc3MgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGVcbiAqL1xuY2xhc3MgTGl2ZVN0YXRlIHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgY2hhbm5lbCBpcyBvZmZsaW5lLlxuICAgICAqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge21vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGV+TGl2ZVN0YXRlSW5kaWNhdG9yfVxuICAgICAqIEBhbGlhcyBtb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlLkxpdmVTdGF0ZS5PRkZMSU5FXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlLlJFRElSRUNUfSwge0BsaW5rIG1vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlLlJFQlJPQURDQVNUfSwge0BsaW5rIG1vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlLkxJVkV9XG4gICAgICovXG4gICAgc3RhdGljIE9GRkxJTkUgPSBPRkZMSU5FO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBjaGFubmVsIGlzIGxpdmUuXG4gICAgICpcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5MaXZlU3RhdGVJbmRpY2F0b3J9XG4gICAgICogQGFsaWFzIG1vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlLkxJVkVcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuUkVESVJFQ1R9LCB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuUkVCUk9BRENBU1R9LCB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuT0ZGTElORX1cbiAgICAgKi9cbiAgICBzdGF0aWMgTElWRSA9IExJVkU7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBjaGFubmVsIGlzIGhvc3RpbmcgYW5vdGhlciBjaGFubmVsIG9yIHNpbWlsYXIuXG4gICAgICpcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5MaXZlU3RhdGVJbmRpY2F0b3J9XG4gICAgICogQGFsaWFzIG1vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlLlJFRElSRUNUXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGUuTGl2ZVN0YXRlLkxJVkV9LCB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuUkVCUk9BRENBU1R9LCB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuT0ZGTElORX1cbiAgICAgKi9cbiAgICBzdGF0aWMgUkVESVJFQ1QgPSBSRURJUkVDVDtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbm5lbCBpcyByZWJyb2FkY2FzdGluZyBhIHByZXZpb3VzIGJyb2FkY2FzdC5cbiAgICAgKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHttb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlfkxpdmVTdGF0ZUluZGljYXRvcn1cbiAgICAgKiBAYWxpYXMgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuUkVCUk9BRENBU1RcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuTElWRX0sIHtAbGluayBtb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlLkxpdmVTdGF0ZS5SRURJUkVDVH0sIHtAbGluayBtb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlLkxpdmVTdGF0ZS5PRkZMSU5FfVxuICAgICAqL1xuICAgIHN0YXRpYyBSRUJST0FEQ0FTVCA9IFJFQlJPQURDQVNUO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJwcmV0cyBldmVyeXRoaW5nIGJ1dCBvZmZsaW5lIGFzIGxpdmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5MaXZlU3RhdGVJbnRlcnByZXRhdGlvbn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgc3RhdGljIFRPV0FSRF9MSVZFID0gVE9XQVJEX0xJVkU7XG4gICAgLyoqXG4gICAgICogSW50ZXJwcmV0cyBldmVyeXRoaW5nIGJ1dCBsaXZlIGFzIG9mZmxpbmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5MaXZlU3RhdGVJbnRlcnByZXRhdGlvbn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgc3RhdGljIFRPV0FSRF9PRkZMSU5FID0gVE9XQVJEX09GRkxJTkU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGV+U2VyaWFsaXplZExpdmVTdGF0ZX0gc2VyaWFsaXplZExpdmVTdGF0ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIC0gTGl2ZVN0YXRlIHJlcHJlc2VudGVkIGFzIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGV9IExpdmVTdGF0ZSBkZXJyaXZlZCBmcm9tXG4gICAgICogICAgICAgICAgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZExpdmVTdGF0ZSkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IG9taXQoc2VyaWFsaXplZExpdmVTdGF0ZSwgSUdOT1JFRF9QUk9QRVJUSUVTKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IExpdmVTdGF0ZShzZXJpYWxpemVkTGl2ZVN0YXRlLnN0YXRlKSwgcHJvcHMpO1xuICAgIH1cblxuXG4gICAgYWx0ZXJuYXRlVXNlcm5hbWUgPSBcIlwiO1xuICAgIGFsdGVybmF0ZVVSTCA9IFwiXCI7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0c1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZX5MaXZlU3RhdGVJbmRpY2F0b3J9IFtzdGF0ZT17QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGl2ZS1zdGF0ZS5MaXZlU3RhdGUuT0ZGTElORX1dXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gSW5pdGlhbCBzdGF0ZSwgZGVmYXVsdGluZyB0byBvZmZsaW5lLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlID0gT0ZGTElORSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdGUgZGVzY3JpcHRvciBvZiB0aGlzIExpdmVTdGF0ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHttb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlfkxpdmVTdGF0ZUluZGljYXRvcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaW50ZXJwcmV0YXRpb24gbW9kZSBiYXNlZCBvbiBhIHVzZXIncyBwcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHR5cGUge21vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGV+TGl2ZVN0YXRlSW50ZXJwcmV0YXRpb259XG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRJbnRlcnByZXRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldERlZmF1bHRJbnRlcnByZXRhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIExpdmVTdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9saXZlLXN0YXRlflNlcmlhbGl6ZWRMaXZlU3RhdGV9IEpTT05cbiAgICAgKiAgICAgICAgICBzZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsaXZlIHN0YXRlLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgYWx0ZXJuYXRlVXNlcm5hbWU6IHRoaXMuYWx0ZXJuYXRlVXNlcm5hbWUsXG4gICAgICAgICAgICBhbHRlcm5hdGVVUkw6IHRoaXMuYWx0ZXJuYXRlVVJMXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgbGl2ZSBzdGF0ZSB0byBhIGJvb2xlYW4gZGVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpjaGFubmVsL2xpdmUtc3RhdGV+TGl2ZVN0YXRlSW50ZXJwcmV0YXRpb259IFtpbnRlcnByZXRhdGlvbl1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBIb3cgdG8gaW50ZXJwcmV0IGxpdmUgc3RhdGVzIGFzIGJvb2xlYW4uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGxpdmUgc3RhdGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgbGl2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBpc0xpdmUoaW50ZXJwcmV0YXRpb24pIHtcbiAgICAgICAgaWYoIWludGVycHJldGF0aW9uKSB7XG4gICAgICAgICAgICBpbnRlcnByZXRhdGlvbiA9IGF3YWl0IGdldERlZmF1bHRJbnRlcnByZXRhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaW50ZXJwcmV0YXRpb24gPT09IFRPV0FSRF9MSVZFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSAhPT0gT0ZGTElORTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGludGVycHJldGF0aW9uID09PSBUT1dBUkRfT0ZGTElORSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IExJVkU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdGF0ZSB0byBsaXZlIG9yIG5vdCBsaXZlLiBTaW1wbGUgYXMgY2FuIGJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsaXZlIC0gU2hvcnRjdXQgdG8gc2V0IHRoZSBvYmplY3QgdG8gc2ltcGxlIHN0YXRlcy5cbiAgICAgKi9cbiAgICBzZXRMaXZlKGxpdmUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBsaXZlID8gTElWRSA6IE9GRkxJTkU7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRlVXNlcm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmFsdGVybmF0ZVVSTCA9IFwiXCI7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXZlU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9jaGFubmVsL2xpdmUtc3RhdGUuanMiLCIvKipcbiAqIFBhZ2luYXRpb24gaGVscGVyIGZvciBBUElzIHdpdGggcGFnaW5hdGlvblxuICogQG1vZHVsZSBwYWdpbmF0aW9uLWhlbHBlclxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqL1xuXG4vKipcbiAqIEFuIFNESyByZXF1ZXN0IGZvciBleGVjdXRpbmcgSFRUUCByZXF1ZXN0LlxuICogQGV4dGVybmFsIHNkay9yZXF1ZXN0XG4gKiBAcmVxdWlyZXMgc2RrL3JlcXVlc3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvU0RLL0hpZ2gtTGV2ZWxfQVBJcy9yZXF1ZXN0fVxuICovXG4vKipcbiAqIEFkZC1vbiBTREsgUmVzcG9uc2Ugb2JqZWN0XG4gKiBAY2xhc3MgUmVzcG9uc2VcbiAqIEBtZW1iZXJvZiBleHRlcm5hbDpzZGsvcmVxdWVzdFxuICogQGlubmVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9BZGQtb25zL1NESy9IaWdoLUxldmVsX0FQSXMvcmVxdWVzdCNSZXNwb25zZX1cbiAqL1xuXG4vKipcbiAqIEEgaGVscGVyIG9iamVjdCBmb3Igd29ya2luZyB3aXRoIHBhZ2luYXRlZCBBUElzLiBJdCBmZXRjaGVzIGFsbCB0aGUgY29udGVudFxuICogYW5kIHRoZW4gcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGF0YS4gUnVucyBpbW1lZGlhdGVseSBhZnRlciBjb25zdHJ1Y3Rpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge21vZHVsZTpwYWdpbmF0aW9uLWhlbHBlcn5QYWdpbmF0aW9uSGVscGVyT3B0aW9uc30gb3B0aW9ucyAtIFBhZ2luYXRpb25cbiAqICAgICAgICBoZWxwZXIgY29uZmlndXJhdGlvbi5cbiAqIEBhbGlhcyBtb2R1bGU6cGFnaW5hdGlvbi1oZWxwZXIuUGFnaW5hdGlvbkhlbHBlclxuICovXG5mdW5jdGlvbiBQYWdpbmF0aW9uSGVscGVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgIHRoaXMucmVxdWVzdCA9IG9wdGlvbnMucmVxdWVzdDtcbiAgICB0aGlzLmZldGNoTmV4dFBhZ2UgPSBvcHRpb25zLmZldGNoTmV4dFBhZ2U7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlO1xuICAgIHRoaXMuZ2V0SXRlbXMgPSBvcHRpb25zLmdldEl0ZW1zO1xuXG4gICAgaWYoXCJwYWdlU2l6ZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IG9wdGlvbnMucGFnZVNpemU7XG4gICAgfVxuICAgIGlmKFwiZ2V0UGFnZU51bWJlclwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5nZXRQYWdlTnVtYmVyID0gb3B0aW9ucy5nZXRQYWdlTnVtYmVyO1xuICAgIH1cblxuICAgIGlmKFwiaW5pdGlhbFBhZ2VcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGFnZSA9IG9wdGlvbnMuaW5pdGlhbFBhZ2U7XG4gICAgfVxuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICB0aGlzLmdldFBhZ2UodHJ1ZSk7XG59XG5cblBhZ2luYXRpb25IZWxwZXIucHJvdG90eXBlLnVybCA9IFwibG9jYWxob3N0L1wiO1xuUGFnaW5hdGlvbkhlbHBlci5wcm90b3R5cGUucGFnZSA9IDA7XG5QYWdpbmF0aW9uSGVscGVyLnByb3RvdHlwZS5wYWdlU2l6ZSA9IDEwMDtcblBhZ2luYXRpb25IZWxwZXIucHJvdG90eXBlLnJlc3VsdCA9IFtdO1xuUGFnaW5hdGlvbkhlbHBlci5wcm90b3R5cGUucmVxdWVzdCA9IG51bGw7XG5QYWdpbmF0aW9uSGVscGVyLnByb3RvdHlwZS5mZXRjaE5leHRQYWdlID0gbnVsbDtcblBhZ2luYXRpb25IZWxwZXIucHJvdG90eXBlLm9uQ29tcGxldGUgPSBudWxsO1xuUGFnaW5hdGlvbkhlbHBlci5wcm90b3R5cGUuZ2V0SXRlbXMgPSBudWxsO1xuUGFnaW5hdGlvbkhlbHBlci5wcm90b3R5cGUuZ2V0UGFnZU51bWJlciA9IGZ1bmN0aW9uKHBhZ2UsIHBhZ2VTaXplKSB7XG4gICAgcmV0dXJuIHBhZ2UgKyBwYWdlU2l6ZTtcbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiBydW5uaW5nIGEgcmVxdWVzdCBvbiB0aGUgcHJvdmlkZWQgVVJMIGFuZCB0aGVuIGNhbGxpbmcgdGhlXG4gKiBjYWxsYmFjayBmdW5jdGlvbi4gQWx0ZXJuYXRpdmVseSByZXR1cm5lcyBhIHByb21pc2UuIE5vcm1hbGx5IGlzXG4gKiB7QGxpbmsgbW9kdWxlOnF1ZXVlc2VydmljZX5RdWV1ZVNlcnZpZS5xdWV1ZVJlcXVlc3R9LCB3aGljaCByZXR1cm5zIGFcbiAqIHtAbGluayBleHRlcm5hbDpzZGsvcmVxdWVzdH5SZXNwb25zZX0uXG4gKlxuICogQGNhbGxiYWNrIHJlcXVlc3RcbiAqIEBhcmd1bWVudCB7c3RyaW5nfSB1cmxcbiAqIEBhcmd1bWVudCB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXJndW1lbnQge2Jvb2xlYW59IGluaXRpYWwgLSBJbmRpY2F0aW5nIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgcmFuLlxuICogQHJldHVybiB7P1Byb21pc2V9IE9wdGlvbmFsbHkgcmV0dXJucyBhIHByb21pc2UgaW5zdGVhZCBvZiBjYWxsaW5nIHRoZVxuICogICAgICAgICBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuLyoqXG4gKiBBIGZ1bmN0aW9uIGRldGVybWluaW5nLCBpZiB0aGUgbmV4dCBwYWdlIHNob3VsZCBiZSBmZXRjaGVkLlxuICpcbiAqIEBjYWxsYmFjayBmZXRjaE5leHRQYWdlXG4gKiBAYXJndW1lbnQgez99IGRhdGEgLSBXaGF0ZXZlciB7QGxpbmsgbW9kdWxlOnBhZ2luYXRpb24taGVscGVyfnJlcXVlc3R9IHJldHVybmVkLlxuICogQGFyZ3VtZW50IHtudW1iZXJ9IHBhZ2VTaXplIC0gVGhlIGV4cGVjdGVkIHNpemUgb2YgYSBwYWdlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuLyoqXG4gKiBAY2FsbGJhY2sgY29tcGxldGVDYWxsYmFja1xuICogQGFyZ3VtZW50IHtBcnJheX0gZGF0YSAtIEFsbCB0aGUgZmV0Y2hlZCBpdGVtc1xuICovXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBpdGVtcyBmcm9tIGEgcGFnZSBvdXQgb2YgYW4gQWRkLW9uIFNESyBSZXNwb25zZSBvYmplY3QuXG4gKlxuICogQGNhbGxiYWNrIGdldEl0ZW1zXG4gKiBAYXJndW1lbnQgez99IGRhdGEgLSBXaGF0ZXZlciB7QGxpbmsgbW9kdWxlOnBhZ2luYXRpb24taGVscGVyfnJlcXVlc3R9IHJldHVybmVkLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBleHRyYWN0ZWQgaXRlbXMuXG4gKi9cbi8qKlxuICogQGNhbGxiYWNrIGdldFBhZ2VOdW1iZXJcbiAqIEBhcmd1bWVudCB7bnVtYmVyfHN0cmluZ30gcGFnZSAtIFRoZSBjdXJyZW50IHBhZ2UuXG4gKiBAYXJndW1lbnQge251bWJlcn0gcGFnZVNpemUgLSBUaGUgc2l6ZSBvZiBhIHBhZ2UuXG4gKiBAYXJndW1lbnQgez99IGRhdGEgLSBXaGF0ZXZlciB7QGxpbmsgbW9kdWxlOnBhZ2luYXRpb24taGVscGVyfnJlcXVlc3R9IHJldHVybmVkLlxuICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gVGhlIG5leHQgcGFnZSB0byBmZXRjaC5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYWdpbmF0aW9uSGVscGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCAtIFRoZSBiYXNlIFVSTCB0byBjYWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWdlU2l6ZT0xMDBdIC0gVGhlIG51bWJlciBvZiBleHBlY3RlZCBpdGVtcyBwZXIgZnVsbCBwYWdlLlxuICogQHByb3BlcnR5IHttb2R1bGU6cGFnaW5hdGlvbi1oZWxwZXJ+cmVxdWVzdH0gcmVxdWVzdFxuICogQHByb3BlcnR5IHttb2R1bGU6cGFnaW5hdGlvbi1oZWxwZXJ+ZmV0Y2hOZXh0UGFnZX0gZmV0Y2hOZXh0UGFnZVxuICogQHByb3BlcnR5IHttb2R1bGU6cGFnaW5hdGlvbi1oZWxwZXJ+Y29tcGxldGVDYWxsYmFja30gW29uQ29tcGxldGVdXG4gKiBAcHJvcGVydHkge21vZHVsZTpwYWdpbmF0aW9uLWhlbHBlcn5nZXRJdGVtc30gZ2V0SXRlbXNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnBhZ2luYXRpb24taGVscGVyfmdldFBhZ2VOdW1iZXJ9IFtnZXRQYWdlTnVtYmVyPShwYWdlLCBwYWdlU2l6ZSkgPT4gcGFnZSArIHBhZ2VTaXplXVxuICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSBbaW5pdGlhbFBhZ2U9MF0gLSBUaGUgZmlyc3QgcGFnZSB0aGF0IGlzIGZldGNoZWQuXG4gKi9cblxuLyoqXG4gKiBGZXRjaGVzIHRoZSBuZXh0IHBhZ2UgYW5kIHRoZW4gcHJvY2Vzc2VzIHRoZSBjb250ZW50LiBJbnZva2VzIGl0c2VsZlxuICogcmVjdXJzaXZlbHkgYW5kIGlzIGluaXRpYWxseSBpbnZva2VkIGZyb20gdGhlIGNvbnN0cnVjdG9yLiBJZiBhbGwgY29udGVudFxuICogd2FzIGZldGNoZWQgb25Db21wbGV0ZSBpcyBjYWxsZWQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdGlhbD1mYWxzZV0gLSBJZiB0aGlzIGlzIHRoZSBmaXJzdCBmZXRjaGVkIHBhZ2UuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5QYWdpbmF0aW9uSGVscGVyLnByb3RvdHlwZS5nZXRQYWdlID0gZnVuY3Rpb24oaW5pdGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2JrID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5yZXN1bHQuY29uY2F0KHRoaXMuZ2V0SXRlbXMoZGF0YSkpO1xuICAgICAgICAgICAgaWYodGhpcy5mZXRjaE5leHRQYWdlKGRhdGEsIHRoaXMucGFnZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlID0gdGhpcy5nZXRQYWdlTnVtYmVyKHRoaXMucGFnZSwgdGhpcy5wYWdlU2l6ZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRQYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKEFycmF5LnNsaWNlKHRoaXMucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJldCA9IHRoaXMucmVxdWVzdCh0aGlzLnVybCArIHRoaXMucGFnZSwgY2JrLCBpbml0aWFsKTtcblxuICAgIGlmKHR5cGVvZiAocmV0KSA9PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHJldCkge1xuICAgICAgICByZXQudGhlbihjYmspO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgUGFnaW5hdGlvbkhlbHBlciB0aGF0IHJlc29sdmVzIGEgcHJvbWlzZS4gVGhlIHNwZWNpZmllZCBjYWxsYmFja1xuICogZnVuY3Rpb25zIGFyZSBub3QgaGFuZGVsZCBwcm9taXNlIGF3YXJlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnBhZ2luYXRpb24taGVscGVyflBhZ2luYXRpb25IZWxwZXJPcHRpb25zfSBvcHRpb25zIC0gUGFnaW5hdGlvblxuICogICAgICAgIGhlbHBlciBjb25maWd1cmF0aW9uIHdpdGhvdXQgb25Db21wbGV0ZS5cbiAqIEBhc3luY1xuICogQHJldHVybnMge3VuZGVmaW5lZH0gVGhlIFBhZ2luYXRpb25IZWxwZXIgaXMgZG9uZS5cbiAqIEBhbGlhcyBtb2R1bGU6cGFnaW5hdGlvbi1oZWxwZXIucHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyXG4gKi9cbmNvbnN0IHByb21pc2VkUGFnaW5hdGlvbkhlbHBlciA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSA9IHJlc29sdmU7XG5cbiAgICAgICAgbmV3IFBhZ2luYXRpb25IZWxwZXIob3B0aW9ucyk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgeyBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIsIFBhZ2luYXRpb25IZWxwZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3BhZ2luYXRpb24taGVscGVyLmpzIiwiLyoqXG4gKiBCdWlsZCBxdWVyeSBzdHJpbmdzIGZyb20gYW4gT2JqZWN0XG4gKlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgc3RyaW5naWZ5KG9iaikge1xuICAgICAgICBjb25zdCBxcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yKGNvbnN0IHEgaW4gb2JqKSB7XG4gICAgICAgICAgICBxcy5hcHBlbmQocSwgb2JqW3FdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxcy50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9xdWVyeXN0cmluZy5qcyIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFNESyBjb21tdW5pY2F0aW9uIGhlbHBlci5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICovXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnZXZlbnQtdGFyZ2V0LXNoaW0nO1xuXG5jbGFzcyBTREtDb21tdW5pY2F0aW9uIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMucG9ydCA9IGJyb3dzZXIucnVudGltZS5jb25uZWN0KHsgbmFtZTogXCJzZGstY29ubmVjdGlvblwiIH0pO1xuICAgICAgICB0aGlzLnBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBlbWl0KHRoaXMsIFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcG9zdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZih0eXBlb2YgbWVzc2FnZSAhPSBcIm9iamVjdFwiIHx8ICEoXCJ0YXJnZXRcIiBpbiBtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBhdCBsZWFzdCBnaXZlIGEgdGFyZ2V0IGFjdGlvbiBmb3IgdGhlIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGRvQWN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSB0aGUgb25jZSBpbmZyYXN0cnVjdHVyZSBzaW5jZSBvdGhlciByZXBsaWVzIG1pZ2h0IGNvbWUgaW4gZmlyc3QuXG4gICAgICAgICAgICBjb25zdCB3YWl0Rm9yQWN0aW9uID0gKHsgZGV0YWlsIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZihkZXRhaWwudGFyZ2V0ID09IG1lc3NhZ2UudGFyZ2V0ICsgXCItcmVwbHlcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRldGFpbC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXRhaWwucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGV0YWlsLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgU0RLID0gbmV3IFNES0NvbW11bmljYXRpb24oKTtcblxuZXhwb3J0IGRlZmF1bHQgU0RLO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvc2RrLmpzIiwiLyoqXG4gKiBDb25jdXJyZW50IGxvZ2ljIHV0aWxzXG4gKlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqL1xuXG4vKipcbiAqIElkZW50aXR5IGZ1bmN0aW9uLCByZXR1cm5zIHdoYXQgaXQgZ2V0cy5cbiAqXG4gKiBAcGFyYW0gez99IGkgLSBXaGF0IGl0IGdldHMuXG4gKiBAcmV0dXJucyB7P30gV2hhdCBpdCBnb3QuXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0gKGkpID0+IGk7XG5cbi8qKlxuICogQW4gYXN5bmNocm9ub3VzIHZlcnNpb24gb2YgdGhlIGJvb2xlYW4gYW5kIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb21pc2V9IGFyZ3MgLSBQcm9taXNlcyB0aGF0IHJldHVybiBib29sZWFucyB0byBkbyBhbiBhbmQgb24uXG4gKiBAYXN5bmNcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXN1bHQgb2YgdGhlIGFuZCBvcGVyYXRpb24gb24gYWxsIHJldHVybmVkIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFyZ3MpLnRoZW4oKHApID0+IHAuZXZlcnkoaWRlbnRpdHkpKTtcbn1cblxuLyoqXG4gKiBBbiBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiB0aGUgYm9vbGVhbiBvciBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtQcm9taXNlfSBhcmdzIC0gUHJvbWlzZXMgdGhhdCByZXR1cm4gYm9vbGVhbnMgdG8gZG8gYW4gb3Igb24uXG4gKiBAYXN5bmNcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXN1bHQgb2YgdGhlIG9yIG9wZXJhdGlvbiBvbiBhbGwgcmV0dXJuZWQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3IoLi4uYXJncykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChhcmdzKS50aGVuKChwKSA9PiBwLnNvbWUoaWRlbnRpdHkpKTtcbn1cblxuLypcbiAqIEludmVydCB0aGUgdmFsdWUgYSBwcm9taXNlIHJlc29sdmVzIHRvLlxuICpcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbXNpZSAtIFByb21pc2UgdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSB0byBpbnZlcnQuXG4gKiBAYXN5bmNcbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgb3Bwb3NpdGUgdmFsdWUgdGhhbiB0aGUgZ2l2ZW4gcHJvbWlzZSByZXNvbHZlZCB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigocCkgPT4gIXApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvbG9naWMuanMiLCIvKipcbiAqIEV4cG9ydHMgZWFjaCBwcm92aWRlciBhcyBhIHByb3BlcnR5IG5hbWVkIGFmdGVyIHRoZSBwcm92aWRlcidzIHR5cGUuIEVhY2hcbiAqIHByb3ZpZGVyIGlzIGFzc3VtZWQgdG8gYmUgZnJvemVuLlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBtb2R1bGUgcHJvdmlkZXJzXG4gKi9cbmltcG9ydCB0d2l0Y2ggZnJvbSBcIi4vdHdpdGNoXCI7XG5pbXBvcnQgaGl0Ym94IGZyb20gXCIuL2hpdGJveFwiO1xuaW1wb3J0IHVzdHJlYW0gZnJvbSBcIi4vdXN0cmVhbVwiO1xuaW1wb3J0IHlvdXR1YmUgZnJvbSBcIi4veW91dHViZVwiO1xuaW1wb3J0IGxpdmVzdHJlYW0gZnJvbSBcIi4vbGl2ZXN0cmVhbVwiO1xuaW1wb3J0IG1sZyBmcm9tIFwiLi9tbGdcIjtcbmltcG9ydCBhenVidSBmcm9tIFwiLi9henVidVwiO1xuaW1wb3J0IGJlYW0gZnJvbSBcIi4vYmVhbVwiO1xuaW1wb3J0IHBpY2FydG8gZnJvbSBcIi4vcGljYXJ0b1wiO1xuaW1wb3J0IG5ld2xpdmVzdHJlYW0gZnJvbSBcIi4vbmV3LWxpdmVzdHJlYW1cIjtcbmltcG9ydCBkb3V5dXR2IGZyb20gXCIuL2RvdXl1dHZcIjtcbmltcG9ydCBkYWlseW1vdGlvbiBmcm9tIFwiLi9kYWlseW1vdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdHdpdGNoLFxuICAgIGhpdGJveCxcbiAgICB1c3RyZWFtLFxuICAgIHlvdXR1YmUsXG4gICAgbGl2ZXN0cmVhbSxcbiAgICBtbGcsXG4gICAgYXp1YnUsXG4gICAgYmVhbSxcbiAgICBwaWNhcnRvLFxuICAgIG5ld2xpdmVzdHJlYW0sXG4gICAgZG91eXV0dixcbiAgICBkYWlseW1vdGlvblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9pbmRleC5qcyIsIi8qKlxuICogTGl2ZSBzdGF0ZSBjb25zdGFudHNcbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBPRkZMSU5FOiAtMSxcbiAgICBMSVZFOiAwLFxuICAgIFJFRElSRUNUOiAxLFxuICAgIFJFQlJPQURDQVNUOiAyLFxuICAgIFRPV0FSRF9MSVZFOiAwLFxuICAgIFRPV0FSRF9PRkZMSU5FOiAxXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpdmUtc3RhdGUuanMiLCIvKipcbiAqIEBhdXRob3IgVG9ydSBOYWdhc2hpbWFcbiAqIEBjb3B5cmlnaHQgMjAxNSBUb3J1IE5hZ2FzaGltYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5pcXVlIGtleS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIEEgbmFtZSB0byBjcmVhdGUuXG4gKiBAcmV0dXJucyB7c3ltYm9sfHN0cmluZ30gR2VuZXJhdGVkIHVuaXF1ZSBrZXkuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlVW5pcXVlS2V5ID0gbW9kdWxlLmV4cG9ydHMuY3JlYXRlVW5pcXVlS2V5ID0gKFxuICAgIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAvKiBvdGhlcndpc2UgKi8gZnVuY3Rpb24gY3JlYXRlVW5pcXVlS2V5KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiW1tcIiArIG5hbWUgKyBcIl9cIiArIE1hdGgucmFuZG9tKCkudG9GaXhlZCg4KS5zbGljZSgyKSArIFwiXV1cIlxuICAgIH1cbilcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3Qgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7YW55fSB4IC0gVGhlIHZhbHVlIHRvIGJlIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaXNPYmplY3QgPSBtb2R1bGUuZXhwb3J0cy5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbFxufVxuXG4vKipcbiAqIFRoZSBrZXkgb2YgbGlzdGVuZXJzLlxuICpcbiAqIEB0eXBlIHtzeW1ib2x8c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuTElTVEVORVJTID0gY3JlYXRlVW5pcXVlS2V5KFwibGlzdGVuZXJzXCIpXG5cbi8qKlxuICogQSB2YWx1ZSBvZiBraW5kIGZvciBsaXN0ZW5lcnMgd2hpY2ggYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIGNhcHR1cmluZyBwaGFzZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuQ0FQVFVSRSA9IDFcblxuLyoqXG4gKiBBIHZhbHVlIG9mIGtpbmQgZm9yIGxpc3RlbmVycyB3aGljaCBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgYnViYmxpbmcgcGhhc2UuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzLkJVQkJMRSA9IDJcblxuLyoqXG4gKiBBIHZhbHVlIG9mIGtpbmQgZm9yIGxpc3RlbmVycyB3aGljaCBhcmUgcmVnaXN0ZXJlZCBhcyBhbiBhdHRyaWJ1dGUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzLkFUVFJJQlVURSA9IDNcblxuLyoqXG4gKiBAdHlwZWRlZiBvYmplY3QgTGlzdGVuZXJOb2RlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIEEgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0ga2luZCAtIFRoZSBraW5kIG9mIHRoZSBsaXN0ZW5lci5cbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJOb2RlfG51bGx9IG5leHQgLSBUaGUgbmV4dCBub2RlLlxuICogICAgICBJZiB0aGlzIG5vZGUgaXMgdGhlIGxhc3QsIHRoaXMgaXMgYG51bGxgLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5vZGUgb2Ygc2luZ2x5IGxpbmtlZCBsaXN0IGZvciBhIGxpc3Qgb2YgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gQSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBraW5kIC0gVGhlIGtpbmQgb2YgdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vbmNlXSAtIFRoZSBmbGFnIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgYXQgdGhlIGZpcnN0IGNhbGwuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhc3NpdmVdIC0gVGhlIGZsYWcgdG8gaWdub3JlIGBldmVudC5wcmV2ZW50RGVmYXVsdGAgbWV0aG9kLlxuICogQHJldHVybnMge0xpc3RlbmVyTm9kZX0gVGhlIGNyZWF0ZWQgbGlzdGVuZXIgbm9kZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMubmV3Tm9kZSA9IGZ1bmN0aW9uIG5ld05vZGUobGlzdGVuZXIsIGtpbmQsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gaXNPYmplY3Qob3B0aW9ucylcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgb25jZTogb2JqICYmIEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgcGFzc2l2ZTogb2JqICYmIEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXZlbnQtdGFyZ2V0LXNoaW0vbGliL2NvbW1vbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogU2VyaWFsaXplcyB0aGUgcHJvdmlkZXJzIHNvIHRoZXkgY2FuIGJlIHNlbnQgb3ZlciBhIG1lc3NhZ2UgcG9ydC5cbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIHByb3ZpZGVycy9zZXJpYWxpemVkXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6cHJvdmlkZXJzfVxuICovXG5pbXBvcnQgYWxsUHJvdmlkZXJzIGZyb20gXCIuL2luZGV4XCI7XG5cbi8qKlxuICogRnJvemVuLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcmlhbGl6ZWRQcm92aWRlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnByb3ZpZGVycy9nZW5lcmljLXByb3ZpZGVyflByb3ZpZGVyU3VwcG9ydHN9IHN1cHBvcnRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuYWJsZWRcbiAqL1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIHByb3ZpZGVycyBvYmplY3RzIHNvIHRoZXkgY2FuIGdldCBwYXNzZWQgYXMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpwcm92aWRlcnMvZ2VuZXJpYy1wcm92aWRlci5HZW5lcmljUHJvdmlkZXI+fSBwcm92aWRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gUHJvdmlkZXJzIG9iamVjdCB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgbW9kdWxlOnByb3ZpZGVycy9zZXJpYWxpemVkflNlcmlhbGl6ZWRQcm92aWRlcj59XG4gKiAgICAgICAgIEZyb3plbiBPYmplY3Qgb2Ygc2VyaWFsaXplZCBwcm92aWRlcnMgYnkgaWQuXG4gKi9cbmNvbnN0IHNlcmlhbGl6ZVByb3ZpZGVycyA9IChwcm92aWRlcnMpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBmb3IoY29uc3QgcCBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgcmV0W3BdID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiBwcm92aWRlcnNbcF0ubmFtZSxcbiAgICAgICAgICAgIHN1cHBvcnRzOiBwcm92aWRlcnNbcF0uc3VwcG9ydHMsXG4gICAgICAgICAgICBlbmFibGVkOiBwcm92aWRlcnNbcF0uZW5hYmxlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmZyZWV6ZShyZXQpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpwcm92aWRlcnMvc2VyaWFsaXplZH5zZXJpYWxpemVQcm92aWRlcnN9XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbW9kdWxlOnByb3ZpZGVycy9zZXJpYWxpemVkflNlcmlhbGl6ZWRQcm92aWRlcj59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHNlcmlhbGl6ZVByb3ZpZGVycyhhbGxQcm92aWRlcnMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL3NlcmlhbGl6ZWQuanMiLCIvKipcbiAqIFF1ZXVlIHNlcnZpY2UgZm9yIHByb3ZpZGVycy4gUHJvdmlkZXMgYSBzZXBhcmF0ZWQgbWFuYWdlbWVudCBmb3IgcmVxdWVzdHMgYnlcbiAqIHByb3ZpZGVyLCBhbGwgaW4gdGhlIHNhbWUge0BsaW5rIG1vZHVsZTpxdWV1ZS91cGRhdGUuVXBkYXRlUXVldWV9LlxuICpcbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIHF1ZXVlL3NlcnZpY2VcbiAqIEByZXF1aXJlcyBtb2R1bGU6cXVldWUvdXBkYXRlXG4gKi9cblxuLy9UT0RPIHByZS1jYWxjdWxhdGUgUmVzcG9uc2UuanNvbigpP1xuaW1wb3J0IFVwZGF0ZVF1ZXVlIGZyb20gXCIuL3VwZGF0ZVwiO1xuaW1wb3J0IHByZWZzIGZyb20gXCIuLi9wcmVmZXJlbmNlc1wiO1xuXG5jb25zdCBxdWV1ZSA9IG5ldyBVcGRhdGVRdWV1ZSgpLFxuICAgIHNlcnZpY2VzID0ge30sXG4gICAgZGVmYXVsdFJlcXVldWUgPSAocmVzcG9uc2UpID0+ICFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgIT09IDQwNCAmJiByZXNwb25zZS5zdGF0dXMgIT09IDQyMCxcbiAgICBjb21wbGV0ZUNhbGxiYWNrID0gKHJlcXVldWUsIGNhbGxiYWNrLCB1cmwsIGRhdGEpID0+IHtcbiAgICAgICAgaWYoIXJlcXVldWUoZGF0YSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEsIHVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbi8qKlxuICogQGNhbGxiYWNrIHVwZGF0ZVJlcXVlc3RDYWxsYmFja1xuICogQHBhcmFtIHtleHRlcm5hbDpzZGsvcmVxdWVzdH5SZXNwb25zZX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIHByb3ZpZGluZyBtZXRob2RzIGZvciBhIHByb3ZpZGVyIHRvIHBsYWNlIG9uZS10aW1lIGFuZCByZW9jdXJyaW5nXG4gKiByZXF1ZXN0cy5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgUXVldWVTZXJ2aWNlIHtcbiAgICBzdGF0aWMgSElHSF9QUklPUklUWSA9IFwiaGlnaFwiO1xuICAgIHN0YXRpYyBMT1dfUFJJT1JJVFkgPSBcImxvd1wiO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIGhpZ2hQcmlvcml0eVJlcXVlc3RJZHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBsb3dQcmlvcml0eVJlcXVlc3RJZHMgPSBbXTtcbiAgICBISUdIX1BSSU9SSVRZID0gUXVldWVTZXJ2aWNlLkhJR0hfUFJJT1JJVFk7XG4gICAgTE9XX1BSSU9SSVRZID0gUXVldWVTZXJ2aWNlLkxPV19QUklPUklUWTtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oaWdoUHJpb3JpdHlSZXF1ZXN0SWRzID0gW107XG4gICAgICAgIHRoaXMubG93UHJpb3JpdHlSZXF1ZXN0SWRzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVxdWVzdCBJRCBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBwcmlvcml0eS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHttb2R1bGU6cXVldWUtc2VydmljZX5RdWV1ZVByaW9yaXR5fSBwcmlvcml0eSAtIFByaW9yaXR5IHRvIGdldFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYXJyYXkgZm9yLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgcmVxdWVzdCBJRHMuXG4gICAgICovXG4gICAgZ2V0UmVxdWVzdFByb3BlcnR5KHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzW3ByaW9yaXR5ICsgXCJQcmlvcml0eVJlcXVlc3RJZHNcIl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgcmVxdWVzdCBoYXMgdG8gYmUgcmVxdWV1ZWQgZHVlIHRvIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFjayByZXF1ZXVlXG4gICAgICogQHBhcmFtIHtleHRlcm5hbDpzZGsvcmVxdWVzdH5SZXNwb25zZX0gZGF0YSAtIFJlc3BvbnNlIHRoYXQgd2FzIHJldHVybmVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGVuIHRydWUsIHRoZSByZXF1ZXN0IHdpbGwgYmUgcXVldWVkIGFnYWluLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IHJ1biBhIHJlcXVlc3QgdG8gdGhlIGdpdmVuIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnM9e31dIC0gQW4gb2JqZWN0IHdpdGggdGhlIGhlYWRlcnNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzZW5kLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnF1ZXVlL3NlcnZpY2V+cmVxdWV1ZX0gW3JlcXVldWU9KHIpID0+IHIuc3RhdHVzID4gNDk5XVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIERldGVybWluZXMgaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIHJlLXJ1bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2F0dGVtcHQ9MF0gLSBDb3VudGVyIHRvIGF2b2lkIHJlcXVldWluZyBpbmZpbml0ZWx5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIEFkZC1vbiBTREsgUmVxdWVzdCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBxdWV1ZVJlcXVlc3QodXJsLCBoZWFkZXJzID0ge30sIHJlcXVldWUgPSBkZWZhdWx0UmVxdWV1ZSwgYXR0ZW1wdCA9IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJRdWV1ZWluZyBcIiArIHVybCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHF1ZXVlLmFkZFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihyZXF1ZXVlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmcy5nZXQoXCJxdWV1ZXNlcnZpY2VfbWF4UmV0cmllc1wiKS50aGVuKChtYXhSZXRyaWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ZW1wdCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnF1ZXVlUmVxdWVzdCh1cmwsIGhlYWRlcnMsIHJlcXVldWUsICsrYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiVG9vIG1hbnkgYXR0ZW1wdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3RcbiAgICAgICAgICAgIH0sIGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYoYXR0ZW1wdCA9PT0gMCAmJiBuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgICAgICAgICAgICAgcXVldWUuZ2V0UmVxdWVzdEJ5SWQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnF1ZXVlcyBhbiBhbGwgdXBkYXRlIHJlcXVlc3RzIG9mIHRoZSBnaXZlbiBwcmlvcml0eS4gSWYgbm9uZSBpcyBnaXZlbixcbiAgICAgKiBhbGwgdXBkYXRlIHJlcXVlc3RzIGFyZSB1bnF1ZXVlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnF1ZXVlL3NlcnZpY2V+UXVldWVQcmlvcml0eT99IHByaW9yaXR5IC0gUHJpb3JpdHkgb2ZcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldXFlc3RzIHRvIHVucXVldWUuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB1bnF1ZXVlVXBkYXRlUmVxdWVzdChwcmlvcml0eSkge1xuICAgICAgICBpZighcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHRoaXMudW5xdWV1ZVVwZGF0ZVJlcXVlc3QoUXVldWVTZXJ2aWNlLkhJR0hfUFJJT1JJVFkpO1xuICAgICAgICAgICAgdGhpcy51bnF1ZXVlVXBkYXRlUmVxdWVzdChRdWV1ZVNlcnZpY2UuTE9XX1BSSU9SSVRZKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0UmVxdWVzdFByb3BlcnR5KHByaW9yaXR5KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSZXF1ZXN0UHJvcGVydHkocHJpb3JpdHkpLmZvckVhY2goKHJlcUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnJlbW92ZVJlcXVlc3QocmVxSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UmVxdWVzdFByb3BlcnR5KHByaW9yaXR5KS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlIGEgbmV3IHJlb2N1cnJpbmcgdXBkYXRlIHJlcXVlc3Qgb2YgdGhlIGdpdmVuIHByaW9yaXR5LiBSZW1vdmVzIGFsbFxuICAgICAqIGV4aXN0aW5nIHVwZGF0ZSByZXF1ZXN0cyBvZiB0aGlzIHByaW9yaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gdXJscyAtIEFuIGFycmF5IG9mIFVSTHMgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTpxdWV1ZS9zZXJ2aWNlflF1ZXVlUHJpb3JpdHl9IHByaW9yaXR5IC0gUHJpb3JpdHkgdG8gcXVldWVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlcXVlc3QgYXMuXG4gICAgICogQHBhcmFtIHttb2R1bGU6cXVldWUvc2VydmljZX51cGRhdGVSZXF1ZXN0Q2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbmV2ZXIgYSByZXF1ZXN0IGlzIGRvbmUgKGZvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggcHJvdmlkZWQgVVJMKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IFtyYXdIZWFkZXJzPXt9XSAtIEFuIG9iamVjdCB3aXRoIGhlYWRlci12YWx1ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpcnMgdG8gc2VuZCB3aXRoIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTpxdWV1ZS9zZXJ2aWNlfnJlcXVldWV9IFtyZXF1ZXVlPShyKSA9PiByLnN0YXR1cyA+IDQ5OV1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEZXRlcm1pbmluZXMgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZS1ydW4uXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBxdWV1ZVVwZGF0ZVJlcXVlc3QodXJscywgcHJpb3JpdHksIGNhbGxiYWNrLCByYXdIZWFkZXJzID0ge30sIHJlcXVldWUgPSBkZWZhdWx0UmVxdWV1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlcXVldWVpbmcgXCIgKyBwcmlvcml0eSArIFwiIHByaW9yaXR5IHVwZGF0ZSByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnVucXVldWVVcGRhdGVSZXF1ZXN0KHByaW9yaXR5KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzLmdldFJlcXVlc3RQcm9wZXJ0eShwcmlvcml0eSksXG4gICAgICAgICAgICBza2lwcyA9IHByaW9yaXR5ID09IFF1ZXVlU2VydmljZS5MT1dfUFJJT1JJVFkgPyA0IDogMCxcbiAgICAgICAgICAgIGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyYXdIZWFkZXJzKTtcblxuICAgICAgICByZXF1ZXN0cy5wdXNoKC4uLnVybHMubWFwKCh1cmwpID0+IHF1ZXVlLmFkZFJlcXVlc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogY29tcGxldGVDYWxsYmFjay5iaW5kKG51bGwsIHJlcXVldWUsIGNhbGxiYWNrLCB1cmwpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgc2tpcHNcbiAgICAgICAgKSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBRdWV1ZVNlcnZpY2UgZm9yIHRoZSB1c2FnZSBpbiBhIHByb3ZpZGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlck5hbWUgLSBUaGUgdHlwZSBvZiB0aGUgcHJvdmlkZXIuXG4gKiBAcmV0dXJucyB7bW9kdWxlOnF1ZXVlL3NlcnZpY2V+UXVldWVTZXJ2aWNlfSBRdWV1ZVNlcnZpY2UgZm9yIHRoZSBwcm92aWRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNlcnZpY2VGb3JQcm92aWRlciA9IChwcm92aWRlck5hbWUpID0+IHtcbiAgICBpZighc2VydmljZXMuaGFzT3duUHJvcGVydHkocHJvdmlkZXJOYW1lKSkge1xuICAgICAgICBzZXJ2aWNlc1twcm92aWRlck5hbWVdID0gbmV3IFF1ZXVlU2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VydmljZXNbcHJvdmlkZXJOYW1lXTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpbnRlcm5hbCBxdWV1ZSByZWZyZXNoIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6cXVldWUvcGF1c2VhYmxlflF1ZXVlT3B0aW9uc30gb3B0aW9ucyAtIFF1ZXVlIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0T3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJbUVNdPiBzZXR0aW5nIHF1ZXVlIG9wdGlvbnM6XCIgKyBvcHRpb25zLnRvU291cmNlKCkpO1xuICAgIHF1ZXVlLmF1dG9GZXRjaChvcHRpb25zLmludGVydmFsLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhTaXplKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBpbnRlcnZhbCBvZiB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIC0gUmVmcmVzaCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlT3B0aW9ucyA9IChpbnRlcnZhbCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiW1FTXT4gc2V0dGluZyBpbnRlcnZhbCB0byBcIiArIGludGVydmFsKTtcbiAgICBxdWV1ZS5hdXRvRmV0Y2goaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBQYXVzZSB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgIHF1ZXVlLnBhdXNlKCk7XG59O1xuXG4vKipcbiAqIFJlc3VtZSB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlc3VtZSA9ICgpID0+IHtcbiAgICBxdWV1ZS5yZXN1bWUoKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUXVldWVTZXJ2aWNlTGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNvbnRhaW5zUHJpb3JpemVkIC0gQ2FsbGJhY2sgZm9yIHRoZVxuICoge0BsaW5rIG1vZHVsZTpxdWV1ZS91cGRhdGUuVXBkYXRlUXVldWUjZXZlbnQ6cXVldWVwcmlvcml6ZWR9IGV2ZW50IG9mIHRoZVxuICogaW50ZXJuYWwgcXVldWUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwcmlvcml6ZWRMb2FkZWQgLSBDYWxsYmFjayBmb3IgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOnF1ZXVlL3VwZGF0ZS5VcGRhdGVRdWV1ZSNldmVudDphbGxwcmlvcml6ZWRsb2FkZWR9IGV2ZW50IG9mIHRoZVxuICogaW50ZXJuYWwgcXVldWUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwYXVzZWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlc3VtZWRcbiAqL1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGludGVybmFsIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnF1ZXVlL3NlcnZpY2V+UXVldWVTZXJ2aWNlTGlzdGVuZXJ9IGxpc3RlbmVycyAtIExpc3RlbmVycyB0byBhZGQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3QgYWRkTGlzdGVuZXJzID0gKHsgY29udGFpbnNQcmlvcml6ZWQsIHByaW9yaXplZExvYWRlZCwgcGF1c2VkLCByZXN1bWVkIH0pID0+IHtcbiAgICBpZihjb250YWluc1ByaW9yaXplZCkge1xuICAgICAgICBxdWV1ZS5hZGRFdmVudExpc3RlbmVyKFwicXVldWVwcmlvcml6ZWRcIiwgY29udGFpbnNQcmlvcml6ZWQpO1xuICAgIH1cbiAgICBpZihwcmlvcml6ZWRMb2FkZWQpIHtcbiAgICAgICAgcXVldWUuYWRkRXZlbnRMaXN0ZW5lcihcImFsbHByaW9yaXplZGxvYWRlZFwiLCBwcmlvcml6ZWRMb2FkZWQpO1xuICAgIH1cbiAgICBpZihwYXVzZWQpIHtcbiAgICAgICAgcXVldWUuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIHBhdXNlZCk7XG4gICAgfVxuICAgIGlmKHJlc3VtZWQpIHtcbiAgICAgICAgcXVldWUuYWRkRXZlbnRMaXN0ZW5lcihcInJlc3VtZVwiLCByZXN1bWVkKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6cXVldWUvc2VydmljZX5RdWV1ZVNlcnZpY2VMaXN0ZW5lcn0gbGlzdGVuZXJzIC0gTGlzdGVuZXJzIHRvXG4gKiAgICAgICAgcmVtb3ZlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9ICh7IGNvbnRhaW5zUHJpb3JpemVkLCBwcmlvcml6ZWRMb2FkZWQsIHBhdXNlZCwgcmVzdW1lZCB9KSA9PiB7XG4gICAgaWYoY29udGFpbnNQcmlvcml6ZWQpIHtcbiAgICAgICAgcXVldWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInF1ZXVlcHJpb3JpemVkXCIsIGNvbnRhaW5zUHJpb3JpemVkKTtcbiAgICB9XG4gICAgaWYocHJpb3JpemVkTG9hZGVkKSB7XG4gICAgICAgIHF1ZXVlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbGxwcmlvcml6ZWRsb2FkZWRcIiwgcHJpb3JpemVkTG9hZGVkKTtcbiAgICB9XG4gICAgaWYocGF1c2VkKSB7XG4gICAgICAgIHF1ZXVlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCBwYXVzZWQpO1xuICAgIH1cbiAgICBpZihyZXN1bWVkKSB7XG4gICAgICAgIHF1ZXVlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXN1bWVcIiwgcmVzdW1lZCk7XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3F1ZXVlL3NlcnZpY2UuanMiLCIvKipcbiAqIFBhcmVudGFsIGNvbnRyb2xzIHdyYXBwZXIuXG4gKlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqL1xuaW1wb3J0IFNESyBmcm9tICcuL3Nkayc7XG5cbmxldCBlbmFibGVkID0gZmFsc2U7XG5cbmNvbnN0IGdldEVuYWJsZWQgPSAoKSA9PiBTREsuZG9BY3Rpb24oeyB0YXJnZXQ6IFwicGMtZW5hYmxlZFwiIH0pLnRoZW4oKGUpID0+IHtcbiAgICBlbmFibGVkID0gZTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIGdldEVuYWJsZWQoKTtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgfVxufTtcblxuZ2V0RW5hYmxlZCgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcGFyZW50YWwtY29udHJvbHMuanMiLCJ2YXIgY2hhcmVuYyA9IHtcbiAgLy8gVVRGLTggZW5jb2RpbmdcbiAgdXRmODoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gY2hhcmVuYy5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjaGFyZW5jLmJpbi5ieXRlc1RvU3RyaW5nKGJ5dGVzKSkpO1xuICAgIH1cbiAgfSxcblxuICAvLyBCaW5hcnkgZW5jb2RpbmdcbiAgYmluOiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN0ciA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSk7XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyZW5jO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NoYXJlbmMvY2hhcmVuYy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBjaGFubmVsL2NvbnRyb2xsZXJcbiAqL1xuaW1wb3J0IHByb3ZpZGVycyBmcm9tIFwiLi4vcHJvdmlkZXJzXCI7XG5pbXBvcnQgQ2hhbm5lbHNNYW5hZ2VyIGZyb20gXCIuL21hbmFnZXJcIjtcbmltcG9ydCBDaGFubmVsTGlzdCBmcm9tIFwiLi9saXN0XCI7XG5pbXBvcnQgRXZlbnRTaW5rIGZyb20gJy4uL3Byb3ZpZGVycy9ldmVudHMnO1xuaW1wb3J0IHsgZW1pdCwgaW52b2tlT25jZSwgd2hlbiB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHNlcmlhbGl6ZWRQcm92aWRlcnMgZnJvbSBcIi4uL3Byb3ZpZGVycy9zZXJpYWxpemVkXCI7XG5pbXBvcnQgUGFyZW50YWxDb250cm9scyBmcm9tIFwiLi4vcGFyZW50YWwtY29udHJvbHNcIjtcbmltcG9ydCB7IGZsYXR0ZW4sIHBhcnRpYWwsIGRlYm91bmNlIH0gZnJvbSBcInVuZGVyc2NvcmVcIjtcbmltcG9ydCAqIGFzIGRlYnVnRHVtcCBmcm9tIFwiLi9kdW1wXCI7XG5pbXBvcnQgcHJlZnMgZnJvbSBcIi4uL3ByZWZlcmVuY2VzXCI7XG5pbXBvcnQgKiBhcyBsb2dpbnMgZnJvbSBcIi4uL2xvZ2luc1wiO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJ2V2ZW50LXRhcmdldC1zaGltJztcblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvY29udHJvbGxlci5DaGFubmVsQ29udHJvbGxlciNjaGFubmVsc2FkZGVkXG4gKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59XG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL2NvbnRyb2xsZXIuQ2hhbm5lbENvbnRyb2xsZXIjY2hhbm5lbGRlbGV0ZWRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL2NvbnRyb2xsZXIuQ2hhbm5lbENvbnRyb2xsZXIjY2hhbm5lbHVwZGF0ZWRcbiAqIEB0eXBlIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9XG4gKi9cblxuLy9jb25zdCBSRUZSRVNIX1BST0ZJTEVfVVJMID0gXCJodHRwczovL3N1cHBvcnQubW96aWxsYS5vcmcva2IvcmVmcmVzaC1maXJlZm94LXJlc2V0LWFkZC1vbnMtYW5kLXNldHRpbmdzXCIsXG5cbi8qKlxuICogRmlsdGVycyBtYXR1cmUgY2hhbm5lbHMgaWYgcGFyZW50YWwgY29udHJvbHMgYXJlIGFjdGl2YXRlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWw+fSBjaGFubmVscyAtIENoYW5uZWxzIHRvIGZpbHRlci5cbiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gRmlsdGVyZWQgb2YgY2hhbm5lbHMgbWFya2VkIGFzXG4gKiAgICAgICAgICBtYXR1cmUgaWYgcGFyZW50YWwgY29udHJvbHMgYXJlIGFjdGl2YXRlZC5cbiAqL1xuY29uc3QgZmlsdGVySW5hcHJvcHJpYXRlQ2hhbm5lbHMgPSAoY2hhbm5lbHMpID0+IHtcbiAgICAgICAgaWYoUGFyZW50YWxDb250cm9scy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbHMuZmlsdGVyKChjKSA9PiAhYy5tYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgfSxcbi8qKlxuICogRmlsdGVyIGNoYW5uZWxzIHRvIGV4Y2x1ZGUgZXhpc3RpbmcgZmF2b3JpdGVzLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyfSB1c2VyIC0gVXNlciB3aG9zZSBmYXZzIHNob3VsZCBiZSBleGNsdWRlZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59IGNoYW5uZWxzIC0gQ2hhbm5lbHMgdG8gZmlsdGVyLlxuICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWw+fSBGaWx0ZXJlZCBhcnJheSBvZiBjaGFubmVscy5cbiAqL1xuICAgIGZpbHRlckV4aXN0aW5nRmF2cyA9ICh1c2VyLCBjaGFubmVscykgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbm5lbHMuZmlsdGVyKChjaCkgPT4gIXVzZXIuZmF2b3JpdGVzLmluY2x1ZGVzKGNoLmxvZ2luKSk7XG4gICAgfTtcblxuLyoqXG4gKiBDb250cm9sbGVyIGZvciBhbGwgdGhlIGNoYW5uZWwgc3R1ZmYuIEhhbmRsZXMgZ2V0dGluZyBpbmZvIGZyb20gcHJvdmlkZXJzXG4gKiBhbmQgYWJzdHJhY3RzIHRoZSB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdH0gY29tcGxpY2F0aW9ucyBhd2F5LlxuICogQGV4dGVuZHMgZXh0ZXJuYWw6RXZlbnRUYXJnZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVhZHkgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9jb250cm9sbGVyLkNoYW5uZWxDb250cm9sbGVyI2NoYW5uZWxzYWRkZWRcbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvY29udHJvbGxlci5DaGFubmVsQ29udHJvbGxlciNjaGFubmVsZGVsZXRlZFxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9jb250cm9sbGVyLkNoYW5uZWxDb250cm9sbGVyI2NoYW5uZWx1cGRhdGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGZ1bmN0aW9uPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICAgICAgY29uc3QgbWFuYWdlckVycm9yID0gKGUsIG5hbWUsIHR5cGUsIGl0ZW1UeXBlLCBjYW5jZWxlZCA9ICgpID0+IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImxvYWRpbmdcIiwgaXRlbVR5cGUsIFwiOlwiLCBuYW1lLCB0eXBlLCBcImFuIGVycm9yIG9jY3VyZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICBpZihjYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZXIub25DYW5jZWwobmFtZSwgdHlwZSwgaXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKG5hbWUgJiYgdHlwZSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5vbkVycm9yKG5hbWUsIHByb3ZpZGVyc1t0eXBlXS5uYW1lLCBpdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLm9uRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFuYWdlckRvbmVMb2FkaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZXIubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IENoYW5uZWxzTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJhZGRjaGFubmVsXCIsICh7IGRldGFpbDogWyBuYW1lLCB0eXBlLCBjYW5jZWxlZCBdIH0pID0+IHRoaXMuYWRkQ2hhbm5lbChuYW1lLCB0eXBlLCBjYW5jZWxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLl9tYW5hZ2VyLl9kZWxldGVDYW5jZWxpbmdWYWx1ZShcImNoYW5uZWxcIiwgdHlwZSwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUpID0+IG1hbmFnZXJFcnJvcihlLCBuYW1lLCB0eXBlLCBcImNoYW5uZWxcIiwgY2FuY2VsZWQpKSk7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZWNoYW5uZWxcIiwgKHsgZGV0YWlsIH0pID0+IHRoaXMucmVtb3ZlQ2hhbm5lbChkZXRhaWwpKTtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlY2hhbm5lbFwiLCAoeyBkZXRhaWwgfSkgPT4gdGhpcy51cGRhdGVDaGFubmVsKGRldGFpbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gobWFuYWdlckRvbmVMb2FkaW5nKSk7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFkZHVzZXJcIiwgKHsgZGV0YWlsOiBbIHVzZXJuYW1lLCB0eXBlLCBjYW5jZWxlZCBdIH0pID0+IHRoaXMuYWRkVXNlcih1c2VybmFtZSwgdHlwZSwgY2FuY2VsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fbWFuYWdlci5fZGVsZXRlQ2FuY2VsaW5nVmFsdWUoXCJ1c2VyXCIsIHR5cGUsIHVzZXJuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSkgPT4gbWFuYWdlckVycm9yKGUsIHVzZXJuYW1lLCB0eXBlLCBcInVzZXJcIiwgY2FuY2VsZWQpKSk7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZXVzZXJcIiwgKHsgZGV0YWlsIH0pID0+IHRoaXMucmVtb3ZlVXNlcihkZXRhaWwpKTtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZmF2b3JpdGVzXCIsICh7IGRldGFpbCB9KSA9PiB0aGlzLnVwZGF0ZVVzZXIoZGV0YWlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChtYW5hZ2VyRG9uZUxvYWRpbmcpKTtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwiYXV0b2FkZFwiLCAoKSA9PiB0aGlzLmF1dG9BZGRVc2VycygpLmNhdGNoKG1hbmFnZXJEb25lTG9hZGluZykpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJnZXRkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENoYW5uZWxzQnlUeXBlKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNoYW5uZWxzKSA9PiBjaGFubmVscy5mb3JFYWNoKChjaCkgPT4gdGhpcy5fbWFuYWdlci5vbkNoYW5uZWxBZGRlZChjaCkpKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFVzZXJzQnlUeXBlKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHVzZXJzKSA9PiB1c2Vycy5mb3JFYWNoKCh1c3IpID0+IHRoaXMuX21hbmFnZXIub25Vc2VyQWRkZWQodXNyKSkpXG4gICAgICAgICAgICBdKS50aGVuKG1hbmFnZXJEb25lTG9hZGluZywgbWFuYWdlckRvbmVMb2FkaW5nKTtcblxuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRQcm92aWRlcnMoc2VyaWFsaXplZFByb3ZpZGVycyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkZWJ1Z2R1bXBcIiwgKCkgPT4ge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2hhbm5lbHNCeVR5cGUoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFVzZXJzQnlUeXBlKClcbiAgICAgICAgICAgIF0pLnRoZW4oKFsgY2hhbm5lbHMsIHVzZXJzIF0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVidWdEdW1wLmNvcHkoY2hhbm5lbHMsIHVzZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwic2hvd29wdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgcHJlZnMub3BlbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGVzZSBhcmUgYSBidW5jaCBvZiBoZWxwZXJzIGZvciBvbkNoYW5uZWxkZWx0ZWQuIFRoZSBjb21tZW50IHRoZXJlXG4gICAgICAgICAqIGV4cGxhaW5zIG1vcmUgb3IgbGVzcyB3aGF0J3MgZ29pbmcgb24uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWxldGVkVHlwZXMgPSBuZXcgTWFwKCksXG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0aGUgYWZ0ZXJjaGFubmVsc2RlbGV0ZWQgZXZlbnQgdG8gZmlyZSBhZnRlciBhbGwgY2hhbm5lbHMgYXJlIGdvbmUuXG4gICAgICAgICAgICBkZWJvdW5jZWRFdmVudCA9IGRlYm91bmNlKCgpID0+IGVtaXQodGhpcywgXCJhZnRlcmNoYW5uZWxzZGVsZXRlZFwiKSwgNTAwKSxcbiAgICAgICAgICAgIGRlbGV0ZUNhbGxiYWNrID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LmdldENoYW5uZWxzQnlUeXBlKHR5cGUpLnRoZW4oKGNoYW5uZWxzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNoYW5uZWxzLmxlbmd0aCA+IDAgJiYgcHJvdmlkZXJzW3R5cGVdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc1t0eXBlXS51cGRhdGVSZXF1ZXN0KGNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc1t0eXBlXS5yZW1vdmVSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZFR5cGVzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VkRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IENoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMuX2xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbGwgdGhlIHF1ZXVlZCB1cCBwcm9taXNlcy5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goKHIpID0+IHIoKSk7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGlzdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbm5lbHNhZGRlZFwiLCAoeyBkZXRhaWw6IGNoYW5uZWxzIH0pID0+IHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB3ZSBhbHdheXMgb25seSBnZXQgYW4gYXJyYXkgb2YgY2hhbm5lbHMgd2l0aCB0aGUgc2FtZSB0eXBlLlxuICAgICAgICAgICAgaWYocHJvdmlkZXJzW2NoYW5uZWxzWzBdLnR5cGVdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LmdldENoYW5uZWxzQnlUeXBlKGNoYW5uZWxzWzBdLnR5cGUpLnRoZW4oKGNoYW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc1tjaGFuc1swXS50eXBlXS51cGRhdGVSZXF1ZXN0KGNoYW5zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hhbm5lbHMuZm9yRWFjaCgoY2hhbikgPT4gdGhpcy5fbWFuYWdlci5vbkNoYW5uZWxBZGRlZChjaGFuKSk7XG5cbiAgICAgICAgICAgIGVtaXQodGhpcywgXCJjaGFubmVsc2FkZGVkXCIsIGNoYW5uZWxzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInVzZXJhZGRlZFwiLCAoeyBkZXRhaWw6IHVzZXIgfSkgPT4ge1xuICAgICAgICAgICAgaWYocHJvdmlkZXJzW3VzZXIudHlwZV0uc3VwcG9ydHMuZmF2b3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5nZXRVc2Vyc0J5VHlwZSh1c2VyLnR5cGUpLnRoZW4oKHVzZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc1t1c2VyLnR5cGVdLnVwZGF0ZUZhdnNSZXF1ZXN0KHVzZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5vblVzZXJBZGRlZCh1c2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWNoYW5uZWxkZWxldGVkXCIsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgICBlbWl0KHRoaXMsIFwiYmVmb3JlY2hhbm5lbGRlbGV0ZWRcIiwgZGV0YWlsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5uZWxkZWxldGVkXCIsICh7IGRldGFpbDogY2hhbm5lbCB9KSA9PiB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogWWVhaCwgdGhpcyBpcyBhIGJpdCBjb25mdXNpbmcsIGJ1dCB0aGF0J3Mgd2h5IHRoZXJlIGFyZVxuICAgICAgICAgICAgICogY29tbWVudHMgZXhwbGFpbmluZyBpdC4gU28gc29tZXRpbWVzIG11bHRpcGxlIGNoYW5uZWxzIGdldFxuICAgICAgICAgICAgICogZGVsZXRlZCBhdCBvbmNlIC0gdGhlIGNoYW5uZWxzIG1hbmFnZXIgc3VwcG9ydHMgbXVsdGktc2VsZWN0c1xuICAgICAgICAgICAgICogQnV0IHRoZXkgYXJlbid0IG9mIHRoZSBzYW1lIHR5cGUuIFNvIHdoYXQgd2Ugd2FudCB0byBkbywgaXNcbiAgICAgICAgICAgICAqIGNhbGwgdGhlIHVucXVldWVSZXF1ZXN0KCkgZm9yIGVhY2ggcHJvdmlkZXIgZXhhY3RseSBvbmNlLlxuICAgICAgICAgICAgICogVG8gZG8gc28sIHdlIGhhdmUgdG8gbWFrZSBzdXJlLCBpdCBvbmx5IGdldHMgY2FsbGVkIGZvciB0aGVcbiAgICAgICAgICAgICAqIGxhc3QgZGVsZXRlZCBjaGFubmVsIG9mIGEgdHlwZS4gaW52b2tlT25jZSBtYWtlcyBzdXJlIG9ubHlcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIGxhc3QgXCJpbnZva2VyXCIgb2YgaW52b2tlT25jZSBpcyBjYWxsaW5nIGl0LCB0aGVcbiAgICAgICAgICAgICAqIG1ldGhvZCBnZXRzIGV4ZWN1dGVkLiBTaW5jZSB3ZSBoYXZlIG11bHRpcGxlIHR5cGVzLCB0aGVyZSBpc1xuICAgICAgICAgICAgICogYSBtYXAsIHN0b3JpbmcgdGhlIGNhbGxiYWNrIGludm9rZU9uY2UgY2FsbHMgZm9yIGVhY2ggdHlwZS5cbiAgICAgICAgICAgICAqIEFuZCB0aGF0J3MgYWxsIHRoZXJlIGlzIHRvIGl0LiBKdXN0IHRvIHJlZHVjZSByZXF1ZXVlaW5nXG4gICAgICAgICAgICAgKiBzdHVmZi4gTm93IHdoeSBzaG91bGQgb25seSB0aGUgbGFzdCBvbmUgZ2V0IGludm9rZWQ/XG4gICAgICAgICAgICAgKiBCZWNhdXNlIGdldENoYW5uZWxzQnlUeXBlIGlzIGFzeW5jLCBhbmQgaW4gdGhlIHdvcnN0IGNhc2UsXG4gICAgICAgICAgICAgKiB0aGUgb25lIHdpdGhvdXQgY2hhbm5lbHMgdG8gcmV0dXJuIHJldHVybnMgZmlyc3QsIHdoaWNoIG1lYW5zXG4gICAgICAgICAgICAgKiBhbiB1cGRhdGUgcmVxdWVzdHMgd2l0aCBjaGFubmVscyB0aGF0IHdlcmUgZGVsZXRlZCB3b3VsZCBiZVxuICAgICAgICAgICAgICogcXVldWVkLCB3aGljaCB3b3VsZCBsZWFkIHRvIHRoZW0gYmVpbmcgcmVhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgICAgICAgICAqIFNvIHRoaXMgaXMgYWxsIHRvdGFsbHkgbmVlZGVkLCBlc3BlY2lhbGx5IHRoZSBsZW5ndGggb2YgdGhpc1xuICAgICAgICAgICAgICogdmVyeSBjb21tZW50IGlzIGNydWNpYWwgdG8gdGhlIG9wZXJhdGlvbi4gRm9yIG1vcmUgbG9uZ1xuICAgICAgICAgICAgICogY29tbWVudHMsIGV4cGxhaW5pbmcgc3R1ZmYsIGNoZWNrIG91dCB0aGUgbGliL3V0aWxzIG1vZHVsZSxcbiAgICAgICAgICAgICAqIHdoZXJlIGludm9rZU9uY2UgaXMga2luZCBvZiBleHBsYWluZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmKCFkZWxldGVkVHlwZXMuaGFzKGNoYW5uZWwudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVkVHlwZXMuc2V0KGNoYW5uZWwudHlwZSwgcGFydGlhbChkZWxldGVDYWxsYmFjaywgY2hhbm5lbC50eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnZva2VPbmNlKGNoYW5uZWwuaWQsIGRlbGV0ZWRUeXBlcy5nZXQoY2hhbm5lbC50eXBlKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIub25DaGFubmVsUmVtb3ZlZChjaGFubmVsLmlkKTtcblxuICAgICAgICAgICAgZW1pdCh0aGlzLCBcImNoYW5uZWxkZWxldGVkXCIsIGNoYW5uZWwuaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGlzdC5hZGRFdmVudExpc3RlbmVyKFwidXNlcmRlbGV0ZWRcIiwgKHsgZGV0YWlsOiB1c2VyIH0pID0+IHtcbiAgICAgICAgICAgIC8qIG5vdCBkb2luZyB0aGUgc2FtZSBtYXNzIGRlbGV0aW9uIHN0dWZmIGFzIGZvciBjaGFubmVscywgYXMgSVxuICAgICAgICAgICAgICAgYXNzdW1lIHRoZXJlIGFyZSBsZXNzIHVzZXJzIGFuZCBpdCdkIG1lc3MgdXAgdGhlIHF1ZXVlJ3MgcGF1c2luZyxcbiAgICAgICAgICAgICAgIGlmIGEgdXNlciBpcyByZW1vdmVkIGJlY2F1c2UgYSBjaGFubmVsIHdhcyBkZWxldGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZihwcm92aWRlcnNbdXNlci50eXBlXS5zdXBwb3J0cy5mYXZvcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LmdldFVzZXJzQnlUeXBlKHVzZXIudHlwZSkudGhlbigodXNlcnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYodXNlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzW3VzZXIudHlwZV0udXBkYXRlRmF2c1JlcXVlc3QodXNlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzW3VzZXIudHlwZV0ucmVtb3ZlRmF2c1JlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLm9uVXNlclJlbW92ZWQodXNlci5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFubmVsdXBkYXRlZFwiLCAoeyBkZXRhaWw6IGNoYW5uZWwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5vbkNoYW5uZWxVcGRhdGVkKGNoYW5uZWwpO1xuXG4gICAgICAgICAgICBlbWl0KHRoaXMsIFwiY2hhbm5lbHVwZGF0ZWRcIiwgY2hhbm5lbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ1c2VydXBkYXRlZFwiLCAoeyBkZXRhaWwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5vblVzZXJVcGRhdGVkKGRldGFpbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKnRoaXMuX2xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsZWFyXCIsICh7IGRldGFpbDogaGFyZCB9KSA9PiB7XG4gICAgICAgICAgICBpZihoYXJkKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPIHN3YXAgb3V0IHRoZSBwYW5lbCBhbmQgd2FybmluZyBzdGF0ZSBvbiB0aGUgYnV0dG9uXG4gICAgICAgICAgICAgICAgc2hvd05vdGlmaWNhdGlvbkJveCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcImp0dm4tZGJlcmFzZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IF8oXCJsb3N0X2NoYW5uZWxzXCIpLFxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogXCJXQVJOSU5HX0hJR0hcIixcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2U6IDEwLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogc2VsZi5kYXRhLnVybChcIi4vaWNvbjE4LnBuZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBfKFwibWFuYWdlQ2hhbm5lbHNfbGFiZWxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gdGhpcy5zaG93TWFuYWdlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInVuZml4YWJsZWVycm9yXCIsICgpID0+IHtcbiAgICAgICAgICAgIC8vVE9ETyBzd2FwIG91dCBwYW5lbCBhbmQgYWRkIHdhcm5pbmcgc3RhdGUgdG8gYnV0dG9uXG4gICAgICAgICAgICBzaG93Tm90aWZpY2F0aW9uQm94KHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJqdHZuLXJlc3RvcmVmYWlsZWRcIixcbiAgICAgICAgICAgICAgICBsYWJlbDogXyhcInJlc3RvcmVfZmFpbGVkXCIpLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBcIkNSSVRJQ0FMX0xPV1wiLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RlbmNlOiAxMCxcbiAgICAgICAgICAgICAgICBpbWFnZTogc2VsZi5kYXRhLnVybChcIi4vb2ZmbGluZTE4LnBuZ1wiKSxcbiAgICAgICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBfKFwicmVzdG9yZV9hY3Rpb25cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0YWJzLm9wZW4oeyB1cmw6IFJFRlJFU0hfUFJPRklMRV9VUkwgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsqL1xuICAgICAgICAvLyBQcm92aWRlciB1cGRhdGUgZXZlbnRzXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIG1vZHVsZTpwcm92aWRlcnMvZXZlbnRzLkV2ZW50U2lua1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXZlbnRTaW5rID0gbmV3IEV2ZW50U2luaygpO1xuICAgICAgICB0aGlzLl9ldmVudFNpbmsuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWR1c2VyXCIsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9saXN0LnNldFVzZXIoZGV0YWlsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2V2ZW50U2luay5hZGRFdmVudExpc3RlbmVyKFwibmV3Y2hhbm5lbHNcIiwgKHsgZGV0YWlsOiBjaGFubmVscyB9KSA9PiB7XG4gICAgICAgICAgICBjaGFubmVscyA9IGZpbHRlckluYXByb3ByaWF0ZUNoYW5uZWxzKGNoYW5uZWxzKTtcbiAgICAgICAgICAgIGlmKGNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LmFkZENoYW5uZWxzKGNoYW5uZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2V2ZW50U2luay5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZGNoYW5uZWxzXCIsICh7IGRldGFpbDogY2hhbm5lbHMgfSkgPT4ge1xuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShjaGFubmVscykpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB0aGlzLl9saXN0LnNldENoYW5uZWwoY2hhbm5lbCkuY2F0Y2goKCkgPT4gdGhpcy5fbGlzdC5hZGRDaGFubmVsKGNoYW5uZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnNldENoYW5uZWwoY2hhbm5lbHMpLmNhdGNoKCgpID0+IHRoaXMuX2xpc3QuYWRkQ2hhbm5lbChjaGFubmVscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0NiID0gKGNoYW5uZWxzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc1tjaGFubmVsc1swXS50eXBlXS51cGRhdGVSZXF1ZXN0KGNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlcnNDYiA9ICh1c2VycykgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHVzZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnNbdXNlcnNbMF0udHlwZV0udXBkYXRlRmF2c1JlcXVlc3QodXNlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZm9yKGNvbnN0IHAgaW4gcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpZihwcm92aWRlcnNbcF0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2hhbm5lbHNCeVR5cGUocCkudGhlbihjaGFubmVsc0NiKTtcbiAgICAgICAgICAgICAgICBpZihwcm92aWRlcnNbcF0uc3VwcG9ydHMuZmF2b3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VXNlcnNCeVR5cGUocCkudGhlbih1c2Vyc0NiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhcyBzb29uIGFzIHRoZSBDaGFubmVsTGlzdCBpcyByZWFkeS5cbiAgICAgKiBBbm90aGVyIG1ldGhvZCBpbiB0aGlzIG1vZHVsZSB0aGF0IG1ha2VzIG1hZ2ljIGhhcHBlbi4uLlxuICAgICAqIFRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggYWxsIHRoZSBhcmd1bWVudHMgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gYXJncyAtIEFyZ3VtZW50cyB0byB0aGUgY2FsbGJhY2suXG4gICAgICogQGFzeW5jXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIF9lbnN1cmVRdWV1ZVJlYWR5KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYoIXRoaXMuX3JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMuX3F1ZXVlLnB1c2gocGFydGlhbChyZXNvbHZlLCAuLi5hcmdzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRldGFpbHMgb2YgYSBjaGFubmVsIGFuZCBzdG9yZSB0aGVtIGluIHRoZSBDaGFubmVsTGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVXNlcm5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZS9wcm92aWRlciBvZiB0aGUgY2hhbm5lbCB0byBhZGQuXG4gICAgICogQHBhcmFtIHtGdW50aW9ufSBbY2FuY2VsZWQ9KCkgPT4gZmFsc2VdIC0gQ2FuY2VsaW5nIGNoZWNrZXIuXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gUmVzdWx0aW5nIGNoYW5uZWwgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIHByb3ZpZGVyIGlzIGRpc2FibGVkLlxuICAgICAqIEB0aHJvd3MgSWYgcGFyZW50YWwgY29udHJvbHMgYXJlIGVuYWJsZWQgYW5kIHRoZSBjaGFubmVsIGlzIG1hcmtlZCBtYXR1cmUuXG4gICAgICogQHRocm93cyBJZiB0aGUgYWN0aW9uIGlzIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZENoYW5uZWwobmFtZSwgdHlwZSwgY2FuY2VsZWQgPSAoKSA9PiBmYWxzZSkge1xuICAgICAgICBpZih0eXBlIGluIHByb3ZpZGVycyAmJiBwcm92aWRlcnNbdHlwZV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IHByb3ZpZGVyc1t0eXBlXS5nZXRDaGFubmVsRGV0YWlscyhuYW1lKTtcbiAgICAgICAgICAgIGlmKFBhcmVudGFsQ29udHJvbHMuZW5hYmxlZCAmJiBjaGFubmVsLm1hdHVyZSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiTm90IGFsbG93ZWQgdG8gYWRkIHRoaXMgY2hhbm5lbFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbnN1cmVRdWV1ZVJlYWR5KCk7XG5cbiAgICAgICAgICAgIGlmKGNhbmNlbGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbmNlbGVkXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0LmFkZENoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIlByb3ZpZGVyIGlzIGRpc2FibGVkXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgY2hhbm5lbCBhbmQgc3RvcmUgaXQgaW4gdGhlIENoYW5uZWxMaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJZCAtIElEIG9mIHRoZSBjaGFubmVsIHRvIHVwZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsP30gVXBkYXRlZCBjaGFubmVsIG9iamVjdC4gTWF5IGJlXG4gICAgICogICAgICAgICAgbnVsbCBpZiB0aGUgcHJvdmlkZXIgaXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ2hhbm5lbChjaGFubmVsSWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5zdXJlUXVldWVSZWFkeSgpO1xuICAgICAgICBsZXQgY2hhbm5lbCA9IGF3YWl0IHRoaXMuX2xpc3QuZ2V0Q2hhbm5lbChjaGFubmVsSWQpO1xuICAgICAgICBpZighcHJvdmlkZXJzW2NoYW5uZWwudHlwZV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFubmVsID0gYXdhaXQgcHJvdmlkZXJzW2NoYW5uZWwudHlwZV0udXBkYXRlQ2hhbm5lbChjaGFubmVsLmxvZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3Quc2V0Q2hhbm5lbChjaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYW5uZWxzIGJ5IHByb3ZpZGVyLiBEb2Vzbid0IHVwZGF0ZSBpZiB0aGUgcHJvdmlkZXIgaXMgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVyPW51bGxdIC0gVHlwZSBvZiBjaGFubmVscyB0byB1cGRhdGUuIEFsbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVscyBhcmUgdXBkYXRlZCBpZiBsZWZ0IG91dC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD58bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfVxuICAgICAqICAgICAgICAgIExpc3Qgb2YgdXBkYXRlZCBjaGFubmVsIG9iamVjdHMsIGlmIG11bHRpcGxlIHdlcmUgdXBkYXRlZCwgZWxzZVxuICAgICAqICAgICAgICAgIG9iamVjdCBvZiB0aGUgdXBkYXRlZCBjaGFubmVsLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUNoYW5uZWxzKHByb3ZpZGVyID0gbnVsbCkge1xuICAgICAgICBpZihwcm92aWRlciA9PT0gbnVsbCB8fCAhKHByb3ZpZGVyIGluIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcm92aWRlcnMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocCkgPT4gcHJvdmlkZXJzW3BdLmVuYWJsZWQpXG4gICAgICAgICAgICAgICAgLm1hcCh0aGlzLnVwZGF0ZUNoYW5uZWxzLmJpbmQodGhpcykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocHJvdmlkZXJzW3Byb3ZpZGVyXS5lbmFibGVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbnN1cmVRdWV1ZVJlYWR5KCk7XG4gICAgICAgICAgICBsZXQgY2hhbm5lbHMgPSBhd2FpdCB0aGlzLl9saXN0LmdldENoYW5uZWxzQnlUeXBlKHByb3ZpZGVyKTtcblxuICAgICAgICAgICAgaWYoY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHMgPSBhd2FpdCBwcm92aWRlcnNbcHJvdmlkZXJdLnVwZGF0ZUNoYW5uZWxzKGNoYW5uZWxzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShjaGFubmVscykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2hhbm5lbHMubWFwKHRoaXMuX2xpc3Quc2V0Q2hhbm5lbC5iaW5kKHRoaXMuX2xpc3QpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdC5zZXRDaGFubmVsKGNoYW5uZWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJZCAtIElEIG9mIHRoZSBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IENoYW5uZWwgaW5zdGFuY2UuXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbChjaGFubmVsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVF1ZXVlUmVhZHkoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fbGlzdC5nZXRDaGFubmVsKGNoYW5uZWxJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbXVsdGlwbGUgY2hhbm5lbHMgYnkgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVyPW51bGxdIC0gVHlwZSBvZiB0aGUgY2hhbm5lbHMgdG8gcmV0dXJuLiBJZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IG91dCwgYWxsIGNoYW5uZWxzIGFyZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59IExpc3Qgb2YgY2hhbm5lbHMgd2l0aCBmb3JcbiAgICAgKiAgICAgICAgICB0aGUgZ2l2ZW4gdHlwZS9wcm92aWRlci5cbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsc0J5VHlwZShwcm92aWRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVF1ZXVlUmVhZHkoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fbGlzdC5nZXRDaGFubmVsc0J5VHlwZShwcm92aWRlcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjaGFubmVsIGZyb20gdGhlIENoYW5uZWxMaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJZFxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IFJlbW92ZWQgY2hhbm5lbC5cbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICByZW1vdmVDaGFubmVsKGNoYW5uZWxJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5zdXJlUXVldWVSZWFkeSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLl9saXN0LnJlbW92ZUNoYW5uZWwoY2hhbm5lbElkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHVzZXIgYW5kIGl0cyBmYXZvcml0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgLSBVc2VybmFtZSBvZiB0aGUgdXNlciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUeXBlL3Byb3ZpZGVyIG9mIHRoZSB1c2VyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FuY2VsZWQ9KCkgPT4gZmFsc2VdIC0gQ2FuY2VsaW5nIGNoZWNrZXIuXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn0gQW4gYXJyYXkgd2l0aCB0aGUgYWRkZWQgdXNlciBhbmQgYW4gYXJyYXkgb2YgYWRkZWRcbiAgICAgKiAgICAgICAgICBjaGFubmVscy5cbiAgICAgKiBAdGhyb3dzIEdldHMgcmVqZWN0ZWQgaWYgdGhlIHByb3ZpZGVyIGRvZXNuJ3Qgc3VwcG9ydCBmYXZvcml0ZXMuXG4gICAgICogQHRocm93cyBXaGVuIHRoZSBhY3Rpb24gaXMgY2FuY2VsZWQuXG4gICAgICovXG4gICAgYXN5bmMgYWRkVXNlcih1c2VybmFtZSwgdHlwZSwgY2FuY2VsZWQgPSAoKSA9PiBmYWxzZSkge1xuICAgICAgICBpZih0eXBlIGluIHByb3ZpZGVycyAmJiBwcm92aWRlcnNbdHlwZV0uc3VwcG9ydHMuZmF2b3JpdGVzKSB7XG4gICAgICAgICAgICBsZXQgWyB1c2VyLCBjaGFubmVscyBdID0gYXdhaXQgcHJvdmlkZXJzW3R5cGVdLmdldFVzZXJGYXZvcml0ZXModXNlcm5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW5zdXJlUXVldWVSZWFkeSgpO1xuXG4gICAgICAgICAgICBpZihjYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYW5jZWxlZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihQYXJlbnRhbENvbnRyb2xzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVscyA9IGNoYW5uZWxzLmZpbHRlcigoYykgPT4gIWMubWF0dXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgWyB1IF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5hZGRVc2VyKHVzZXIpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QuYWRkQ2hhbm5lbHMoZmlsdGVySW5hcHJvcHJpYXRlQ2hhbm5lbHMoY2hhbm5lbHMpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2FuJ3QgYWRkIHVzZXJzIGZvciBwcm92aWRlciBcIiArIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn0gdXNlciAtIFVzZXIgaW5zdGFuY2UgdG8gdXBkYXRlLlxuICAgICAqIEBhc3luY1xuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IFVwZGF0ZWQgdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyBfdXBkYXRlVXNlcih1c2VyKSB7XG4gICAgICAgIGNvbnN0IFsgdXBkYXRlZFVzZXIsIGNoYW5uZWxzIF0gPSBhd2FpdCBwcm92aWRlcnNbdXNlci50eXBlXS5nZXRVc2VyRmF2b3JpdGVzKHVzZXIubG9naW4pLFxuICAgICAgICAgICAgWyBmaW5hbFVzZXIgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnNldFVzZXIodXBkYXRlZFVzZXIpLFxuICAgICAgICAgICAgICAgIC8vIENhbid0IGp1c3QgY2FsbCB0aGlzLmFkZFVzZXIodXNlci5sb2dpbiwgdXNlci50eXBlKSBiZWNhdXNlIG9mIHRoaXMuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5hZGRDaGFubmVscyhmaWx0ZXJJbmFwcm9wcmlhdGVDaGFubmVscyhmaWx0ZXJFeGlzdGluZ0ZhdnModXNlciwgY2hhbm5lbHMpKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gZmluYWxVc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSB1c2VyIG9yIGFsbCB1c2VycyBhbmQgYWRkIGFueSBuZXcgZmF2b3JpdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VySWRdIC0gSUQgb2YgdGhlIHVzZXIsIGlmIG5vdCBzcGVjaWZpZWQgdXBkYXRlc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbCB1c2Vycy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcj59IFVwZGF0ZWQgdXNlciBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXNlcih1c2VySWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5zdXJlUXVldWVSZWFkeSgpO1xuICAgICAgICBsZXQgdXNlcnM7XG4gICAgICAgIGlmKHVzZXJJZCkge1xuICAgICAgICAgICAgdXNlcnMgPSBbIChhd2FpdCB0aGlzLl9saXN0LmdldFVzZXIodXNlcklkKSkgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZXJzID0gYXdhaXQgdGhpcy5nZXRVc2Vyc0J5VHlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgdXNlcnMuZmlsdGVyKCh1c2VyKSA9PiBwcm92aWRlcnNbdXNlci50eXBlXS5zdXBwb3J0cy5mYXZvcml0ZXMpXG4gICAgICAgICAgICAubWFwKHRoaXMuX3VwZGF0ZVVzZXIuYmluZCh0aGlzKSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB1c2VycyBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvdmlkZXI9bnVsbF0gLSBUeXBlIHRoZSB1c2VycyBzaG91bGQgYmUgb2YuIElmXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb21pdHRlZCBhbGwgdXNlcnMgYXJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyPn0gVXNlciBpbnN0YW5jZXMgZm9yIHRoZSBnaXZlblxuICAgICAqICAgICAgICAgIHR5cGUvcHJvdmlkZXIuXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgZ2V0VXNlcnNCeVR5cGUocHJvdmlkZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVRdWV1ZVJlYWR5KClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuX2xpc3QuZ2V0VXNlcnNCeVR5cGUocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdXNlciBmcm9tIHRoZSBDaGFubmVsTGlzdCBhbmQgb3B0aW9uYWxseSByZW1vdmUgdGhlIGNoYW5uZWxzIGl0XG4gICAgICogZmF2b3JpdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVzZXJJZCAtIElEIG9mIHRoZSB1c2VyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVGYXZvcml0ZXM9ZmFsc2VdIC0gQWxzbyByZW1vdmUgZmF2b3JpdGVkIGNoYW5uZWxzXG4gICAgICogICAgICAgIG9mIHRoZSB1c2VyLlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IFJlbW92ZWQgdXNlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVVc2VyKHVzZXJJZCwgcmVtb3ZlRmF2b3JpdGVzID0gZmFsc2UpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5zdXJlUXVldWVSZWFkeSgpO1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBpZihyZW1vdmVGYXZvcml0ZXMpIHtcbiAgICAgICAgICAgIHAgPSB0aGlzLl9saXN0LnJlbW92ZUNoYW5uZWxzQnlVc2VyRmF2b3JpdGVzKHVzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWyB1IF0gPSBhd2FpdCBQcm9taXNlLmFsbChbIHRoaXMuX2xpc3QucmVtb3ZlVXNlcih1c2VySWQpLCBwIF0pO1xuICAgICAgICByZXR1cm4gdTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXIgLSBQcm92aWRlci90eXBlIHRvIGFkZCBjcmVkZW50aWFscyBmb3IuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY3JlZGVudGlhbHMgLSBSZXN1bHRpbmcgY3JlZGVudGlhbHMgZnJvbSBhIHNlYXJjaC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcj59IEFkZGVkIHVzZXIgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIF9hZGRGb3VuZENyZWRlbnRpYWxzKHByb3ZpZGVyLCBjcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY3JlZGVudGlhbHMuZmlsdGVyKChjcmVkZW50aWFsKSA9PiBjcmVkZW50aWFsLnVzZXJuYW1lKS5tYXAoKGNyZWRlbnRpYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBhIGNyZWRlbnRpYWwgZm9yICR7cHJvdmlkZXJ9IHVzZXIgJHtjcmVkZW50aWFsLnVzZXJuYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVXNlcihjcmVkZW50aWFsLnVzZXJuYW1lLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXIgLSBQcm92aWRlciB0byBzZWFyY2ggZm9yIHVzZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBVUkwgdG8gc2VhcmNoIGZvciBjcmVkZW50aWFscyBmb3IuXG4gICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXI+fSBVc2VycyBmb3VuZCBmb3IgdGhlIGdpdmVuIHVybC5cbiAgICAgKi9cbiAgICBfZmluZFVzZXJzQnlVUkwocHJvdmlkZXIsIHVybCkge1xuICAgICAgICByZXR1cm4gbG9naW5zLnNlYXJjaCh7IHVybCB9KVxuICAgICAgICAgICAgLnRoZW4odGhpcy5fYWRkRm91bmRDcmVkZW50aWFscy5iaW5kKHRoaXMsIHByb3ZpZGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB1c2VycyB0aGF0IGhhdmUgc3RvcmVkIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcm92aWRlcl0gLSBQcm92aWRlciB0byBhZGQgdXNlcnMgc3RvcmVkIGluIHRoZVxuICAgICAqIGNyZWRlbnRpYWxzIGZvci4gSWYgbm90IHByb3ZpZGVkLCBhbGwgcHJvdmlkZXJzIGFyZSBzZWFyY2hlZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn0gVXNlcnMgYWRkZWQgYmFzZWQgb24gc2F2ZWRcbiAgICAgKiAgICAgICAgICBjcmVkZW50aWFscy5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZyB1c2VycyBiYXNlZCBvbiBjcmVkZW50aWFscy5cbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhdXRvQWRkVXNlcnMocHJvdmlkZXIpIHtcbiAgICAgICAgaWYoIXByb3ZpZGVyIHx8ICEocHJvdmlkZXIgaW4gcHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHByb3ZpZGVycylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChwKSA9PiBwcm92aWRlcnNbcF0uc3VwcG9ydHMuY3JlZGVudGlhbHMpXG4gICAgICAgICAgICAgICAgLm1hcCh0aGlzLmF1dG9BZGRVc2Vycy5iaW5kKHRoaXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwcm92aWRlcnNbcHJvdmlkZXJdLnN1cHBvcnRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2VhcmNoaW5nIGxvZ2luIG5hbWUgZm9yICR7cHJvdmlkZXJ9YCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvdmlkZXJzW3Byb3ZpZGVyXS5hdXRoVVJMLm1hcCh0aGlzLl9maW5kVXNlcnNCeVVSTC5iaW5kKHRoaXMsIHByb3ZpZGVyKSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oZmxhdHRlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYFByb3ZpZGVyICR7cHJvdmlkZXJ9IGRvZXMgbm90IHN1cHBvcnQgYXV0byBhZGRpbmcgdXNlcnNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBvciBmb2N1ZXNlcyBhIHRhYiB3aXRoIHRoZSBtYW5hZ2VyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBzaG93TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hbmFnZXIub3BlbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGhlbWUgb2YgdGhlIGNoYW5uZWwgbWFuYWdlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aGVtZSAtIFRoZW1lIElEIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVF1ZXVlUmVhZHkoKS50aGVuKCgpID0+IHRoaXMuX21hbmFnZXIuc2V0VGhlbWUodGhlbWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHN0cmVhbSBVUkwgb2YgdGhlIGdpdmVuIGNoYW5uZWwgdG8gdGhlIGNsaXBib2FyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWQgLSBJRCBvciBsb2dpbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVHlwZSBpZiBub3QgYW4gSUQgaXMgZ2l2ZW4uXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBhc3luYyBjb3B5Q2hhbm5lbFVSTChpZCwgdHlwZSkge1xuICAgICAgICBsZXQgY2hhbm5lbDtcbiAgICAgICAgaWYodHlwZSkge1xuICAgICAgICAgICAgaWYoISh0eXBlIGluIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlNwZWNpZmllZCB0eXBlIGlzIG5vdCBrbm93blwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFubmVsID0gYXdhaXQgcHJvdmlkZXJzW3R5cGVdLnVwZGF0ZUNoYW5uZWwoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbm5lbCA9IGF3YWl0IHRoaXMuX2xpc3QuZ2V0Q2hhbm5lbChpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cmwgPSBjaGFubmVsLmxpdmUuYWx0ZXJuYXRlVVJMID8gY2hhbm5lbC5saXZlLmFsdGVybmF0ZVVSTCA6IGNoYW5uZWwudXJsWzBdLFxuICAgICAgICAgICAgcCA9IHdoZW4oZG9jdW1lbnQsIFwiY29weVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgY29uc3QgWyBlLCBwYXR0ZXJuIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgcHJlZnMuZ2V0KFwiY29weV9wYXR0ZXJuXCIpXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBwYXR0ZXJuLnJlcGxhY2UoXCJ7VVJMfVwiLCB1cmwpKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvY29udHJvbGxlci5qcyIsIi8qKlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBtb2R1bGUgY2hhbm5lbC91dGlsc1xuICovXG5cbi8qKlxuICogT3BlbnMgdGhlIGdpdmVuIGNoYW5uZWwgaW4gYSBuZXcgdGFiLCB1bmxlc3MgdGhlcmUgaXMgYWxyZWFkeSBhIHRhYiBvcGVuIGZvclxuICogaXQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgY2hhbm5lbCB0byBvcGVuLlxuICogQHBhcmFtIHtzdHJpbmd9IFt3aGF0XSAtIFNwZWNpZmllcyB0aGUgYWN0aW9uIHRvIHRha2UuIFwiY2hhdFwiIG9wZW5zIHRoZVxuICogICAgICAgICBjaGFubmVsJ3MgY2hhdCwgXCJhcmNoaXZlXCIgb3BlbnMgdGhlIGFyY2hpdmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyP30gVGhlIGNoYW5uZWwgc2hvdWxkIG5vdyBiZSB2aXNpYmxlIGZvciB0aGUgdXNlci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbGVjdE9yT3BlblRhYihjaGFubmVsLCB3aGF0KSB7XG4gICAgbGV0IHRvQ2hlY2sgPSBbXTtcblxuICAgIGlmKHdoYXQgPT09IFwiY2hhdFwiKSB7XG4gICAgICAgIHRvQ2hlY2sucHVzaChjaGFubmVsLmNoYXRVcmwpO1xuICAgIH1cbiAgICBlbHNlIGlmKHdoYXQgPT09IFwiYXJjaGl2ZVwiIHx8ICFjaGFubmVsLmxpdmUuaXNMaXZlKCkpIHtcbiAgICAgICAgdG9DaGVjay5wdXNoKGNoYW5uZWwuYXJjaGl2ZVVybCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b0NoZWNrID0gY2hhbm5lbC51cmw7XG5cbiAgICAgICAgaWYod2hhdCA9PT0gXCJsaXZlc3RyZWFtZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgXCJOb3Qgc3VwcG9ydGVkXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0YWJzID0gYXdhaXQgYnJvd3Nlci50YWJzLnF1ZXJ5KHtcbiAgICAgICAgdXJsOiB0b0NoZWNrXG4gICAgfSk7XG4gICAgaWYodGFicy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGJyb3dzZXIudGFicy51cGRhdGUodGFic1swXS5pZCwge1xuICAgICAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIG5vIHRhYiBvcGVuIGZvciB0aGUgY2hhbm5lbFxuICAgIHJldHVybiBicm93c2VyLnRhYnMuY3JlYXRlKHsgdXJsOiB0b0NoZWNrWzBdIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvY2hhbm5lbC91dGlscy5qcyIsIi8qKlxuICogTW9kZWwgZm9yIHRoZSBQYW5lbC5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBsaXN0XG4gKiBAcmVxdWlyZXMgbW9kdWxlOmNoYW5uZWwvdXRpbHNcbiAqIEByZXF1aXJlcyBtb2R1bGU6bGlzdC9maXJlZm94XG4gKiBAdG9kbyBjb3V0bmVyIGJhZGdlIHZzLiBsaXZlIHN0YXRlIGhhbmRsaW5nIGNoYW5nZVxuICovXG4vLyBzZXR1cCBldmVudCBoYW5kbGluZ1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IHByZWZzIGZyb20gXCIuL3ByZWZlcmVuY2VzXCI7XG5pbXBvcnQgTGl2ZVN0YXRlIGZyb20gXCIuL2NoYW5uZWwvbGl2ZS1zdGF0ZVwiO1xuaW1wb3J0IHByb3ZpZGVycyBmcm9tICcuL3Byb3ZpZGVycyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnZXZlbnQtdGFyZ2V0LXNoaW0nO1xuXG4vKipcbiAqIFNob3VsZCBvcGVuIHRoZSBDaGFubmVsc01hbmFnZXIuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpsaXN0Lkxpc3RWaWV3I29wZW5jbVxuICovXG4vKipcbiAqIFBhc3NlcyB0d28gYXJndW1lbnRzOiB0eXBlIGFuZCBsb2dpbiBvZiB0aGUgY2hhbm5lbCB0byBhZGQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpsaXN0Lkxpc3RWaWV3I2FkZGNoYW5uZWxcbiAqL1xuLyoqXG4gKiBUaGUgdXNlciB0cmlnZ2VyZWQgYSBtYW51YWwgcmVmcmVzaCBmcm9tIHRoZSBsaXN0LiBPcHRpb25hbGx5IGhvbGRzIHRoZSBJRCBvZlxuICogdGhlIGNoYW5uZWwgdG8gdXBkYXRlLCBlbHNlIGFsbCBjaGFubmVscyBhcmUgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmxpc3QuTGlzdFZpZXcjcmVmcmVzaFxuICogQHR5cGUge251bWJlcj99XG4gKi9cbi8qKlxuICogVGhlIHVzZXIgd2lzaGVzIHRvIG9wZW4gdGhlIGEgY2hhbm5lbCBieSBhcHByb3JpYXRlIG1lYW5zLiBUaGUgc2Vjb25kXG4gKiBwYXJhbWV0ZXIgc3BlY2lmaWVzIHRoZSBtZWFucywgbGlrZSB0aGUgXCJ3aGF0XCIgcGFyYW1ldGVyIG9mXG4gKiB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvdXRpbHMuc2VsZWN0T3JPcGVuVGFifS5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmxpc3QuTGlzdFZpZXcjb3BlblxuICogQHR5cGUge251bWJlcn1cbiAqL1xuLyoqXG4gKiBUaGUgdXNlciB3aXNoZXMgdG8gcGF1c2UgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmxpc3QuTGlzdFZpZXcjcGF1c2VcbiAqL1xuLyoqXG4gKiBUaGUgdXNlciB3aXNoZXMgdG8gcmVzdW1lIHRoZSB1cGRhdGUgcXVldWUuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpsaXN0Lkxpc3RWaWV3I3Jlc3VtZVxuICovXG4vKipcbiAqIFRoZSBsaXN0IGlzIHJlYWR5IGZvciBtb2RpZmljYXRpb25zLlxuICpcbiAqIEBldmVudCBtb2R1bGU6bGlzdC5MaXN0VmlldyNyZWFkeVxuICovXG4vKipcbiAqIEB0eXBlZGVmIFN0eWxlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtudW1iZXJ9IE5vbkxpdmVEaXNwbGF5XG4gKi9cblxuY29uc3QgTElWRV9JQ09OUyA9IHtcbiAgICAgICAgXCIxNlwiOiBcImFzc2V0cy9pbWFnZXMvaWNvbjE2LnBuZ1wiLFxuICAgICAgICBcIjE4XCI6IFwiYXNzZXRzL2ltYWdlcy9pY29uMTgucG5nXCIsXG4gICAgICAgIFwiMzJcIjogXCJhc3NldHMvaW1hZ2VzL2ljb24zMi5wbmdcIixcbiAgICAgICAgXCIzNlwiOiBcImFzc2V0cy9pbWFnZXMvaWNvbjM2LnBuZ1wiLFxuICAgICAgICBcIjQ4XCI6IFwiYXNzZXRzL2ltYWdlcy9pY29uNDgucG5nXCIsXG4gICAgICAgIFwiNjRcIjogXCJhc3NldHMvaW1hZ2VzL2ljb242NC5wbmdcIlxuICAgIH0sXG4gICAgT0ZGTElORV9JQ09OUyA9IHtcbiAgICAgICAgXCIxNlwiOiBcImFzc2V0cy9pbWFnZXMvb2ZmbGluZTE2LnBuZ1wiLFxuICAgICAgICBcIjE4XCI6IFwiYXNzZXRzL2ltYWdlcy9vZmZsaW5lMTgucG5nXCIsXG4gICAgICAgIFwiMzJcIjogXCJhc3NldHMvaW1hZ2VzL29mZmxpbmUzMi5wbmdcIixcbiAgICAgICAgXCIzNlwiOiBcImFzc2V0cy9pbWFnZXMvb2ZmbGluZTM2LnBuZ1wiLFxuICAgICAgICBcIjQ4XCI6IFwiYXNzZXRzL2ltYWdlcy9vZmZsaW5lNDgucG5nXCIsXG4gICAgICAgIFwiNjRcIjogXCJhc3NldHMvaW1hZ2VzL29mZmxpbmU2NC5wbmdcIlxuICAgIH0sXG4gICAgXyA9IGJyb3dzZXIuaTE4bi5nZXRNZXNzYWdlO1xuXG4vKipcbiAqIEBjbGFzcyBtb2R1bGU6bGlzdC5MaXN0Vmlld1xuICogQGV4dGVuZHMgZXh0ZXJuYWw6RXZlbnRUYXJnZXRcbiAqL1xuY2xhc3MgTGlzdFZpZXcgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0IHttb2R1bGU6bGlzdH5TdHlsZX1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhdGljIFNUWUxFX0NPTVBBQ1QgPSAwO1xuICAgIC8qKlxuICAgICAqIEBjb25zdCB7bW9kdWxlOmxpc3R+U3R5bGV9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHN0YXRpYyBTVFlMRV9OT1JNQUwgPSAxO1xuICAgIC8qKlxuICAgICAqIEBjb25zdCB7bW9kdWxlOmxpc3R+U3R5bGV9XG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIHN0YXRpYyBTVFlMRV9USFVNQk5BSUwgPSAyO1xuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBub24tbGl2ZSBjaGFubmVscyBhcyBsaXZlLlxuICAgICAqXG4gICAgICogQGNvbnN0IHttb2R1bGU6bGlzdH5Ob25MaXZlRGlzcGxheX1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhdGljIExJVkUgPSAwO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXkgbm9uLWxpdmUgY2hhbm5lbHMgYXMgbGl2ZSBidXQgc29ydCB0aGVtIHRvIHRoZSBib3R0b20gaWYgcG9zc2libGUuXG4gICAgICogQGNvbnN0IHttb2R1bGU6bGlzdH5Ob25MaXZlRGlzcGxheX1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgc3RhdGljIExJVkVfQk9UVE9NID0gMTtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IG5vbi1saXZlIGNoYW5uZWxzIGluIHRoZWlyIG93biBjYXRlZ29yeS5cbiAgICAgKiBAY29uc3Qge21vZHVsZTpsaXN0fk5vbkxpdmVEaXNwbGF5XG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIHN0YXRpYyBESVNUSU5DVCA9IDI7XG4gICAgLyoqXG4gICAgICogRGlzcGxheSBub24tbGl2ZSBjaGFubmVscyBhcyBvZmZsaW5lIChpZ25vcmUgdGhlaXIgbGl2ZW5lc3MpLiBUaGlzIGlzIGhhbmRsZWRcbiAgICAgKiBkaXJlY3RseSBpbiB0aGlzIG1vZHVsZSwgc28gdGhlIGNoYW5uZWwgZ2V0cyBwYXNzZWQgYXMgZ29pbmcgb2ZmbGluZS5cbiAgICAgKiBAY29uc3Qge21vZHVsZTpsaXN0fk5vbkxpdmVEaXNwbGF5fVxuICAgICAqIEBkZWZhdWx0IDNcbiAgICAgKi9cbiAgICBzdGF0aWMgT0ZGTElORSA9IDM7XG5cbiAgICByZWFkeSA9IGZhbHNlO1xuICAgIHBvcnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RzXG4gICAgICogQGZpcmVzIG1vZHVsZTpsaXN0Lkxpc3RWaWV3I29wZW5jbVxuICAgICAqIEBmaXJlcyBtb2R1bGU6bGlzdC5MaXN0VmlldyNhZGRjaGFubmVsXG4gICAgICogQGZpcmVzIG1vZHVsZTpsaXN0Lkxpc3RWaWV3I3JlYWR5XG4gICAgICogQGZpcmVzIG1vZHVsZTpsaXN0Lkxpc3RWaWV3I29wZW5cbiAgICAgKiBAZmlyZXMgbW9kdWxlOmxpc3QuTGlzdFZpZXcjcmVmcmVzaFxuICAgICAqIEBmaXJlcyBtb2R1bGU6bGlzdC5MaXN0VmlldyNwYXVzZVxuICAgICAqIEBmaXJlcyBtb2R1bGU6bGlzdC5MaXN0VmlldyNyZXN1bWVcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmxpc3QuTGlzdFZpZXdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9saXZlU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXZlID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm5vbmxpdmUgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgYnJvd3Nlci5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcigocG9ydCkgPT4ge1xuICAgICAgICAgICAgaWYocG9ydC5uYW1lID09IFwibGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBQb3J0KHBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcmVmcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoZXZlbnQucHJlZiA9PSBcInBhbmVsX2JhZGdlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJhZGdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgX3NldHVwUG9ydChwb3J0KSB7XG4gICAgICAgIHRoaXMucG9ydCA9IHBvcnQ7XG5cbiAgICAgICAgdGhpcy5zZXROb25MaXZlRGlzcGxheSgpO1xuICAgICAgICB0aGlzLnBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYoZXZlbnQudGFyZ2V0ID09IFwib3BlblVybFwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcIm9wZW5cIiwgZXZlbnQuY2hhbm5lbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0ID09IFwib3BlbkNoYXRcIikge1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJvcGVuXCIsIGV2ZW50LmNoYW5uZWxJZCwgXCJjaGF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQgPT0gXCJvcGVuQXJjaGl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcIm9wZW5cIiwgZXZlbnQuY2hhbm5lbElkLCBcImFyY2hpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldCA9PSBcInJlZnJlc2hcIikge1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJyZWZyZXNoXCIsIGV2ZW50LmNoYW5uZWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldCA9PSBcImNvbmZpZ3VyZVwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcIm9wZW5jbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0ID09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwiYWRkY2hhbm5lbFwiLCBldmVudC50eXBlLCBldmVudC5sb2dpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldCA9PSBcInBhdXNlXCIpIHtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwicGF1c2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldCA9PSBcInJlc3VtZVwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInJlc3VtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0ID09IFwicmVhZHlcIikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJyZWFkeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0ID09IFwic2VhcmNoXCIpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcnNbZXZlbnQudHlwZV0uc2VhcmNoKGV2ZW50LnF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoY2hhbm5lbHMpID0+IHRoaXMuc2V0RmVhdHVyZWQoY2hhbm5lbHMubWFwKChjKSA9PiBjLnNlcmlhbGl6ZSgpKSwgZXZlbnQudHlwZSwgZXZlbnQucXVlcnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnNldEZlYXR1cmVkKFtdLCBldmVudC50eXBlLCBldmVudC5xdWVyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQgPT0gXCJleHBsb3JlXCIpIHtcbiAgICAgICAgICAgICAgICBpZihldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc1tldmVudC50eXBlXS5nZXRGZWF0dXJlZENoYW5uZWxzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjaGFubmVscykgPT4gdGhpcy5zZXRGZWF0dXJlZChjaGFubmVscy5tYXAoKGMpID0+IGMuc2VyaWFsaXplKCkpLCBldmVudC50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuc2V0RmVhdHVyZWQoW10sIGV2ZW50LnR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldCA9PSBcImNvcHlcIikge1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJjb3B5XCIsIGV2ZW50LmNoYW5uZWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldCA9PSBcImNvcHlleHRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImNvcHlcIiwgZXZlbnQubG9naW4sIGV2ZW50LnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQgPT0gXCJyZW1vdmVkTGl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5yZWdpc3RlckNoYW5uZWwoZXZlbnQuY2hhbm5lbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfZW1pdFRvTGlzdChldmVudCwgZGF0YSkge1xuICAgICAgICBpZih0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb3VudE5vbmxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vbkxpdmVEaXNwbGF5IDwgTGlzdFZpZXcuRElTVElOQ1Q7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlQmFkZ2UoKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxpdmUuc2l6ZSArICh0aGlzLmNvdW50Tm9ubGl2ZSA/IHRoaXMubm9ubGl2ZS5zaXplIDogMCk7XG4gICAgICAgIGlmKHNpemUgPiAwKSB7XG4gICAgICAgICAgICBpZihhd2FpdCBwcmVmcy5nZXQoXCJwYW5lbF9iYWRnZVwiKSkge1xuICAgICAgICAgICAgICAgIGJyb3dzZXIuYnJvd3NlckFjdGlvbi5zZXRCYWRnZVRleHQoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzaXplLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyb3dzZXIuYnJvd3NlckFjdGlvbi5zZXRCYWRnZVRleHQoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyb3dzZXIuYnJvd3NlckFjdGlvbi5zZXRJY29uKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBMSVZFX0lDT05TXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyb3dzZXIuYnJvd3NlckFjdGlvbi5zZXRUaXRsZSh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IF8oXCJsaXN0VG9vbHRpcExpdmVcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJvd3Nlci5icm93c2VyQWN0aW9uLnNldEJhZGdlVGV4dCh7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicm93c2VyLmJyb3dzZXJBY3Rpb24uc2V0SWNvbih7XG4gICAgICAgICAgICAgICAgcGF0aDogT0ZGTElORV9JQ09OU1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicm93c2VyLmJyb3dzZXJBY3Rpb24uc2V0VGl0bGUoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBfKFwibGlzdFRvb2x0aXBPZmZsaW5lXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgaWYoY2hhbm5lbC5saXZlLnN0YXRlID09IExpdmVTdGF0ZS5PRkZMSU5FKSB7XG4gICAgICAgICAgICB0aGlzLl91bnJlZ2lzdGVyQ2hhbm5lbChjaGFubmVsLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2hhbm5lbChjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUJhZGdlKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIGlmKGNoYW5uZWwubGl2ZS5zdGF0ZSA9PSBMaXZlU3RhdGUuTElWRSkge1xuICAgICAgICAgICAgaWYodGhpcy5ub25saXZlLmhhcyhjaGFubmVsLmlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9ubGl2ZS5kZWxldGUoY2hhbm5lbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpdmUuYWRkKGNoYW5uZWwuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYodGhpcy5saXZlLmhhcyhjaGFubmVsLmlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGl2ZS5kZWxldGUoY2hhbm5lbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vbmxpdmUuYWRkKGNoYW5uZWwuaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VucmVnaXN0ZXJDaGFubmVsKGNoYW5uZWxJZCkge1xuICAgICAgICBpZih0aGlzLmxpdmUuaGFzKGNoYW5uZWxJZCkpIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZS5kZWxldGUoY2hhbm5lbElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMubm9ubGl2ZS5oYXMoY2hhbm5lbElkKSkge1xuICAgICAgICAgICAgdGhpcy5ub25saXZlLmRlbGV0ZShjaGFubmVsSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5saXZlLnNpemUgPT09IDAgJiYgKCF0aGlzLmNvdW50Tm9ubGl2ZSB8fCB0aGlzLm5vbmxpdmUuc2l6ZSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZVN0YXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGxpdmUgc3RhdGUgb3ZlciBhbGwgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmxpc3QuTGlzdFZpZXdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgbGl2ZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGl2ZVN0YXRlO1xuICAgIH1cbiAgICBzZXQgbGl2ZVN0YXRlKHZhbCkge1xuICAgICAgICB0aGlzLl9saXZlU3RhdGUgPSB2YWw7XG4gICAgICAgIGlmKCF2YWwpIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCYWRnZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHlsZSBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmxpc3R+U3R5bGV9IHN0eWxlIC0gU3R5bGUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgc2V0U3R5bGUoc3R5bGUgPSB0aGlzLl9zdHlsZSkge1xuICAgICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLl9lbWl0VG9MaXN0KFwic2V0U3R5bGVcIiwgc3R5bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZXh0cmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlIC0gVmlzaWJpbGl0eSBvZiBleHRyYXMuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzZXRFeHRyYXNWaXNpYmlsaXR5KHZpc2libGUgPSB0aGlzLl9leHRyYXMpIHtcbiAgICAgICAgdGhpcy5fZXh0cmFzID0gdmlzaWJsZTtcbiAgICAgICAgdGhpcy5fZW1pdFRvTGlzdChcInNldEV4dHJhc1wiLCB2aXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRpc3BsYXkgdHlwZSBmb3Igbm9uLWxpdmUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmxpc3R+Tm9uTGl2ZURpc3BsYXl9IHN0eWxlIC0gRGlzcGxheSBtb2RlIG9mIG5vbi1saXZlIGNvbnRlbnQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzZXROb25MaXZlRGlzcGxheShzdHlsZSA9IHRoaXMubm9uTGl2ZURpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5ub25MaXZlRGlzcGxheSA9IHN0eWxlO1xuICAgICAgICB0aGlzLnVwZGF0ZUJhZGdlKCk7XG4gICAgICAgIGlmKHRoaXMubm9ubGl2ZS5zaXplID4gMCAmJiB0aGlzLmxpdmUuc2l6ZSA9PT0gMCAmJiBzdHlsZSA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZVN0YXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VtaXRUb0xpc3QoXCJzZXROb25MaXZlRGlzcGxheVwiLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGNoYW5uZWxzIHRvIHRoZSBsaXN0LiBVcGRhdGVzIHRoZSBsaXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gY2hhbm5lbHMgLSBDaGFubmVscyB0byBhZGQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBhZGRDaGFubmVscyhjaGFubmVscykge1xuICAgICAgICBpZihjaGFubmVscy5zb21lKChjaGFubmVsKSA9PiBjaGFubmVsLmxpdmUuaXNMaXZlKCkpKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVTdGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbHMuZm9yRWFjaCh0aGlzLl91cGRhdGVDaGFubmVsLCB0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVCYWRnZSgpO1xuICAgICAgICB0aGlzLl9lbWl0VG9MaXN0KFwiYWRkQ2hhbm5lbHNcIiwgY2hhbm5lbHMubWFwKChjKSA9PiBjLnNlcmlhbGl6ZSgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNoYW5uZWwgZnJvbSB0aGUgbGlzdC4gVXBkYXRlcyB0aGUgbGl2ZVN0YXRlIGlmIGFwcHJvcHJpYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJZCAtIElEIG9mIHRoZSBjaGFubmVsIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHJlbW92ZUNoYW5uZWwoY2hhbm5lbElkKSB7XG4gICAgICAgIHRoaXMuX3VucmVnaXN0ZXJDaGFubmVsKGNoYW5uZWxJZCk7XG4gICAgICAgIHRoaXMuX2VtaXRUb0xpc3QoXCJyZW1vdmVDaGFubmVsXCIsIGNoYW5uZWxJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgYSBjaGFubmVsIGFzIGxpdmUuIEFsc28gdXBkYXRlcyB0aGUgbGl2ZVN0YXRlLiBDYW4gYWxzbyBiZSB1c2VyIHRvXG4gICAgICogdXBkYXRlIHRoZSBpbmZvIG9mIGEgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsIC0gQ2hhbm5lbCB0byBtYXJrIGxpdmUuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzZXRDaGFubmVsTGl2ZShjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgIHRoaXMuX2VtaXRUb0xpc3QoXCJzZXRPbmxpbmVcIiwgY2hhbm5lbC5zZXJpYWxpemUoKSk7XG4gICAgICAgIHRoaXMubGl2ZVN0YXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayBhIGNoYW5uZWwgYXMgb2ZmbGluZS4gQWxzbyB1cGRhdGVzIGxpdmVTdGF0ZSBpZiBhcHByb3ByaWF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsIC0gQ2hhbm5lbCB0byBtYXJrIG9mZmxpbmUuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzZXRDaGFubmVsT2ZmbGluZShjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgIHRoaXMuX2VtaXRUb0xpc3QoXCJzZXRPZmZsaW5lXCIsIGNoYW5uZWwuc2VyaWFsaXplKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmsgYSBjaGFubmVsIGFzIGluIGEgZGlzdGluY3Qgc3RhdGUgdGhhdCBpcyBub3Qgb25saW5lIG9yIG9mZmxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gY2hhbm5lbCAtIENoYW5uZWwgdG8gZ2l2ZSBhIGRpc3RpbmN0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHNldENoYW5uZWxEaXN0aW5jdChjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgICAgIHRoaXMuX2VtaXRUb0xpc3QoXCJzZXREaXN0aW5jdFwiLCBjaGFubmVsLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF2YWlsYWJsZSBwcm92aWRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdC48bW9kdWxlOnByb3ZpZGVycy9nZW5lcmljLXByb3ZpZGVyLkdlbmVyaWNQcm92aWRlcj59IHNlcmlhbGl6ZWRQcm92aWRlcnNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEF2YWlsYWJsZSBwcm92aWRlcnMuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzZXRQcm92aWRlcnMoc2VyaWFsaXplZFByb3ZpZGVycykge1xuICAgICAgICB0aGlzLl9lbWl0VG9MaXN0KFwic2V0UHJvdmlkZXJzXCIsIHNlcmlhbGl6ZWRQcm92aWRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIGlmIHRoZSB1cGRhdGUgcXVldWUgaXMgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgLSBJZiBxdWV1ZSBpcyBlbmFibGVkLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgc2V0UXVldWVTdGF0dXMoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9lbWl0VG9MaXN0KFwicXVldWVTdGF0dXNcIiwgZW5hYmxlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgaWYgdGhlIHF1ZXVlIGlzIHRlbXBvcmFyaWx5IHBhdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGF1c2VkIC0gSWYgcXVldWUgaXMgcGF1c2VkLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgc2V0UXVldWVQYXVzZWQocGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2VtaXRUb0xpc3QoXCJxdWV1ZVBhdXNlZFwiLCBwYXVzZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGhlbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhlbWUgLSBUaGVtZSB0eXBlLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgc2V0VGhlbWUodGhlbWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdFRvTGlzdChcInRoZW1lXCIsIHRoZW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTb21ldGhpbmcgd2l0aCB0aGUgY2hhbm5lbCBjaGFuZ2VkLiBQZXJmb3JtcyBhcHByb3ByaWF0ZSBhY3Rpb25zIGJhc2VkIG9uIHRoZVxuICAgICAqIHN0YXRlIG9mIHRoZSBjaGFubmVsLiBVcGRhdGVzIGxpdmVTdGF0ZSBpZiBhcHByb3ByaWF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsIC0gQ2hhbm5lbCB0aGF0IGNoYW5nZWQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBvbkNoYW5uZWxDaGFuZ2VkKGNoYW5uZWwpIHtcbiAgICAgICAgaWYoY2hhbm5lbC5saXZlLnN0YXRlID4gMCAmJiB0aGlzLm5vbkxpdmVEaXNwbGF5ID09PSBMaXN0Vmlldy5MSVZFX0RJU1RJTkNUKSB7XG4gICAgICAgICAgICB0aGlzLnNldENoYW5uZWxEaXN0aW5jdChjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNoYW5uZWwubGl2ZS5pc0xpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDaGFubmVsTGl2ZShjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2hhbm5lbE9mZmxpbmUoY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRGZWF0dXJlZChjaGFubmVscywgdHlwZSwgcSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZW1pdFRvTGlzdChcInNldEZlYXR1cmVkXCIsIHsgY2hhbm5lbHMsIHR5cGUsIHEgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0VmlldztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL2xpc3QuanMiLCIvKipcbiAqIE1vZGVsIGZvciB0aGUgTm90aWZpY2F0aW9uc1xuICpcbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIG5vdGlmaWVyXG4gKi9cblxuaW1wb3J0IHByZWZzIGZyb20gJy4vcHJlZmVyZW5jZXMnO1xuaW1wb3J0IExpdmVTdGF0ZSBmcm9tIFwiLi9jaGFubmVsL2xpdmUtc3RhdGVcIjtcbmltcG9ydCB7IGFuZCwgb3IsIG5vdCB9IGZyb20gJy4vbG9naWMnO1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICdldmVudC10YXJnZXQtc2hpbSc7XG5cbmNvbnN0IF8gPSBicm93c2VyLmkxOG4uZ2V0TWVzc2FnZSxcblxuLyoqXG4gKiBTaXplIG9mIHRoZSBpbWFnZSBzaG93biBpbiB0aGUgbm90aWZpY2F0aW9uLlxuICogQGNvbnN0IHtudW1iZXJ9XG4gKiBAZGVmYXVsdCAxMDBcbiAqL1xuICAgIE5PVElGSUNBVElPTl9JQ09OX1NJWkUgPSAxMDA7XG5cbi8qKlxuICogQGNsYXNzIG1vZHVsZTpub3RpZmllci5Ob3RpZmllclxuICogQGV4dGVuZHMgZXh0ZXJuYWw6RXZlbnRUYXJnZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm90aWZpZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHRpdGxlIG9mIGVhY2ggY2hhbm5lbCBieSBpZCB0aGUgbm90aWZpZXIgbGFzdCBzYXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtNYXAuPG51bWJlciwgc3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbm5lbFRpdGxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ByaWV0YXJ5IHRoaW5nIEknbSB0b28gdGlyZWQgdG8gZXhwbGFpbiwgYnV0IGl0IHN0b3JlcyB0aGUgcmVsZXZhbnRcbiAgICAgICAgICogaW5mbyBhYm91dCBhIGNoYW5uZWwncyBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TWFwLjxudW1iZXIsIG9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGJyb3dzZXIubm90aWZpY2F0aW9ucy5vbkNsaWNrZWQuYWRkTGlzdGVuZXIoKGlkKSA9PiB7XG4gICAgICAgICAgICBpZihpZC5zdGFydHNXaXRoKFwiY25cIikpIHtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwiY2xpY2tcIiwgaWQuc3Vic3RyKDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgb25saW5lIG5vdGlmaWNhdGlvbnMgc2hvdWxkIGJlIHNob3duLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFNob3cgb25saW5lIG5vdGlmaWNhdGlvbnMgd2hlbiB0cnVlLlxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIG9ubGluZU5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBwcmVmcy5nZXQoXCJvbmxpbmVOb3RpZmljYXRpb25cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRpdGxlIGNoYW5nZSBub3RpZmljYXRpb25zIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBTaG93IHRpdGxlIGNoYW5nZSBub3RpZmljYXRpb25zIHdoZW4gdHJ1ZS5cbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICB0aXRsZU5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBwcmVmcy5nZXQoXCJ0aXRsZUNoYW5nZU5vdGlmaWNhdGlvblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgb2ZmbGluZSBub3RpZmljYXRpb25zIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBTaG93IG9mZmxpbmUgbm90aWZpY2F0aW9ucyB3aGVuIHRydWUuXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgb2ZmbGluZU5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBwcmVmcy5nZXQoXCJvZmZsaW5lTm90aWZpY2F0aW9uXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBub24tbGl2ZSB0eXBlcyBhcmUgaGFuZGxlZCBsaWtlIGEgbm9uLWJpbmFyeSBzdGF0ZSwgdGhleSBnZXQgY3VzdG9tXG4gICAgICogbm90aWZpY2F0aW9ucyB3aGVuIHRoaXMgaXMgc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFNob3cgbm9uLWxpdmUgbm90aWZpY2F0aW9ucyB3aGVuIHRydWUuXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgbm9ubGl2ZU5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBwcmVmcy5nZXQoXCJub25saXZlTm90aWZpY2F0aW9uXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBhbnkgbm90aWZpY2F0aW9ucyBhcmUgdG8gYmUgc2hvd24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQ2FuIHNob3cgbm90aWZpY2F0aW9ucyB3aGVuIHRydWUuXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgc2hvd05vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBvcihcbiAgICAgICAgICAgIHRoaXMub25saW5lTm90aWZpY2F0aW9ucygpLFxuICAgICAgICAgICAgdGhpcy50aXRsZU5vdGlmaWNhdGlvbnMoKSxcbiAgICAgICAgICAgIHRoaXMub2ZmbGluZU5vdGlmaWNhdGlvbnMoKSxcbiAgICAgICAgICAgIHRoaXMubm9ubGl2ZU5vdGlmaWNhdGlvbnMoKVxuICAgICAgICApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZSBhIGNoYW5uZWwncyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsIC0gVGhlIGNoYW5uZWwgdG8gc3RvcmUuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBfc2V0Q2hhbm5lbFN0YXRlKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsU3RhdGVzLnNldChjaGFubmVsLmlkLCB7XG4gICAgICAgICAgICBzdGF0ZTogY2hhbm5lbC5saXZlLnN0YXRlLFxuICAgICAgICAgICAgdXNlcjogY2hhbm5lbC5saXZlLmFsdGVybmF0ZVVzZXJuYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIHN0YXRlIG9mIGEgY2hhbm5lbCBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsIC0gVGhlIGNoYW5uZWwgdGhhdCBtaWdodFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZSBjaGFuZ2VkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGVuIHRydWUgdGhlIGNoYW5uZWwgc3RhdGUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBfY2hhbm5lbFN0YXRlQ2hhbmdlZChjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jaGFubmVsU3RhdGVzLmdldChjaGFubmVsLmlkKTtcbiAgICAgICAgcmV0dXJuIG9sZFN0YXRlID09PSB1bmRlZmluZWQgfHwgb2xkU3RhdGUuc3RhdGUgIT0gY2hhbm5lbC5saXZlLnN0YXRlIHx8IChjaGFubmVsLmxpdmUuc3RhdGUgPiBMaXZlU3RhdGUuTElWRSAmJiBvbGRTdGF0ZS51c2VyICE9IGNoYW5uZWwubGl2ZS5hbHRlcm5hdGVVc2VybmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRMaXZlSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgIGlmKGF3YWl0IHRoaXMubm9ubGl2ZU5vdGlmaWNhdGlvbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIExpdmVTdGF0ZS5UT1dBUkRfTElWRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMaXZlU3RhdGUuVE9XQVJEX09GRkxJTkU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBhIG5vdGlmaWNhdGlvbiB0byB0aGUgdXNlciwgaWYgdGhlIGNoYW5uZWwgaXNuJ3QgaW4gdGhlIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSB0YWIsIHRoZSBjaGFubmVsIGNoYW5nZWQgYWNjb3JkaW5nbHkgYW5kIHRoZSByZXNwZWN0aXZlXG4gICAgICogbm90aWZpY2F0aW9uIGlzIGFjdGl2YXRlZC5cbiAgICAgKiBUaGlzIGFsc28gbWFuYWdlcyB0aGUge0BsaW5rIG1vZHVsZTpub3RpZmllci5Ob3RpZmllcn5jaGFubmVsVGl0bGVzfSBNYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBjaGFubmVsIHRvIHNob3cgYVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uIGZvci5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGFzeW5jIHNlbmROb3RpZmljYXRpb24oY2hhbm5lbCkge1xuICAgICAgICAvLyBNdXRlIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IHRhYlxuICAgICAgICBjb25zdCBbIHRhYiwgc2hvd05vdGlmaWNhdGlvbnMgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGJyb3dzZXIudGFicy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgdXJsOiBjaGFubmVsLnVybFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb25zKClcbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYoc2hvd05vdGlmaWNhdGlvbnMgJiYgIXRhYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpdmVJbnRlcnByZXRhdGlvbiA9IGF3YWl0IHRoaXMuX2dldExpdmVJbnRlcnByZXRhdGlvbigpO1xuICAgICAgICAgICAgbGV0IHRpdGxlID0gbnVsbDtcbiAgICAgICAgICAgIGlmKChhd2FpdCBhbmQoY2hhbm5lbC5saXZlLmlzTGl2ZShMaXZlU3RhdGUuVE9XQVJEX09GRkxJTkUpLCB0aGlzLm9ubGluZU5vdGlmaWNhdGlvbnMoKSkpICYmIHRoaXMuX2NoYW5uZWxTdGF0ZUNoYW5nZWQoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IF8oXCJvbmxpbmVOb3RpZmljYXRpb25cIiwgY2hhbm5lbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoKGF3YWl0IGFuZChjaGFubmVsLmxpdmUuaXNMaXZlKGxpdmVJbnRlcnByZXRhdGlvbiksIHRoaXMudGl0bGVOb3RpZmljYXRpb25zKCksIG9yKGNoYW5uZWwubGl2ZS5zdGF0ZSA9PT0gTGl2ZVN0YXRlLkxJVkUsIHRoaXMubm9ubGl2ZU5vdGlmaWNhdGlvbnMoKSkpKSAmJiAhdGhpcy5fY2hhbm5lbFN0YXRlQ2hhbmdlZChjaGFubmVsKSAmJiB0aGlzLmNoYW5uZWxUaXRsZXMuZ2V0KGNoYW5uZWwuaWQpICE9IGNoYW5uZWwudGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IF8oXCJ1cGRhdGVOb3RpZmljYXRpb25cIiwgY2hhbm5lbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoKGF3YWl0IGFuZChub3QoY2hhbm5lbC5saXZlLmlzTGl2ZShsaXZlSW50ZXJwcmV0YXRpb24pKSwgdGhpcy5vZmZsaW5lTm90aWZpY2F0aW9ucygpKSkgJiYgdGhpcy5jaGFubmVsVGl0bGVzLmhhcyhjaGFubmVsLmlkKSkge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gXyhcIm9mZmxpbmVOb3RpZmljYXRpb25cIiwgY2hhbm5lbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoY2hhbm5lbC5saXZlLnN0YXRlID4gTGl2ZVN0YXRlLkxJVkUgJiYgKGF3YWl0IHRoaXMubm9ubGl2ZU5vdGlmaWNhdGlvbnMoKSkgJiYgdGhpcy5fY2hhbm5lbFN0YXRlQ2hhbmdlZChjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlTmFtZSA9IExpdmVTdGF0ZS5SRURJUkVDVCA9PT0gY2hhbm5lbC5saXZlLnN0YXRlID8gXCJSZWRpcmVjdFwiIDogXCJSZWJyb2FkY2FzdFwiO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gXyhcIm5vbmxpdmVOb3RpZmljYXRpb25cIiwgW1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIF8oXCJub25saXZlTm90aWZpY2F0aW9uU3RhdGVcIiArIHN0YXRlTmFtZSwgY2hhbm5lbC5saXZlLmFsdGVybmF0ZVVzZXJuYW1lKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmFzaWNcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoYW5uZWwudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGljb25Vcmw6IGNoYW5uZWwuZ2V0QmVzdEltYWdlRm9yU2l6ZShOT1RJRklDQVRJT05fSUNPTl9TSVpFKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBicm93c2VyLm5vdGlmaWNhdGlvbnMuY3JlYXRlKGBjbiR7Y2hhbm5lbC5pZH1gLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGF3YWl0IGNoYW5uZWwubGl2ZS5pc0xpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsVGl0bGVzLnNldChjaGFubmVsLmlkLCBjaGFubmVsLnRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbFRpdGxlcy5kZWxldGUoY2hhbm5lbC5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRDaGFubmVsU3RhdGUoY2hhbm5lbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGNhbGwsIHdoZW5ldmVyIGFuIGV2ZW50IGdldHMgcmVtb3ZlZC4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAqIGNoYW5uZWwgZnJvbSB0aGUgaW50ZXJuYWwgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJZCAtIElEIG9mIHRoZSBjaGFubmVsIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBvbkNoYW5uZWxSZW1vdmVkKGNoYW5uZWxJZCkge1xuICAgICAgICBpZih0aGlzLmNoYW5uZWxUaXRsZXMuaGFzKGNoYW5uZWxJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbFRpdGxlcy5kZWxldGUoY2hhbm5lbElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmNoYW5uZWxTdGF0ZXMuaGFzKGNoYW5uZWxJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbFN0YXRlcy5kZWxldGUoY2hhbm5lbElkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGUgdXNlciwgdGhhdCB0aGUgc3RyaW5nIGhhcyBiZWVuIGNvcGllZCB0byB0aGUgY2xpcGJvYXJkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxOYW1lIC0gTmFtZSBvZiB0aGUgY2hhbm5lbCB0aGF0IHdhcyBjb3BpZWQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBub3RpZnlDb3BpZWQoY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgYnJvd3Nlci5ub3RpZmljYXRpb25zLmNyZWF0ZShcImNvcHlcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJiYXNpY1wiLFxuICAgICAgICAgICAgdGl0bGU6IF8oXCJjb3B5Tm90aWZpY2F0aW9uXCIsIGNoYW5uZWxOYW1lKSxcbiAgICAgICAgICAgIGljb25VUkw6IFwiLi4vaW1hZ2VzL2ljb242NC5wbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9ub3RpZmllci5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIGR1bXAgb2YgdGhlIHdob2xlIGNoYW5uZWwgbGlzdCBhbmQgb3RoZXIgcmVsZXZhbnQgc2V0dGluZ3MgYW5kXG4gKiBjYW4gY29weSBpdCB0byB0aGUgY2xpcGJvYXJkLlxuICpcbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIGNoYW5uZWwvZHVtcFxuICovXG5pbXBvcnQgcHJlZnMgZnJvbSBcIi4uL3ByZWZlcmVuY2VzXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBVc2VyIH0gZnJvbSBcIi4vY29yZVwiO1xuaW1wb3J0IHsgd2hlbiB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgUFJFRlNfTUFQUElORyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHF1ZXVlOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaW50ZXJ2YWw6IFwidXBkYXRlSW50ZXJ2YWxcIixcbiAgICAgICAgcmF0aW86IFwicXVldWVfcmF0aW9cIixcbiAgICAgICAgbWF4QW1vdW50OiBcInF1ZXVlX21heFJlcXVlc3RCYXRjaFNpemVcIixcbiAgICAgICAgbWF4UmV0cmllczogXCJxdWV1ZXNlcnZpY2VfbWF4UmV0cmllc1wiXG4gICAgfSksXG4gICAgcGFuZWw6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzdHlsZTogXCJwYW5lbF9zdHlsZVwiLFxuICAgICAgICBleHRyYXM6IFwicGFuZWxfZXh0cmFzXCIsXG4gICAgICAgIHdpZHRoOiBcInBhbmVsX21pbldpZHRoXCIsXG4gICAgICAgIGhlaWdodDogXCJwYW5lbF9tYXhIZWlnaHRcIixcbiAgICAgICAgYmFkZ2U6IFwicGFuZWxfYmFkZ2VcIlxuICAgIH0pLFxuICAgIG1pc2M6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjYWNoZVRpbWU6IFwiY2hhbm5lbGxpc3RfY2FjaGVUaW1lXCIsXG4gICAgICAgIGZpbmRNYXR1cmU6IFwiZmluZF9tYXR1cmVcIlxuICAgIH0pXG59KTtcblxuLyoqXG4gKiBGcm96ZW5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEYXRhRHVtcFxuICogQHByb3BlcnR5IHtBcnJheS48T2JqZWN0Pn0gY2hhbm5lbHMgLSBTZXJpYWxpemVkIGNoYW5uZWxzXG4gKiBAcHJvcGVydHkge0FycmF5LjxPYmplY3Q+fSB1c2VycyAtIFNlcmlhbGl6ZWQgdXNlcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcmVmcyAtIENvbGxlY3Rpb24gb2YgaW1wb3J0YW50IHByZWZlcmVuY2VzXG4gKiBAcHJvcGVydHkge09iamVjdH0gbWV0YSAtIFN5c3RlbSBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIEpTT04gc2VyaWFsaXplZCBkdW1wIG9mIGFsbCBpbXBvcnRhbmQgZXh0ZW5zaW9uIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gY2hhbm5lbHMgLSBDaGFubmVscyB0byBkdW1wLlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyPn0gdXNlcnMgLSBVc2VycyB0byBkdW1wLlxuICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2R1bXB+RGF0YUR1bXB9IFNlcmlhbGl6ZWQgZGF0YSBkdW1wLlxuICogQGFzeW5jXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSBhc3luYyAoY2hhbm5lbHMsIHVzZXJzKSA9PiB7XG4gICAgY29uc3QgcCA9IHt9O1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgZm9yKGxldCBicmFuY2ggaW4gUFJFRlNfTUFQUElORykge1xuICAgICAgICBwW2JyYW5jaF0gPSB7fTtcbiAgICAgICAgZm9yKGxldCBuYW1lIGluIFBSRUZTX01BUFBJTkdbYnJhbmNoXSkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcmVmcy5nZXQoUFJFRlNfTUFQUElOR1ticmFuY2hdW25hbWVdKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHBbYnJhbmNoXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgZm9yKGxldCBicmFuY2ggaW4gcCkge1xuICAgICAgICBPYmplY3QuZnJlZXplKHBbYnJhbmNoXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBicm93c2VyLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCk7XG4gICAgY29uc3QgbWFuaWZlc3QgPSBicm93c2VyLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKTtcblxuICAgIGNvbnN0IGRlYnVnRHVtcCA9IHtcbiAgICAgICAgY2hhbm5lbHM6IGNoYW5uZWxzLm1hcCgoYykgPT4gYy5zZXJpYWxpemUoKSksXG4gICAgICAgIHVzZXJzOiB1c2Vycy5tYXAoKHUpID0+IHUuc2VyaWFsaXplKCkpLFxuICAgICAgICBwcmVmczogT2JqZWN0LmZyZWV6ZShwKSxcbiAgICAgICAgbWV0YTogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICB2ZXJzaW9uOiBtYW5pZmVzdC52ZXJzaW9uLFxuICAgICAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtLm9zLFxuICAgICAgICAgICAgcGxhdGZvcm1BcmNoOiBwbGF0Zm9ybS5hcmNoLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGJyb3dzZXIuaTE4bi5nZXRVSUxhbmd1YWdlKCksXG4gICAgICAgICAgICBsYXN0RXJyb3I6IGJyb3dzZXIucnVudGltZS5sYXN0RXJyb3JcbiAgICAgICAgfSlcbiAgICB9O1xuICAgIE9iamVjdC5mcmVlemUoZGVidWdEdW1wKTtcblxuICAgIHJldHVybiBkZWJ1Z0R1bXA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGNvcGllcyB0aGUgZGF0YSBkdW1wIHRvIHRoZSBjbGlwYm9hcmQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gY2hhbm5lbHMgLSBDaGFubmVscyB0byBkdW1wLlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyPn0gdXNlcnMgLSBVc2VycyB0byBkdW1wLlxuICovXG5leHBvcnQgY29uc3QgY29weSA9IGFzeW5jIChjaGFubmVscywgdXNlcnMpID0+IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZXhwb3J0cy5jcmVhdGUoY2hhbm5lbHMsIHVzZXJzKSxcbiAgICAgICAgcCA9IHdoZW4oZG9jdW1lbnQsIFwiY29weVwiKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIiwgZmFsc2UsIG51bGwpO1xuICAgIGNvbnN0IGUgPSBhd2FpdCBwO1xuXG4gICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9qc29uXCIsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc29sZS5sb2coXCJEYXRhIGR1bXAgY29waWVkIHRvIGNsaXBib2FyZFwiKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbHNBbmRVc2Vyc1xuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn0gY2hhbm5lbHNcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcj59IHVzZXJzXG4gKi9cblxuLyoqXG4gKiBMb2FkcyBhIGRhdGEgZHVtcCdzIGRhdGEgaW50byB0aGUgZXh0ZW5zaW9uLiBBcHBsaWVzIGR1bXBlZCBzZXR0aW5nc1xuICogZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9kdW1wfkRhdGFEdW1wfSBkZWJ1Z0R1bXAgLSBEdW1wIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9kdW1wfkNoYW5uZWxzQW5kVXNlcnN9IERlc2VyaWFsaXplZCBjaGFubmVscyBhbmRcbiAqICAgICAgICAgIHVzZXJzLlxuICogQGFzeW5jXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkID0gKGRlYnVnRHVtcCkgPT4ge1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgZm9yKGxldCBicmFuY2ggaW4gZGVidWdEdW1wLnByZWZzKSB7XG4gICAgICAgIGZvcihsZXQgbmFtZSBpbiBkZWJ1Z0R1bXAucHJlZnNbYnJhbmNoXSkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcmVmcy5zZXQoUFJFRlNfTUFQUElOR1ticmFuY2hdW25hbWVdLCBkZWJ1Z0R1bXAucHJlZnNbYnJhbmNoXVtuYW1lXSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbm5lbHM6IGRlYnVnRHVtcC5jaGFubmVscy5tYXAoKGMpID0+IENoYW5uZWwuZGVzZXJpYWxpemUoYykpLFxuICAgICAgICB1c2VyczogZGVidWdEdW1wLnVzZXJzLm1hcCgodSkgPT4gVXNlci5kZXNlcmlhbGl6ZSh1KSlcbiAgICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvZHVtcC5qcyIsIi8qKlxuICogQ2hhbm5lbCBsaXN0IE9iamVjdC5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBjaGFubmVsL2xpc3RcbiAqIEByZXF1aXJlcyBtb2R1bGU6Y2hhbm5lbC9jb3JlXG4gKi9cbi8vIHNldHVwIGV2ZW50IGhhbmRsaW5nXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgcHJlZnMgZnJvbSBcIi4uL3ByZWZlcmVuY2VzXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBVc2VyIH0gZnJvbSBcIi4vY29yZVwiO1xuaW1wb3J0IExpdmVTdGF0ZSBmcm9tIFwiLi9saXZlLXN0YXRlXCI7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnZXZlbnQtdGFyZ2V0LXNoaW0nO1xuXG4vKipcbiAqIEluZGV4ZWREQiB2ZXJzaW9uLlxuICpcbiAqIEBjb25zdCB7bnVtYmVyfVxuICogQGRlZmF1bHQgMlxuICovXG5jb25zdCBWRVJTSU9OID0gMixcblxuLyoqXG4gKiBEYXRhYmFzZSBuYW1lLlxuICpcbiAqIEBjb25zdCB7c3RyaW5nfVxuICogQGRlZmF1bHQgXCJjaGFubmVsbGlzdFwiXG4gKi9cbiAgICBOQU1FID0gXCJjaGFubmVsbGlzdFwiO1xuXG4vKipcbiAqIFRoZSBDaGFubmVsTGlzdCBpcyByZWFkeSB0byBiZSB1c2VkLlxuICpcbiAqIEBldmVudCBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I3JlYWR5XG4gKi9cbi8qKlxuICogV2hlbmV2ZXIgb25lIG9yIG1vcmUgY2hhbm5lbHMgYXJlIGFkZGVkIHRvIHRoZSBDaGFubmVsTGlzdCB0aGlzIGV2ZW50IGlzXG4gKiBmaXJlZC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNjaGFubmVsc2FkZGVkXG4gKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59XG4gKi9cbi8qKlxuICogV2hlbmV2ZXIgYSB1c2VyIGlzIGFkZGVkIHRvIHRoZSBDaGFubmVsTGlzdCB0aGlzIGV2ZW50IGlzIGZpcmVkLlxuICpcbiAqIEBldmVudCBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I3VzZXJhZGRlZFxuICogQHR5cGUge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn1cbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNjaGFubmVsdXBkYXRlZFxuICogQHR5cGUge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH1cbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCN1c2VydXBkYXRlZFxuICogQHR5cGUge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn1cbiAqL1xuLyoqXG4gKiBHZXRzIGZpcmVkIGJlZm9yZSBhIGNoYW5uZWwgaXMgZGVsZXRlZC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNiZWZvcmVjaGFubmVsZGVsZXRlZFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuLyoqXG4gKiBHZXRzIGZpcmVkIGFmdGVyIGEgY2hhbm5lbCB3YXMgZGVsZXRlZC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNjaGFubmVsZGVsZXRlZFxuICogQHR5cGUge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH1cbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCN1c2VyZGVsZXRlZFxuICogQHR5cGUge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn1cbiAqL1xuLyoqXG4gKiBGaXJlZCB3aGVuIGFsbCBjb250ZW50IG9mIHRoZSBDaGFubmVsTGlzdCBpcyByZW1vdmVkLiBJZiB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIGlzIHRydWUsIHRoZSB3aG9sZSBEQiBoYXMgYmVlbiBkZWxldGVkIGFuZCByZWNyZWF0ZWQsIG1vc3QgbGlrZWx5IHRvIGZpeCBpdC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNjbGVhclxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbi8qKlxuICogVGhlIGRhdGFiYXNlIGNvdWxkIG5vdCBiZSByZXBhaXJlZC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCN1bmZpeGFibGVlcnJvclxuICovXG4vKipcbiAqIFRoZSBkYXRiYXNlIHdhcyBmaXhlZCwgYnV0IGFsbCB0aGUgY29udGVudCB3YXMgbGlzdCBpbiB0aGUgcHJvY2Vzcy4gVXNlclxuICogbWlnaHQgd2FudCB0byByZS1hZGQgY29udGVudC5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNmaXhkYlxuICovXG5cbi8qKlxuICogQGNsYXNzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3RcbiAqIEBleHRlbmRzIGV4dGVybmFsOkV2ZW50VGFyZ2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWxMaXN0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgREJcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJbmRleGVkREI/fVxuICAgICAqL1xuICAgIGRiID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBIb2xkcyBhIHByb21pc2UgdW50aWwgdGhlIERCIGlzIGJlaW5nIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQcm9taXNlP31cbiAgICAgKi9cbiAgICBfb3BlbmluZ0RCID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0c1xuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I3JlYWR5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5pZENhY2hlID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMub3BlbkRCKE5BTUUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBEQiwgaW5pdGlhbGl6ZXMgdGhlIHNjaGVtYSBpZiBpdCdzIGEgbmV3IERCIG9yIHNldHMgY2hhbm5lbHNcbiAgICAgKiBvZmZsaW5lIHRoYXQgd2VyZSBvbmxpbmUgYW5kIGhhdmUgbGFzdCBiZWVuIHVwZGF0ZWQgYSBjZXJ0YWluIHRpbWUgYWdvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBEQiB0byBvcGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvbnRUcnk9ZmFsc2VdIC0gRG9uJ3QgdHJ5IHRvIGZpeCB0aGUgREIuXG4gICAgICogQGFzeW5jXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3QjcmVhZHlcbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNmaXhkYlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IFRoZSBEQiBpcyByZWFkeS5cbiAgICAgKiBAdGhyb3dzIENvdWxkIG5vdCBvcGVuIHRoZSBEQi5cbiAgICAgKi9cbiAgICBvcGVuREIobmFtZSwgZG9udFRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDaGFubmVsTGlzdC5vcGVuREIoJHtuYW1lfSwke2RvbnRUcnl9KWApO1xuICAgICAgICAvLyBRdWljayBwYXRoIGlmIERCIGlzIGFscmVhZHkgb3BlbmVkLlxuICAgICAgICBpZih0aGlzLmRiKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLl9vcGVuaW5nREIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcGVuaW5nREI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcGVuaW5nREIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gb3BlbiB0aGUgREJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB3aW5kb3cuaW5kZXhlZERCLm9wZW4obmFtZSwgVkVSU0lPTik7XG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYiA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJzID0gdGhpcy5kYi5jcmVhdGVPYmplY3RTdG9yZShcInVzZXJzXCIsIHsga2V5UGF0aDogXCJpZFwiLCBhdXRvSW5jcmVtZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHVzZXJzLmNyZWF0ZUluZGV4KFwidHlwZW5hbWVcIiwgWyBcInR5cGVcIiwgXCJsb2dpblwiIF0sIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHVzZXJzLmNyZWF0ZUluZGV4KFwidHlwZVwiLCBcInR5cGVcIiwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIC8vdXNlcnMuY3JlYXRlSW5kZXgoXCJpZFwiLCBcImlkXCIsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5kYi5jcmVhdGVPYmplY3RTdG9yZShcImNoYW5uZWxzXCIsIHsga2V5UGF0aDogXCJpZFwiLCBhdXRvSW5jcmVtZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzLmNyZWF0ZUluZGV4KFwidHlwZW5hbWVcIiwgWyBcInR5cGVcIiwgXCJsb2dpblwiIF0sIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzLmNyZWF0ZUluZGV4KFwidHlwZVwiLCBcInR5cGVcIiwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIC8vY2hhbm5lbHMuY3JlYXRlSW5kZXgoXCJpZFwiLCBcImlkXCIsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gREIgaXMgcmVhZHlcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRiID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgcHJlZnMuZ2V0KFwiY2hhbm5lbGxpc3RfY2FjaGVUaW1lXCIpLnRoZW4oKGNhY2hlVGltZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWxsIGNoYW5uZWxzIHRvIG9mZmxpbmUsIHRoYXQgaGF2ZW4ndCBiZWVuIHVwZGF0ZWQgaW4gYSBjZXJ0YWluIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihcImNoYW5uZWxzXCIsIFwicmVhZHdyaXRlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcImNoYW5uZWxzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGF0ZSA9IERhdGUubm93KCkgLSBjYWNoZVRpbWUsIC8vbm93IC0gMTAgbWluXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5pbmRleChcInR5cGVuYW1lXCIpLm9wZW5DdXJzb3IoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkQ2FjaGUuc2V0KGN1cnNvci52YWx1ZS50eXBlICsgY3Vyc29yLnZhbHVlLmxvZ2luLCBjdXJzb3IudmFsdWUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnNvci52YWx1ZS5sYXN0TW9kaWZpZWQgPCBtaW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci52YWx1ZS5saXZlLnN0YXRlID0gTGl2ZVN0YXRlLk9GRkxJTkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci51cGRhdGUoY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInJlYWR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZighZG9udFRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuY2xlYXIoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IGRlbGV0ZSB0aGUgREJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidW5maXhhYmxlZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xlYXIgaXQgb25jZSB0aGUgcHJvbWlzZSBpcyBkb25lLlxuICAgICAgICB0aGlzLl9vcGVuaW5nREIudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuaW5nREIgPSBudWxsO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuaW5nREIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5pbmdEQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBJRCBvZiBhIGNoYW5uZWwsIGlmIGl0IGlzIGluIHRoZSBDaGFubmVsTGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTG9naW4gb2YgdGhlIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUeXBlIG9mIHRoZSBjaGFubmVsLlxuICAgICAqIEBhc3luY1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBJRCBvZiB0aGUgY2hhbm5lbCBpZiBpdCBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbElkKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQ2hhbm5lbExpc3QuZ2V0Q2hhbm5lbElkKFwiICsgbmFtZSArIFwiLFwiICsgdHlwZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMuaWRDYWNoZS5oYXModHlwZSArIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSElUIElEIENBQ0hFXCIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5pZENhY2hlLmdldCh0eXBlICsgbmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFwiY2hhbm5lbHNcIiksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoXCJjaGFubmVsc1wiKS5pbmRleChcInR5cGVuYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICByZXEgPSBpbmRleC5nZXQoWyB0eXBlLCBuYW1lIF0pO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlcS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWRDYWNoZS5zZXQodHlwZSArIG5hbWUsIHJlcS5yZXN1bHQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzdWx0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgSUQgb2YgYSB1c2VyLCBpZiBpdCBpcyBpbiB0aGUgQ2hhbm5lbExpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIExvZ2luIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgdXNlci5cbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgSUQgb2YgdGhlIHVzZXIgKGlmIGl0IGV4c2l0cykuXG4gICAgICovXG4gICAgZ2V0VXNlcklkKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihcInVzZXJzXCIpLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoXCJ1c2Vyc1wiKS5pbmRleChcInR5cGVuYW1lXCIpLFxuICAgICAgICAgICAgICAgIHJlcSA9IGluZGV4LmdldChbIHR5cGUsIG5hbWUgXSk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHJlcS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzdWx0LmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzcGVjaWZpZWQgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBpZCAtIElEIG9mIGxvZ2luIG9mIHRoZSBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBUeXBlIG9mIHRoZSBjaGFubmVsIGlmIGEgbG9naW4gd2FzIHBhc3NlZCBhc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfVxuICAgICAqIEB0aHJvd3MgVGhlIGNoYW5uZWwgZG9lc24ndCBleGlzdCBvciBubyBhcmd1bWVudHMgcGFzc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENoYW5uZWwoaWQsIHR5cGUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQ2hhbm5lbExpc3QuZ2V0Q2hhbm5lbChcIiArIGlkICsgXCIpXCIpO1xuICAgICAgICBpZih0eXBlKSB7XG4gICAgICAgICAgICBpZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhbm5lbElkKGlkLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZighaWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiTm8gSUQgc3BlY2lmaWVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFwiY2hhbm5lbHNcIiksXG4gICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcImNoYW5uZWxzXCIpLFxuICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLmdldChpZCk7XG5cbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYocmVxLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKENoYW5uZWwuZGVzZXJpYWxpemUocmVxLnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNwZWNpZmllZCB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGlkIC0gSUQgb2YgbG9naW4gb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFR5cGUgb2YgdGhlIHVzZXIgaWYgYSBsb2dpbiB3YXMgcGFzc2VkIGFzIGZpcnN0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9XG4gICAgICogQHRocm93cyBUaGUgdXNlciBkb2Vzbid0IGV4aXN0IG9yIG5vIGFyZ3VtZW50cyBwYXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcihpZCwgdHlwZSkge1xuICAgICAgICBpZih0eXBlKSB7XG4gICAgICAgICAgICBpZCA9IGF3YWl0IHRoaXMuZ2V0VXNlcklkKGlkLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJObyBJRCBzcGVjaWZpZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oXCJ1c2Vyc1wiKSxcbiAgICAgICAgICAgICAgICBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFwidXNlcnNcIiksXG4gICAgICAgICAgICAgICAgcmVxID0gc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZihyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoVXNlci5kZXNlcmlhbGl6ZShyZXEucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNoYW5uZWwgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBjaGFubmVsIHRvIGFkZC5cbiAgICAgKiBAdGhyb3dzIHtzdHJpbmd9IElmIHRoZSBjaGFubmVsIGlzIGFscmVhZHkgaW4gdGhlIGxpc3QuXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3QjY2hhbm5lbHNhZGRlZFxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IEFkZGVkIGNoYW5uZWwgd2l0aCB0aGUgSUQgc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGFkZENoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDaGFubmVsTGlzdC5hZGRDaGFubmVsKFwiICsgY2hhbm5lbC5sb2dpbiArIFwiKVwiKTtcbiAgICAgICAgY2hhbm5lbC5sYXN0TW9kaWZpZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmKGF3YWl0IHRoaXMuY2hhbm5lbEV4aXN0cyhjaGFubmVsLmxvZ2luLCBjaGFubmVsLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNoYW5uZWwgYWxyZWFkeSBleGlzdHNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oXCJjaGFubmVsc1wiLCBcInJlYWR3cml0ZVwiKSxcbiAgICAgICAgICAgICAgICBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFwiY2hhbm5lbHNcIiksXG4gICAgICAgICAgICAgICAgcmVxID0gc3RvcmUuYWRkKGNoYW5uZWwuc2VyaWFsaXplKCkpO1xuXG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuaWQgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHRoaXMuaWRDYWNoZS5zZXQoY2hhbm5lbC50eXBlICsgY2hhbm5lbC5sb2dpbiwgY2hhbm5lbC5pZCk7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImNoYW5uZWxzYWRkZWRcIiwgWyBjaGFubmVsIF0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoY2hhbm5lbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBtdWx0aXBsZSBjaGFubmVscyB0byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59IGNoYW5uZWxzIC0gVGhlIGNoYW5uZWxzIHRvIGFkZC5cbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCNjaGFubmVsc2FkZGVkXG4gICAgICogQGFzeW5jXG4gICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWw+fSBBZGRlZCBjaGFubmVscyB3aXRoIHRoZWlyIElEIHNldC5cbiAgICAgKi9cbiAgICBhZGRDaGFubmVscyhjaGFubmVscykge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDaGFubmVsTGlzdC5hZGRDaGFubmVscyhjaGFubmVscylcIik7XG4gICAgICAgIGlmKGNoYW5uZWxzIGluc3RhbmNlb2YgQ2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2hhbm5lbChjaGFubmVscykudGhlbigoY2hhbm5lbCkgPT4gWyBjaGFubmVsIF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheShjaGFubmVscykpIHtcbiAgICAgICAgICAgIGlmKGNoYW5uZWxzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2hhbm5lbChjaGFubmVsc1swXSkudGhlbigoY2hhbm5lbCkgPT4gWyBjaGFubmVsIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihjaGFubmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihcImNoYW5uZWxzXCIsIFwicmVhZHdyaXRlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcImNoYW5uZWxzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzdG9yZS5pbmRleChcInR5cGVuYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDaGFubmVscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcmVxID0gaW5kZXguZ2V0KFsgY2hhbm5lbC50eXBlLCBjaGFubmVsLmxvZ2luIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWlyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWRkaW5nIGNoYW5uZWwgXCIgKyBjaGFubmVsLmxvZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5sYXN0TW9kaWZpZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5hZGQoY2hhbm5lbC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsc1tpXS5pZCA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkQ2FjaGUuc2V0KGNoYW5uZWwudHlwZSArIGNoYW5uZWwubG9naW4sIHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDaGFubmVscy5wdXNoKGNoYW5uZWxzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNoYW5uZWwgXCIgKyBjaGFubmVsLmxvZ2luICsgXCIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFkZGVkQ2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJjaGFubmVsc2FkZGVkXCIsIGFkZGVkQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRlZENoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB1c2VyIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IHVzZXIgLSBUaGUgY2hhbm5lbCB0byBhZGQuXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3QjdXNlcmFkZGVkXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn0gVGhlIG5ld2x5IGFkZGVkIFVzZXIgd2l0aCBJRC5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRVc2VyKHVzZXIpIHtcbiAgICAgICAgaWYoYXdhaXQgdGhpcy51c2VyRXhpc3RzKHVzZXIubG9naW4sIHVzZXIudHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVXNlciBhbHJlYWR5IGV4aXN0c1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihcInVzZXJzXCIsIFwicmVhZHdyaXRlXCIpLFxuICAgICAgICAgICAgICAgIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoXCJ1c2Vyc1wiKSxcbiAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5hZGQodXNlci5zZXJpYWxpemUoKSk7XG5cbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdXNlci5pZCA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VyKTtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXNlcmFkZGVkXCIsIHVzZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGEgb2YgYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmV3IGRhdGEgZm9yIHRoZSBjaGFubmVsLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I2NoYW5uZWx1cGRhdGVkXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbH0gVGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBjaGFubmVsLlxuICAgICAqL1xuICAgIGFzeW5jIHNldENoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDaGFubmVsTGlzdC5zZXRDaGFubmVsKFwiICsgY2hhbm5lbC5pZCArIFwiKVwiKTtcbiAgICAgICAgaWYoIShcImlkXCIgaW4gY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuaWQgPSBhd2FpdCB0aGlzLmdldENoYW5uZWxJZChjaGFubmVsLmxvZ2luLCBjaGFubmVsLnR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihcImNoYW5uZWxzXCIsIFwicmVhZHdyaXRlXCIpLFxuICAgICAgICAgICAgICAgIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoXCJjaGFubmVsc1wiKTtcblxuICAgICAgICAgICAgY2hhbm5lbC5sYXN0TW9kaWZpZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5wdXQoY2hhbm5lbC5zZXJpYWxpemUoKSk7XG5cbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZENhY2hlLnNldChjaGFubmVsLnR5cGUgKyBjaGFubmVsLmxvZ2luLCByZXEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmlkID0gcmVxLnJlc3VsdDsgLy9UT0RPIHdhcyB0aGVyZSBhIHJlYXNvbiB0byBmZXRjaCB0aGUgY2hhbm5lbCBoZXJlP1xuICAgICAgICAgICAgICAgIHJlc29sdmUoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImNoYW5uZWx1cGRhdGVkXCIsIGNoYW5uZWwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGEgb2YgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IHVzZXIgLSBUaGUgbmV3IGRhdGEgZm9yIHRoZSB1c2VyLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I3VzZXJ1cGRhdGVkXG4gICAgICogQHJldHVybnMge21vZHVsZTpjaGFubmVsL2NvcmUuVXNlcn0gVGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSB1c2VyIHN0b3JlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgQ2hhbm5lbExpc3QuXG4gICAgICovXG4gICAgYXN5bmMgc2V0VXNlcih1c2VyKSB7XG4gICAgICAgIGlmKCEoXCJpZFwiIGluIHVzZXIpKSB7XG4gICAgICAgICAgICB1c2VyLmlkID0gYXdhaXQgdGhpcy5nZXRVc2VySWQodXNlci5sb2dpbiwgdXNlci50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFwidXNlcnNcIiwgXCJyZWFkd3JpdGVcIiksXG4gICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcInVzZXJzXCIpLFxuICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLnB1dCh1c2VyLnNlcmlhbGl6ZSgpKTtcblxuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB1c2VyLmlkID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXNlcnVwZGF0ZWRcIiwgdXNlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2hhbm5lbCBmcm9tIHRoZSBsaXN0LiBBbHNvIHJlbW92ZXMgYWxsIHVzZXJzIHRoYXQgaGF2ZSB0aGlzIGNoYW5uZWxcbiAgICAgKiBhcyBmYXZvcml0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBpZCAtIElEIG9yIGxvZ2luIG9mIHRoZSBjaGFubmVsIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVHlwZSBvZiB0aGUgY2hhbm5lbCBpZiBubyBJRCB3YXMgcGFzc2VkLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I2JlZm9yZWNoYW5uZWxkZWxldGVkXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3QjY2hhbm5lbGRlbGV0ZWRcbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBSZXNvbHZlcyB0byB0aGUgcmVtb3ZlZCBjaGFubmVsLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUNoYW5uZWwoaWQsIHR5cGUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQ2hhbm5lbExpc3QucmVtb3ZlQ2hhbm5lbChcIiArIGlkICsgXCIpXCIpO1xuICAgICAgICBpZih0eXBlKSB7XG4gICAgICAgICAgICBpZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhbm5lbElkKGlkLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXQodGhpcywgXCJiZWZvcmVjaGFubmVsZGVsZXRlZFwiLCBpZCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCB0aGlzLmdldENoYW5uZWwoaWQpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVVzZXJzV2l0aEZhdm9yaXRlKGlkKSxcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oXCJjaGFubmVsc1wiLCBcInJlYWR3cml0ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcImNoYW5uZWxzXCIpLFxuICAgICAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicXVldWVkIGRlbGV0aW9uXCIpO1xuXG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZENhY2hlLmRlbGV0ZShjaGFubmVsLnR5cGUgKyBjaGFubmVsLmxvZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImNoYW5uZWxkZWxldGVkXCIsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB1c2VyIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaWQgLSBJRCBvciBsb2dpbiBvZiB0aGUgdXNlciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFR5cGUgb2YgdGhlIHVzZXIgaWYgbm8gSUQgd2FzIHBhc3NlZC5cbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCN1c2VyZGVsZXRlZFxuICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IFJlc29sdmVzIHRvIHRoZSByZW1vdmVkIHVzZXIuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlVXNlcihpZCwgdHlwZSkge1xuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5nZXRVc2VyKGlkLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihcInVzZXJzXCIsIFwicmVhZHdyaXRlXCIpLFxuICAgICAgICAgICAgICAgIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoXCJ1c2Vyc1wiKSxcbiAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5kZWxldGUodXNlci5pZCk7XG5cbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VyKTtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXNlcmRlbGV0ZWRcIiwgdXNlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgY2hhbm5lbCBpcyBpbiB0aGUgQ2hhbm5lbExpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaWQgLSBJRCBvciBsb2dpbiBvZiB0aGUgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVHlwZSBvZiB0aGUgY2hhbm5lbCBpZiBubyBJRCB3YXMgcGFzc2VkLlxuICAgICAqIEBhc3luY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXNvbHZlcyB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY2hhbm5lbCBleGlzdHMuXG4gICAgICovXG4gICAgY2hhbm5lbEV4aXN0cyhpZCwgdHlwZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDaGFubmVsTGlzdC5jaGFubmVsRXhpc3RzKFwiLCBpZCwgXCIsXCIsIHR5cGUsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhbm5lbChpZCwgdHlwZSkudGhlbigoY2hhbm5lbCkgPT4gISFjaGFubmVsLCAoKSA9PiBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB1c2VyIGlzIGluIHRoZSBDaGFubmVsTGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBpZCAtIElEIG9yIGxvZ2luIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBUeXBlIG9mIHRoZSB1c2VyIGlmIG5vIElEIHdhcyBwYXNzZWQuXG4gICAgICogQGFzeW5jXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJlc29sdmVzIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB1c2VyIGV4aXN0cy5cbiAgICAgKi9cbiAgICB1c2VyRXhpc3RzKGlkLCB0eXBlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkNoYW5uZWxMaXN0LnVzZXJFeGlzdHMoXCIsIGlkLCBcIixcIiwgdHlwZSwgXCIpXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXIoaWQsIHR5cGUpLnRoZW4oKGNoYW5uZWwpID0+ICEhY2hhbm5lbCwgKCkgPT4gZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGl2ZSBzdGF0dXMgb2YgdGhlIENoYW5uZWxMaXN0IGFzIGEgd2hvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gQ2hlY2sgdGhlIGxpdmUgc3RhdGUgb2YganVzdCB0aGUgY2hhbm5lbHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCB0eXBlLlxuICAgICAqIEB0b2RvIG1ha2UgbGl2ZSBhbiBpbmRleCBhbmQgdGhlbiBnZXQgYWxsIHRoZSBjaGFubmVscyB0aGF0IGFyZSBsaXZlIGFuZFxuICAgICAqICAgICAgIGNvdW50IHRob3NlLiBUaGF0IHNob3VsZCBiZSBzbGlnaHRseSBmYXN0ZXIgdGhhbiB0aGlzIE8obilcbiAgICAgKiAgICAgICBvcGVyYXRpb24gb24gdGhlIGFycmF5IG9mIGFsbCBjaGFubmVscy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmVzb2x2ZXMgdG8gYSBib29sZWFuIGluZGljYXRpbmcsIGlmIHRoZXJlIGFyZSBhbnkgbGl2ZVxuICAgICAqICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpdmVTdGF0dXModHlwZSkge1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IHRoaXMuZ2V0Q2hhbm5lbHNCeVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBjaGFubmVscy5zb21lKChjaGFubmVsKSA9PiBjaGFubmVsLmxpdmUuaXNMaXZlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVHlwZSBhbGwgdGhlIGNoYW5uZWxzIHNob3VsZCBoYXZlLiBJZiBsZWZ0IG91dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsIGNoYW5uZWxzIGFyZSByZXR1cm5lZC5cbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59XG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHNCeVR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFwiY2hhbm5lbHNcIiksXG4gICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcImNoYW5uZWxzXCIpLFxuICAgICAgICAgICAgICAgIHJldGNoYW5zID0gW107XG5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSByZWplY3Q7XG5cbiAgICAgICAgICAgIGlmKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoXCJ0eXBlbmFtZVwiKS5vcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRjaGFucy5wdXNoKENoYW5uZWwuZGVzZXJpYWxpemUoY3Vyc29yLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0Y2hhbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVJhbmdlID0gSURCS2V5UmFuZ2Uub25seSh0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzdG9yZS5pbmRleChcInR5cGVcIik7XG5cbiAgICAgICAgICAgICAgICBpbmRleC5vcGVuQ3Vyc29yKGtleVJhbmdlKS5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldGNoYW5zLnB1c2goQ2hhbm5lbC5kZXNlcmlhbGl6ZShjdXJzb3IudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXRjaGFucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHVzZXJzIGluIHRoZSBDaGFubmVsTGlzdCB3aXRoIGEgY2VydGFpbiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFRoZSB0eXBlIGFsbCByZXR1cm5lZCB1c2VycyBzaG91bGQgaGF2ZS4gSWYgbGVmdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgYWxsIHVzZXJzIGFyZSByZXR1cm5lZC5cbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuVXNlcj59XG4gICAgICovXG4gICAgZ2V0VXNlcnNCeVR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFwidXNlcnNcIiksXG4gICAgICAgICAgICAgICAgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcInVzZXJzXCIpLFxuICAgICAgICAgICAgICAgIHJldHVzcnMgPSBbXTtcblxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IHJlamVjdDtcblxuICAgICAgICAgICAgaWYoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5pbmRleChcInR5cGVuYW1lXCIpLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVzcnMucHVzaChVc2VyLmRlc2VyaWFsaXplKGN1cnNvci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVzcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVJhbmdlID0gSURCS2V5UmFuZ2Uub25seSh0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzdG9yZS5pbmRleChcInR5cGVcIik7XG5cbiAgICAgICAgICAgICAgICBpbmRleC5vcGVuQ3Vyc29yKGtleVJhbmdlKS5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVzcnMucHVzaChVc2VyLmRlc2VyaWFsaXplKGN1cnNvci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVzcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB1c2VycyB0aGF0IGhhdmUgdGhlIGdpdmVuIGNoYW5uZWwgYXMgYSBmYXZvcml0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsIC0gQ2hhbm5lbCB0byBzZWFyY2ggdXNlcnMnc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYXZvcml0ZXMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2Vyc0J5RmF2b3JpdGUoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHRoaXMuZ2V0VXNlcnNCeVR5cGUoY2hhbm5lbC50eXBlKTtcbiAgICAgICAgcmV0dXJuIHVzZXJzLmZpbHRlcigodXNlcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTY2FubmluZyB1c2VyIFwiICsgdXNlci5sb2dpbiArIFwiIHdpdGggdGhlIGZhdm9yaXRlcyBcIiArIHVzZXIuZmF2b3JpdGVzKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyLmZhdm9yaXRlcy5pbmRleE9mKGNoYW5uZWwubG9naW4pICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB1c2VycyB0aGF0IGhhdmUgdGhlIGdpdmVuIGNoYW5uZWwgYXMgZmF2b3JpdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbElkIC0gSUQgb2YgdGhlIGNoYW5uZWwgdGhhdCB1c2VycyBoYXZlIGZhdm9yaXRlZC5cbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbGlzdC5DaGFubmVsTGlzdCN1c2VyZGVsZXRlZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyPn1cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVVc2Vyc1dpdGhGYXZvcml0ZShjaGFubmVsSWQpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IHRoaXMuZ2V0Q2hhbm5lbChjaGFubmVsSWQpO1xuICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHRoaXMuZ2V0VXNlcnNCeUZhdm9yaXRlKGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodXNlcnMubWFwKCh1c2VyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbW92aW5nIHVzZXIgXCIgKyB1c2VyLmxvZ2luICsgXCIgYmVjYXVzZSBoZSBmb2xsb3dzIFwiICsgY2hhbm5lbC5sb2dpbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVVc2VyKHVzZXIuaWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjaGFubmVscyB0aGF0IGFyZSBmYXZvcml0ZWQgYnkgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IHVzZXIgLSBVc2VyIHRvIGdldCB0aGUgZmF2b3JpdGVzIG9mLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDaGFubmVsc0J5VXNlckZhdm9yaXRlcyh1c2VyKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gYXdhaXQgdGhpcy5nZXRDaGFubmVsc0J5VHlwZSh1c2VyLnR5cGUpO1xuICAgICAgICByZXR1cm4gY2hhbm5lbHMuZmlsdGVyKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdXNlci5mYXZvcml0ZXMuc29tZSgoY2hhbm5hbWUpID0+IGNoYW5uYW1lID09IGNoYW5uZWwubG9naW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGNoYW5uZWxzIHRoYXQgYXJlIGZhdm9yaXRlZCBieSBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXNlcklkIC0gSUQgb2YgdGhlIHVzZXIgd2hvc2UgZmF2b3JpdGVzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I2NoYW5uZWxkZWxldGVkXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3QjYmVmb3JlY2hhbm5lbGRlbGV0ZWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTpjaGFubmVsL2NvcmUuQ2hhbm5lbD59XG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hhbm5lbHNCeVVzZXJGYXZvcml0ZXModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmdldFVzZXIodXNlcklkKSxcbiAgICAgICAgICAgIGNoYW5uZWxzID0gYXdhaXQgdGhpcy5nZXRDaGFubmVsc0J5VXNlckZhdm9yaXRlcyh1c2VyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hhbm5lbChjaGFubmVsLmlkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBjb250ZW50cyBvZiB0aGUgQ2hhbm5lbExpc3QuIFNvbWV0aW1lcyByZWluaXRpYWxpemVzIHRoZSBEQiBmcm9tXG4gICAgICogc2NyYXRjaC5cbiAgICAgKlxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9saXN0LkNoYW5uZWxMaXN0I2NsZWFyXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL2xpc3QuQ2hhbm5lbExpc3QjcmVhZHlcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdHJ1ZSB0aGUgREIgd2FzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkNoYW5uZWxMaXN0LmNsZWFyXCIpO1xuXG4gICAgICAgIGNvbnN0IGRvbmUgPSAoaGFyZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBlbWl0KHRoaXMsIFwiY2xlYXJcIiwgaGFyZCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhcmQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKHRoaXMuZGIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNsZWFyaW5nIG9iamVjdCBzdG9yZXNcIik7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oWyBcImNoYW5uZWxzXCIsIFwidXNlcnNcIiBdLCBcInJlYWR3cml0ZVwiKSxcbiAgICAgICAgICAgICAgICBjaGFubmVscyA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFwiY2hhbm5lbHNcIiksXG4gICAgICAgICAgICAgICAgdXNlcnMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShcInVzZXJzXCIpLFxuICAgICAgICAgICAgICAgIGNoYW5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuUmVxID0gY2hhbm5lbHMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhblJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICBjaGFuUmVxLm9uc3VjY2VzcyA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXNyUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNyUmVxID0gdXNlcnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdXNyUmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHVzclJlcS5vbnN1Y2Nlc3MgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsgY2hhblByb21pc2UsIHVzclByb21pc2UgXSkudGhlbigoKSA9PiBkb25lKGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlbGV0aW5nIGFuZCByZWluaXRpYWxpemluZyB0aGUgREJcIik7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgc2xvd2VyIHBhdGgsIHNvIHdlIGF2b2lkIGl0LiBJdCBuZWVkcyBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgKiB0byBiZSBkb25lIGluIG9yZGVyIHRvIHNsb3dseSBlcmFzZSB0aGUgd2hvbGUgREIgZnJvbSB0aGUgZGlzaywganVzdFxuICAgICAgICAgICAgICogdG8gcmVpbml0aWFsaXplIGl0IGFmdGVyd2FyZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKE5BTUUpO1xuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiBjb25zb2xlLmxvZyhcIkRlbGV0aW5nIGRhdGFiYXNlIHdhcyBibG9ja2VkXCIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgREIgYWZ0ZXIgaXQncyBiZWVuIGNsZWFyZWQuIERvbid0IHRyeSB0byBmaXggaXQsIGlmIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IHdhbnQgdG8gb3Blbi5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gZG9uZSh0cnVlKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLm9wZW5EQihOQU1FLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBEQi5cbiAgICAgKlxuICAgICAqIEBhc3luY1xuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IERCIGlzIGJlaW5nIGRlbGV0ZWQsIG9yIG1heSBhbHJlYWR5IGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYodGhpcy5kYikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL2NoYW5uZWwvbGlzdC5qcyIsIi8qKlxuICogTW9kZWwgZm9yIHRoZSBjaGFubmVscyBtYW5hZ2VyIGNvbXBvbmVudC5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBjaGFubmVsL21hbmFnZXJcbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJ2V2ZW50LXRhcmdldC1zaGltJztcblxuLyoqXG4gKiBTdG9yZSBhIGNoYW5uZWwuIExpc3RlbmVycyBzaG91bGQgY2FsbFxuICoge0BsaW5rIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI29uQ2hhbm5lbEFkZGVkfSBvbmNlIHRoZVxuICogY2hhbm5lbCB3YXMgYWRkZWQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI2FkZGNoYW5uZWxcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbi8qKlxuICogUmVtb3ZlIGEgY2hhbm5lbCAoZ2l2ZW4gYnkgaXRzIElEKSBhbmQgYWxsIHVzZXJzIHRoYXQgaGF2ZSBpdCBhcyBmYXZvcml0ZS5cbiAqIExpc3RlbmVycyBzaG91bGQgY2FsbFxuICoge0BsaW5rIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI29uQ2hhbm5lbFJlbW92ZWR9IG9uY2UgdGhlXG4gKiBjaGFubmVsIGhhcyBiZWVuIHJlbW92ZWQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI3JlbW92ZWNoYW5uZWxcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbi8qKlxuICogVXBkYXRlIGEgY2hhbm5lbCAoZ2l2ZW4gYnkgaXRzIElEKS4gTGlzdGVuZXJzIHNob3VkbCBjYWxsXG4gKiB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjb25DaGFubmVsVXBkYXRlZH0gb25jZSB0aGVcbiAqIGNoYW5uZWxzIGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI3VwZGF0ZWNoYW5uZWxcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbi8qKlxuICogU3RvcmUgYSB1c2VyLiBMaXN0ZW5lcnMgc2hvdWxkIGNhbGxcbiAqIHtAbGluayBtb2R1bGU6Y2hhbm5lbC9tYW5hZ2VyLkNoYW5uZWxzTWFuYWdlciNvblVzZXJBZGRlZH0gb25jZSB0aGUgdXNlciBoYXNcbiAqIGJlZW4gYWRkZWQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI2FkZHVzZXJcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbi8qKlxuICogUmVtb3ZlIGEgdXNlciAoZ2l2ZW4gYnkgaXQgSUQpLiBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRydWUsIGRlbGV0ZSBhbGxcbiAqIGl0cyBmYXZvcml0ZWQgY2hhbm5lbHMsIHRvby4gTGlzdGVuZXJzIHNob3VsZCBjYWxsXG4gKiB7QGxpbmsgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjb25Vc2VyUmVtb3ZlZH0gb25jZSB0aGUgdXNlclxuICogd2FzIHJlbW92ZWQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI3JlbW92ZXVzZXJcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbi8qKlxuICogVXBkYXRlIHRoZSBmYXZvcml0ZXMgb2YgdGhlIGdpdmVuIHVzZXIgKGJ5IElEKSBvciBhbGwgdXNlcnMsIGlmIG5vIElEIHdhc1xuICogc3BlY2lmaWVkLiBTaG91bGQgY2FsbCB0aGUgYXBwcm9yaWF0ZSB1cGRhdGUgY2FsbGJhY2tzIG9uIHRoZSBDaGFubmVsc01hbmFnZXJcbiAqIG9uY2UgZG9uZS5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjdXBkYXRlZmF2b3JpdGVzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG4vKipcbiAqIFNlYXJjaCBmb3IgYWNjb3VudHMgb2YgdGhlIHVzZXIgb24gc3VwcG9ydGVkIHNpdGVzLlxuICpcbiAqIEBldmVudCBtb2R1bGU6Y2hhbm5lbC9tYW5hZ2VyLkNoYW5uZWxzTWFuYWdlciNhdXRvYWRkXG4gKlxuICovXG4vKipcbiAqIEFkZCBhbGwgZXhpc3RpbmcgY2hhbm5lbHMgYW5kIHVzZXJzIHZpYSB0aGUgb24gY2FsbGJhY2tzLlxuICpcbiAqIEBldmVudCBtb2R1bGU6Y2hhbm5lbC9tYW5hZ2VyLkNoYW5uZWxzTWFuYWdlciNnZXRkYXRhXG4gKi9cbi8qKlxuICogU2hpZnQgY2xpY2tlZCBoZWxwIGJ1dHRvbiB0byBleHBvcnQgZGVidWcgaW5mby5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjZGVidWdkdW1wXG4gKi9cbi8qKlxuICogU2hvdyBhZGQtb24gb3B0aW9ucy5cbiAqXG4gKiBAZXZlbnQgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjc2hvd29wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgZXh0ZXJuYWw6RXZlbnRUYXJnZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbHNNYW5hZ2VyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIF9sb2FkaW5nID0gdHJ1ZTtcbiAgICBwb3J0ID0gbnVsbDtcbiAgICB0YWJJRCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdHNcbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjYWRkY2hhbm5lbFxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9tYW5hZ2VyLkNoYW5uZWxzTWFuYWdlciNyZW1vdmVjaGFubmVsXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI3VwZGF0ZWNoYW5uZWxcbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjYWRkdXNlclxuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9tYW5hZ2VyLkNoYW5uZWxzTWFuYWdlciNyZW1vdmV1c2VyXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI3VwZGF0ZWZhdm9yaXRlc1xuICAgICAqIEBmaXJlcyBtb2R1bGU6Y2hhbm5lbC9tYW5hZ2VyLkNoYW5uZWxzTWFuYWdlciNhdXRvYWRkXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI2dldGRhdGFcbiAgICAgKiBAZmlyZXMgbW9kdWxlOmNoYW5uZWwvbWFuYWdlci5DaGFubmVsc01hbmFnZXIjZGVidWdkdW1wXG4gICAgICogQGZpcmVzIG1vZHVsZTpjaGFubmVsL21hbmFnZXIuQ2hhbm5lbHNNYW5hZ2VyI3Nob3dvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5jYW5jZWxpbmdWYWx1ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgYnJvd3Nlci5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcigocG9ydCkgPT4ge1xuICAgICAgICAgICAgaWYocG9ydC5uYW1lID09IFwibWFuYWdlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBQb3J0KHBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgbG9hZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gICAgfVxuICAgIHNldCBsb2FkaW5nKHZhbCkge1xuICAgICAgICBpZih0aGlzLl9sb2FkaW5nICE9IHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IHZhbDtcbiAgICAgICAgICAgIGlmKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcImlzbG9hZGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcImRvbmVsb2FkaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXR1cFBvcnQocG9ydCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltNYW5hZ2VyXT4gQXR0YWNoZWRcIik7XG4gICAgICAgIGNvbnN0IGlzU2Vjb25kYXJ5ID0gdGhpcy5wb3J0ICE9PSBudWxsO1xuXG4gICAgICAgIGlmKCFpc1NlY29uZGFyeSkge1xuICAgICAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgICAgIHRoaXMudGFiSUQgPSBwb3J0LnNlbmRlci50YWIuaWQ7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9ydC5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFiSUQgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICBwb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYobWVzc2FnZS50YXJnZXQgPT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICAgICAgaWYoaXNTZWNvbmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdFRvV29ya2VyKFwic2Vjb25kYXJ5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbTWFuYWdlcl0+IFBhZ2UgcmVhZHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJnZXRkYXRhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaXNTZWNvbmRhcnkgJiYgbWVzc2FnZS50YXJnZXQgPT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy50YWJJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcInJlbG9hZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG1lc3NhZ2UudGFyZ2V0ID09IFwiYWRkdXNlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYobWVzc2FnZS51c2VybmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbGluZ1ZhbHVlcy5zZXQoXCJ1c2VyXCIgKyBtZXNzYWdlLnR5cGUgKyBtZXNzYWdlLnVzZXJuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJhZGR1c2VyXCIsIG1lc3NhZ2UudXNlcm5hbWUsIG1lc3NhZ2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmNhbmNlbGluZ1ZhbHVlcy5nZXQoXCJ1c2VyXCIgKyBtZXNzYWdlLnR5cGUgKyBtZXNzYWdlLnVzZXJuYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihtZXNzYWdlLnRhcmdldCA9PSBcImF1dG9hZGRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImF1dG9hZGRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG1lc3NhZ2UudGFyZ2V0ID09IFwiYWRkY2hhbm5lbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYobWVzc2FnZS51c2VybmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbGluZ1ZhbHVlcy5zZXQoXCJjaGFubmVsXCIgKyBtZXNzYWdlLnR5cGUgKyBtZXNzYWdlLnVzZXJuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJhZGRjaGFubmVsXCIsIG1lc3NhZ2UudXNlcm5hbWUsIG1lc3NhZ2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmNhbmNlbGluZ1ZhbHVlcy5nZXQoXCJjaGFubmVsXCIgKyBtZXNzYWdlLnR5cGUgKyBtZXNzYWdlLnVzZXJuYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihtZXNzYWdlLnRhcmdldCA9PSBcImNhbmNlbFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxpbmdWYWx1ZXMuc2V0KG1lc3NhZ2UudmFsdWVzLmpvaW4oXCJcIiksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihtZXNzYWdlLnRhcmdldCA9PSBcInJlbW92ZWNoYW5uZWxcIikge1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJyZW1vdmVjaGFubmVsXCIsIG1lc3NhZ2UuY2hhbm5lbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG1lc3NhZ2UudGFyZ2V0ID09IFwicmVtb3ZldXNlclwiKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInJlbW92ZXVzZXJcIiwgbWVzc2FnZS51c2VySWQsIG1lc3NhZ2UucmVtb3ZlRmF2b3JpdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG1lc3NhZ2UudGFyZ2V0ID09IFwidXBkYXRlY2hhbm5lbFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlY2hhbm5lbFwiLCBtZXNzYWdlLmNoYW5uZWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG1lc3NhZ2UudGFyZ2V0ID09IFwidXBkYXRlZmF2b3JpdGVzXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJ1cGRhdGVmYXZvcml0ZXNcIiwgbWVzc2FnZS51c2VySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihtZXNzYWdlLnRhcmdldCA9PSBcImRlYnVnZHVtcFwiIHx8IG1lc3NhZ2UudGFyZ2V0ID09IFwic2hvd29wdGlvbnNcIikge1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgbWVzc2FnZS50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHRoZSBjYW5jZWxpbmcgdmFsdWUgZm9yIGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gT2JqZWN0IHR5cGUgKHVzZXIgb3IgY2hhbm5lbCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyIC0gT2JqZWN0IHByb3ZpZGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBPYmplY3QgbG9naW4uXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBfZGVsZXRlQ2FuY2VsaW5nVmFsdWUodHlwZSwgcHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxpbmdWYWx1ZXMuZGVsZXRlKHR5cGUgKyBwcm92aWRlciArIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IGVtaXRzIHRvIHRoZSB3b3JrZXIgaWYgaXQgYWN0dWFsbHkgZXhpc3RzIChpc24ndCBudWxsKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgLSBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0LlxuICAgICAqIEBwYXJhbSB7P30gZGF0YSAtIERhdGEgdG8gc2VuZC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIF9lbWl0VG9Xb3JrZXIodGFyZ2V0LCAuLi5kYXRhKSB7XG4gICAgICAgIGlmKHRoaXMucG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIG1hbmFnZXIgdGFiLCBpZiBvbmUncyBhbHJlYWR5IG9wZW5lZCwgZWxzZSBvcGVucyBvbmUuXG4gICAgICpcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcmV0dXJucyB7P30gVGhlIHRhYiB3aXRoIHRoZSBjaGFubmVscyBtYW5hZ2VyLlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIGlmKHRoaXMudGFiSUQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICB1cmw6IFwiLi9tYW5hZ2VyL2luZGV4Lmh0bWxcIlxuICAgICAgICAgICAgfSkudGhlbigodGFiKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJJRCA9IHRhYi5pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3Nlci50YWJzLnVwZGF0ZSh0aGlzLnRhYklELCB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcHJvdmlkZXJzIHRvIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBwcm92aWRlcnMgaW4gdGhlIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdC48bW9kdWxlOnByb3ZpZGVycy9nZW5lcmljLXByb3ZpZGVyLkdlbmVyaWNQcm92aWRlcj59IHByb3ZpZGVyc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQXZhaWxhYmUgcHJvdmlkZXJzIGluIHNlcmlhbGl6ZWQgZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGFkZFByb3ZpZGVycyhwcm92aWRlcnMpIHtcbiAgICAgICAgdGhpcy5fZW1pdFRvV29ya2VyKFwiYWRkcHJvdmlkZXJzXCIsIHByb3ZpZGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGNhbGxiYWNrIGlmIGEgY2hhbm5lbCB3YXMgYWRkZWQuIENhbGxlcnMgc2hvdWxkIGNhbGxcbiAgICAgKiBfZGVsZXRlQ2FuY2VsaW5nVmFsdWUgaWYgaW52b2tlZCBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLkNoYW5uZWx9IGNoYW5uZWxPYmogLSBUaGUgYWRkZWQgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG9uQ2hhbm5lbEFkZGVkKGNoYW5uZWxPYmopIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcImFkZFwiLCBjaGFubmVsT2JqLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2hlbiBhIGNoYW5uZWwgd2FzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbElkIC0gSUQgb2YgdGhlIHJlbW92ZWQgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG9uQ2hhbm5lbFJlbW92ZWQoY2hhbm5lbElkKSB7XG4gICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcInJlbW92ZVwiLCBjaGFubmVsSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aGVuIGEgY2hhbm5lbCB3YXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5DaGFubmVsfSBjaGFubmVsT2JqIC0gVGhlIHVwZGF0ZWQgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG9uQ2hhbm5lbFVwZGF0ZWQoY2hhbm5lbE9iaikge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1pdFRvV29ya2VyKFwidXBkYXRlXCIsIGNoYW5uZWxPYmouc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aGVuIGEgdXNlciB3YXMgYWRkZWQuIENhbGxlcnMgc2hvdWxkIGNhbGwgX2RlbGV0ZUNhbmNlbGluZ1ZhbHVlXG4gICAgICogaWYgaW52b2tlZCBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6Y2hhbm5lbC9jb3JlLlVzZXJ9IHVzZXIgLSBUaGUgYWRkZWQgdXNlci5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG9uVXNlckFkZGVkKHVzZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcImFkZHVzZXJcIiwgdXNlci5zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdoZW4gYSB1c2VyIHdhcyByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVzZXJJZCAtIFRoZSBJRCBvZiB0aGUgcmVtb3ZlZCB1c2VyLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgb25Vc2VyUmVtb3ZlZCh1c2VySWQpIHtcbiAgICAgICAgdGhpcy5fZW1pdFRvV29ya2VyKFwicmVtb3ZldXNlclwiLCB1c2VySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aGVuIGEgdXNlciB3YXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmNoYW5uZWwvY29yZS5Vc2VyfSB1c2VyIC0gVGhlIHVzZXIgdGhhdCB3YXMgdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG9uVXNlclVwZGF0ZWQodXNlcikge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1pdFRvV29ya2VyKFwidXBkYXRldXNlclwiLCB1c2VyLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2hlbiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgYWRkaW5nIHNvbWV0aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBOYW1lIG9mIHRoZSBvYmplY3QgdGhhdCB3YXMgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFR5cGUgb2YgdGhlIG9iamVjdCB0aGF0IHdhcyB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2l0ZW1UeXBlXSAtIFR5cGUgb2YgdGhlIG9iamVjdCB0aGF0IGhhZCBhbiBlcnJvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1c2VyL2NoYW5uZWwpLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgb25FcnJvcihuYW1lLCB0eXBlLCBpdGVtVHlwZSkge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZXRlQ2FuY2VsaW5nVmFsdWUoaXRlbVR5cGUsIHR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgLy9UT0RPIG1vdmUgaTE4biB0byBjb250ZW50XG4gICAgICAgICAgICB0aGlzLl9lbWl0VG9Xb3JrZXIoXCJlcnJvclwiLCBuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRUb1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIGFuIGFjdGlvbiBpcyBjYW5jZWxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBOYW1lIG9mIHRoZSBvYmplY3Qgd2hvc2UgYWN0aW9uIHdhcyBjYW5jZWxlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVHlwZS9wcm92aWRlciBvZiB0aGUgb2JqZWN0IHdob3NlIGFjdGlvbiB3YXNcbiAgICAgKiAgICAgICAgY2FuY2VsZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpdGVtVHlwZV0gLSBUeXBlIG9mIHRoZSBvYmplY3Qgd2hvZXNlIGFjdGlvbiB3YXMgY2FjbmVsZWQuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBvbkNhbmNlbChuYW1lLCB0eXBlLCBpdGVtVHlwZSkge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVsZXRlQ2FuY2VsaW5nVmFsdWUoaXRlbVR5cGUsIHR5cGUsIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGhlbWUgb2YgdGhlIGNoYW5uZWwgbWFuYWdlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZSAtIFRoZW1lIElEIG9mIHRoZSB0aGVtZSB0byB1c2UuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzZXRUaGVtZSh0aGVtZSkge1xuICAgICAgICB0aGlzLl9lbWl0VG9Xb3JrZXIoXCJ0aGVtZVwiLCB0aGVtZSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvY2hhbm5lbC9tYW5hZ2VyLmpzIiwiLyoqXG4gKiBDcmVkZW50aWFscyBzZWFyY2ggd3JhcHBlci5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICovXG5cbmltcG9ydCBTREsgZnJvbSBcIi4vc2RrXCI7XG5cbmV4cG9ydCBjb25zdCBzZWFyY2ggPSAoeyB1cmwgfSkgPT4ge1xuICAgIHJldHVybiBTREsuZG9BY3Rpb24oe1xuICAgICAgICB0YXJnZXQ6IFwicGFzc3dvcmRzLXNlYXJjaFwiLFxuICAgICAgICB1cmxcbiAgICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9sb2dpbnMuanMiLCIvKlxuICogQ3JlYXRlZCBieSBNYXJ0aW4gR2lnZXJcbiAqIExpY2Vuc2VkIHVuZGVyIE1QTCAyLjBcbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHFzIGZyb20gXCIuLi9xdWVyeXN0cmluZ1wiO1xuaW1wb3J0IHsgQ2hhbm5lbCwgVXNlciB9IGZyb20gJy4uL2NoYW5uZWwvY29yZSc7XG5pbXBvcnQgeyBQYWdpbmF0aW9uSGVscGVyLCBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIgfSBmcm9tICcuLi9wYWdpbmF0aW9uLWhlbHBlcic7XG5pbXBvcnQgR2VuZXJpY1Byb3ZpZGVyIGZyb20gXCIuL2dlbmVyaWMtcHJvdmlkZXJcIjtcblxuY29uc3QgdHlwZSA9IFwiYXp1YnVcIixcbiAgICBiYXNlVVJMID0gJ2h0dHBzOi8vYXBpLmF6dWJ1LnR2L3B1YmxpYy8nLFxuICAgIHBhZ2VTaXplID0gMTAwO1xuXG5mdW5jdGlvbiBnZXRDaGFubmVsRnJvbUpTT04oanNvbkNoYW5uZWwpIHtcbiAgICBjb25zb2xlLmluZm8oXCJBenVidTpnZXRDaGFubmVsRnJvbUpTT05cIik7XG4gICAgY29uc3QgcmV0ID0gbmV3IENoYW5uZWwoanNvbkNoYW5uZWwudXNlci51c2VybmFtZSwgdHlwZSksXG4gICAgICAgIGNoYW5uZWxVcmwgPSBqc29uQ2hhbm5lbC51cmxfY2hhbm5lbCB8fCBcImh0dHA6Ly93d3cuYXp1YnUudHYvXCIgKyByZXQubG9naW47XG4gICAgaWYoXCJkaXNwbGF5X25hbWVcIiBpbiBqc29uQ2hhbm5lbC51c2VyKSB7XG4gICAgICAgIHJldC51bmFtZSA9IGpzb25DaGFubmVsLnVzZXIuZGlzcGxheV9uYW1lO1xuICAgIH1cbiAgICByZXQudXJsLnB1c2goY2hhbm5lbFVybCk7XG4gICAgcmV0LmFyY2hpdmVVcmwgPSBjaGFubmVsVXJsO1xuICAgIHJldC5jaGF0VXJsID0ganNvbkNoYW5uZWwudXJsX2NoYXQ7XG4gICAgcmV0LmltYWdlID0ge1xuICAgICAgICA1MDoganNvbkNoYW5uZWwudXNlci5wcm9maWxlLnVybF9waG90b19zbWFsbCxcbiAgICAgICAgMjYwOiBqc29uQ2hhbm5lbC51c2VyLnByb2ZpbGUudXJsX3Bob3RvX2xhcmdlXG4gICAgfTtcbiAgICByZXQubGl2ZS5zZXRMaXZlKGpzb25DaGFubmVsLmlzX2xpdmUpO1xuICAgIHJldC50aHVtYm5haWwgPSBqc29uQ2hhbm5lbC51cmxfdGh1bWJuYWlsO1xuICAgIHJldC52aWV3ZXJzID0ganNvbkNoYW5uZWwudmlld19jb3VudDtcbiAgICBpZihyZXQudGl0bGUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0LnRpdGxlID0ganNvbkNoYW5uZWwudGl0bGU7XG4gICAgfVxuICAgIHJldC5jYXRlZ29yeSA9IGpzb25DaGFubmVsLmNhdGVnb3J5LnRpdGxlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmNsYXNzIEF6dWJ1IGV4dGVuZHMgR2VuZXJpY1Byb3ZpZGVyIHtcbiAgICBhdXRoVVJMID0gWyBcImh0dHA6Ly93d3cuYXp1YnUudHZcIiBdO1xuICAgIF9zdXBwb3J0c0Zhdm9yaXRlcyA9IHRydWU7XG4gICAgX3N1cHBvcnRzQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIF9zdXBwb3J0c0ZlYXR1cmVkID0gdHJ1ZTtcblxuICAgIGFzeW5jIGdldFVzZXJGYXZvcml0ZXModXNlcm5hbWUpIHtcbiAgICAgICAgY29uc3QgWyBmb2xsb3dzLCB1c2VyZGF0YSBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyKHtcbiAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyBcInVzZXIvXCIgKyB1c2VybmFtZSArIFwiL2ZvbGxvd2luZ3MvbGlzdD9saW1pdD1cIiArIHBhZ2VTaXplICsgXCImb2Zmc2V0PVwiLFxuICAgICAgICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdCh1cmwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04gJiYgXCJkYXRhXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5kYXRhLmxlbmd0aCA9PSBkYXRhLnBhcnNlZEpTT04ubGltaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBcImRhdGFcIiBpbiBkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04uZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcInVzZXIvXCIgKyB1c2VybmFtZSArIFwiL3Byb2ZpbGVcIilcbiAgICAgICAgXSk7XG4gICAgICAgIGlmKHVzZXJkYXRhLnBhcnNlZEpTT04gJiYgXCJkYXRhXCIgaW4gdXNlcmRhdGEucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKHVzZXJkYXRhLnBhcnNlZEpTT04uZGF0YS51c2VyLnVzZXJuYW1lLCB0aGlzLl90eXBlKTtcbiAgICAgICAgICAgIGlmKFwiZGlzcGxheV9uYW1lXCIgaW4gdXNlcmRhdGEucGFyc2VkSlNPTi5kYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICB1c2VyLnVuYW1lID0gdXNlcmRhdGEucGFyc2VkSlNPTi5kYXRhLnVzZXIuZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlci5pbWFnZSA9IHtcbiAgICAgICAgICAgICAgICA1MDogdXNlcmRhdGEucGFyc2VkSlNPTi5kYXRhLnVybF9waG90b19zbWFsbCxcbiAgICAgICAgICAgICAgICAyNjA6IHVzZXJkYXRhLnBhcnNlZEpTT04uZGF0YS51cmxfcGhvdG9fbGFyZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1c2VyLmZhdm9yaXRlcyA9IGZvbGxvd3MubWFwKChmb2xsb3cpID0+IGZvbGxvdy5mb2xsb3cudXNlcm5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IHRoaXMudXBkYXRlQ2hhbm5lbHMoZm9sbG93cy5tYXAoKGZvbGxvdykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGxvZ2luOiBmb2xsb3cuZm9sbG93LnVzZXJuYW1lIH07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbIHVzZXIsIGNoYW5uZWxzIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGZldGNoIHRoZSBkZXRhaWxzIGZvciB0aGUgYXp1YnUgdXNlciBcIiArIHVzZXJuYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2hhbm5lbERldGFpbHMoY2hhbm5lbG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJjaGFubmVsL1wiICsgY2hhbm5lbG5hbWUpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEuc3RhdHVzID09IDIwMCAmJiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbEZyb21KU09OKGRhdGEucGFyc2VkSlNPTi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgZ2V0dGluZyBjaGFubmVsIGRldGFpbHMgZm9yIGNoYW5uZWwgXCIgKyBjaGFubmVsbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUZhdnNSZXF1ZXN0KHVzZXJzKSB7XG4gICAgICAgIGNvbnN0IHVybHMgPSB1c2Vycy5tYXAoKHVzZXIpID0+IGJhc2VVUkwgKyBcInVzZXIvXCIgKyB1c2VyLmxvZ2luICsgXCIvcHJvZmlsZVwiKTtcbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkxPV19QUklPUklUWSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcihkYXRhLnBhcnNlZEpTT04uZGF0YS51c2VyLnVzZXJuYW1lLCB0aGlzLl90eXBlKTtcbiAgICAgICAgICAgICAgICBpZihcImRpc3BsYXlfbmFtZVwiIGluIGRhdGEucGFyc2VkSlNPTi5kYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci51bmFtZSA9IGRhdGEucGFyc2VkSlNPTi5kYXRhLnVzZXIuZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1c2VyLmltYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICA1MDogZGF0YS5wYXJzZWRKU09OLmRhdGEudXJsX3Bob3RvX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAyNjA6IGRhdGEucGFyc2VkSlNPTi5kYXRhLnVybF9waG90b19sYXJnZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbGRVc2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5sb2dpbiA9PT0gdXNlci5sb2dpbik7XG4gICAgICAgICAgICAgICAgdXNlci5pZCA9IG9sZFVzZXIuaWQ7XG5cbiAgICAgICAgICAgICAgICBuZXcgUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYmFzZVVSTCArIFwidXNlci9cIiArIHVzZXIubG9naW4gKyBcIi9mb2xsb3dpbmdzL2xpc3Q/bGltaXQ9XCIgKyBwYWdlU2l6ZSArIFwiJm9mZnNldD1cIixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIFwiZGF0YVwiIGluIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZGF0YS5sZW5ndGggPT0gZGF0YS5wYXJzZWRKU09OLmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJkYXRhXCIgaW4gZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiAoZm9sbG93cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5mYXZvcml0ZXMgPSBmb2xsb3dzLm1hcCgoZm9sbG93KSA9PiBmb2xsb3cuZm9sbG93LnVzZXJuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJ1cGRhdGVkdXNlclwiLCB1c2VyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhZGQgdGhlIGNoYW5uZWxzIHRoZSB1c2VyIHdhc24ndCBmb2xsb3dpbmcgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hhbm5lbHMoZm9sbG93c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZvbGxvdykgPT4gb2xkVXNlci5mYXZvcml0ZXMuZXZlcnkoKGZhdikgPT4gZmF2ICE9PSBmb2xsb3cuZm9sbG93LnVzZXJuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChmb2xsb3cpID0+ICh7IGxvZ2luOiBmb2xsb3cuZm9sbG93LnVzZXJuYW1lIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgKS50aGVuKChjaGFubmVscykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJuZXdjaGFubmVsc1wiLCBjaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVXNlci5mYXZvcml0ZXMgPSB1c2VyLmZhdm9yaXRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUmVxdWVzdChjaGFubmVscykge1xuICAgICAgICBjb25zdCBjaGFubmVsbmFtZXMgPSBjaGFubmVscy5tYXAoKGNoKSA9PiBjaC5sb2dpbikuam9pbihcIixcIik7XG5cbiAgICAgICAgbmV3IFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgdXJsOiBiYXNlVVJMICsgXCJjaGFubmVsL2xpc3Q/Y2hhbm5lbHM9XCIgKyBjaGFubmVsbmFtZXMgKyBcIiZsaW1pdD1cIiArIHBhZ2VTaXplICsgXCImb2Zmc2V0PVwiLFxuICAgICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgICByZXF1ZXN0OiAodXJsLCBjYWxsYmFjaywgaW5pdGlhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KFsgdXJsIF0sIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTiAmJiBcImRhdGFcIiBpbiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmRhdGEubGVuZ3RoID09PSBkYXRhLnBhcnNlZEpTT04ubGltaXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogKGNoYW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBjaGFucy5tYXAoZ2V0Q2hhbm5lbEZyb21KU09OKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbXMoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQXp1YnUudXBkYXRlQ2hhbm5lbHNcIik7XG4gICAgICAgIGlmKGNoYW5uZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGFubmVsbmFtZXMgPSBjaGFubmVscy5tYXAoKGNoKSA9PiBjaC5sb2dpbikuam9pbihcIixcIik7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2VkUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyBcImNoYW5uZWwvbGlzdD9jaGFubmVscz1cIiArIGNoYW5uZWxuYW1lcyArIFwiJmxpbWl0PVwiICsgcGFnZVNpemUgKyBcIiZvZmZzZXQ9XCIsXG4gICAgICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTiAmJiBcImRhdGFcIiBpbiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmRhdGEubGVuZ3RoID09PSBkYXRhLnBhcnNlZEpTT04ubGltaXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbXMoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKChjaGFucykgPT4gY2hhbnMubWFwKGdldENoYW5uZWxGcm9tSlNPTikpO1xuICAgIH1cbiAgICBnZXRGZWF0dXJlZENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcImNoYW5uZWwvbGl2ZS9saXN0P2xpbWl0PTYwXCIpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBcImRhdGFcIiBpbiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5kYXRhLm1hcChnZXRDaGFubmVsRnJvbUpTT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJObyBmZWF0dXJlZCBjaGFubmVscyBmb3VuZCBmb3IgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgJ21vZHVsZXMvc2VhcmNoL2NoYW5uZWw/JyArIHFzLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBvcmRlckJ5OiAne1wiY2hhbm5lbC51cGRhdGVkQXRcIjpcImRlc2NcIn0nLFxuICAgICAgICAgICAgXCJhY2Nlc3NfdG9rZW5cIjogJycsXG4gICAgICAgICAgICBfZm9ybWF0OiBcImpzb25cIixcbiAgICAgICAgICAgIHE6IHF1ZXJ5XG4gICAgICAgIH0pKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJkYXRhXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04uZGF0YS5tYXAoZ2V0Q2hhbm5lbEZyb21KU09OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiTm8gcmVzdWx0cyBmb3VuZCBmb3IgXCIgKyBxdWVyeSArIFwiIG9uIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9iamVjdC5mcmVlemUobmV3IEF6dWJ1KHR5cGUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9henVidS5qcyIsIi8qKlxuICogQmVhbSBwcm92aWRlci5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBwcm92aWRlcnMvYmVhbVxuICogQHRvZG8gY2hlY2tvdXQgc29ja2V0IGJhc2VkIGV2ZW50c1xuICovXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBVc2VyIH0gZnJvbSAnLi4vY2hhbm5lbC9jb3JlJztcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tIFwidW5kZXJzY29yZVwiO1xuaW1wb3J0IHsgUGFnaW5hdGlvbkhlbHBlciwgcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyIH0gZnJvbSAnLi4vcGFnaW5hdGlvbi1oZWxwZXInO1xuaW1wb3J0IEdlbmVyaWNQcm92aWRlciBmcm9tIFwiLi9nZW5lcmljLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBub3QgfSBmcm9tICcuLi9sb2dpYyc7XG5cbmNvbnN0IHR5cGUgPSBcImJlYW1cIixcbiAgICBjaGF0VVJMID0gXCJodHRwczovL2JlYW0ucHJvL2VtYmVkL2NoYXQvXCIsXG4gICAgYmFzZVVSTCA9ICdodHRwczovL2JlYW0ucHJvL2FwaS92MS8nLFxuICAgIHBhZ2VTaXplID0gNTAsXG4gICAgREVGQVVMVF9BVkFUQVJfVVJMID0gXCJodHRwczovL2JlYW0ucHJvL19sYXRlc3QvaW1nL21lZGlhL3Byb2ZpbGUuanBnXCIsXG4gICAgU0laRVMgPSBbICc1MCcsICc3MCcsICcxNTAnLCAnMzAwJyBdLFxuICAgIGdldEltYWdlRnJvbVVzZXJJRCA9IChpZCkgPT4ge1xuICAgICAgICBjb25zdCBpbWFnZSA9IHt9O1xuICAgICAgICBTSVpFUy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICBpbWFnZVtzXSA9IGAke2Jhc2VVUkx9dXNlcnMvJHtpZH0vYXZhdGFyP3c9JHtzfSZoPSR7c31gO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH07XG5cbmZ1bmN0aW9uIGdldENoYW5uZWxGcm9tSlNPTihqc29uQ2hhbm5lbCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDaGFubmVsKGpzb25DaGFubmVsLnRva2VuLCB0eXBlKTtcbiAgICByZXQubGl2ZS5zZXRMaXZlKGpzb25DaGFubmVsLm9ubGluZSk7XG4gICAgcmV0LnRpdGxlID0ganNvbkNoYW5uZWwubmFtZTtcbiAgICByZXQudmlld2VycyA9IGpzb25DaGFubmVsLnZpZXdlcnNDdXJyZW50O1xuICAgIC8vIHRoaXMgaXMgdGhlIGFjdHVhbCB0aHVtYm5haWwgYW5kIG5vdCBqdXN0IHRoZSBkZWZhdWx0IGNoYW5uZWwgdGh1bWJuYWlsIHRoaW5nLlxuICAgIHJldC50aHVtYm5haWwgPSBcImh0dHBzOi8vdGh1bWJzLmJlYW0ucHJvL2NoYW5uZWwvXCIgKyBqc29uQ2hhbm5lbC5pZCArIFwiLmJpZy5qcGdcIjtcbiAgICByZXQudXJsLnB1c2goXCJodHRwczovL2JlYW0ucHJvL1wiICsganNvbkNoYW5uZWwudG9rZW4pO1xuICAgIHJldC5hcmNoaXZlVXJsID0gXCJodHRwczovL2JlYW0ucHJvL1wiICsganNvbkNoYW5uZWwudG9rZW47XG4gICAgcmV0LmNoYXRVcmwgPSBjaGF0VVJMICsganNvbkNoYW5uZWwudG9rZW47XG4gICAgcmV0Lm1hdHVyZSA9IGpzb25DaGFubmVsLmF1ZGllbmNlID09PSBcIjE4K1wiO1xuICAgIHJldC5pbWFnZSA9IGdldEltYWdlRnJvbVVzZXJJRChqc29uQ2hhbm5lbC51c2VyLmlkKTtcbiAgICBpZihqc29uQ2hhbm5lbC50eXBlICE9PSBudWxsKSB7XG4gICAgICAgIHJldC5jYXRlZ29yeSA9IGpzb25DaGFubmVsLnR5cGUubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VGcm9tQXZhdGFycyhhdmF0YXJzKSB7XG4gICAgY29uc3QgaW1hZ2UgPSB7fTtcbiAgICBpZihBcnJheS5pc0FycmF5KGF2YXRhcnMpICYmIGF2YXRhcnMubGVuZ3RoKSB7XG4gICAgICAgIGF2YXRhcnMuZm9yRWFjaCgoYXZhdGFyKSA9PiB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIFVSTCBnaXZlbiBieSB0aGUgQVBJIGRvZXNuJ3Qgd29yayBhdCB0aGlzIHBvaW50LiBSZWNvbnN0cnVjdFxuICAgICAgICAgICAgICogdGhlIG9uZSB1c2VkIG9uIHRoZSBzaXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbWFnZVthdmF0YXIubWV0YS5zaXplLnNwbGl0KFwieFwiKVswXV0gPSBgaHR0cHM6Ly9pbWFnZXMuYmVhbS5wcm8vJHthdmF0YXIubWV0YS5zaXplfS9odHRwczovL3VwbG9hZHMuYmVhbS5wcm8vYXZhdGFyLyR7YXZhdGFyLnJlbGlkfS5qcGdgO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGltYWdlW1wiMjIwXCJdID0gREVGQVVMVF9BVkFUQVJfVVJMO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG59XG5cbmNsYXNzIEJlYW0gZXh0ZW5kcyBHZW5lcmljUHJvdmlkZXIge1xuICAgIGF1dGhVUkwgPSBbIFwiaHR0cHM6Ly9iZWFtLnByb1wiIF07XG4gICAgX3N1cHBvcnRzRmF2b3JpdGVzID0gdHJ1ZTtcbiAgICBfc3VwcG9ydHNDcmVkZW50aWFscyA9IHRydWU7XG4gICAgX3N1cHBvcnRzRmVhdHVyZWQgPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcih0eXBlKTtcbiAgICAgICAgdGhpcy5fZ2V0VXNlcklkRnJvbVVzZXJuYW1lID0gbWVtb2l6ZSgodXNlcm5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwidXNlcnMvc2VhcmNoP3F1ZXJ5PVwiICsgdXNlcm5hbWUpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYocmVzcG9uc2Uub2sgJiYgcmVzcG9uc2UucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucGFyc2VkSlNPTi5maW5kKCh2YWwpID0+IHZhbC51c2VybmFtZSA9PSB1c2VybmFtZSkuaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGBDb3VsZCBub3QgZmluZCB1c2VyIGZvciAke3VzZXJuYW1lfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFVzZXJGYXZvcml0ZXModXNlcm5hbWUpIHtcbiAgICAgICAgY29uc3QgdXNlcmlkID0gYXdhaXQgdGhpcy5fZ2V0VXNlcklkRnJvbVVzZXJuYW1lKHVzZXJuYW1lKSxcbiAgICAgICAgICAgIHVzZXIgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwidXNlcnMvXCIgKyB1c2VyaWQpO1xuXG4gICAgICAgIGlmKHVzZXIucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBuZXcgVXNlcih1c2VyLnBhcnNlZEpTT04udXNlcm5hbWUsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgaWYoXCJhdmF0YXJzXCIgaW4gdXNlci5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgY2guaW1hZ2UgPSBnZXRJbWFnZUZyb21BdmF0YXJzKHVzZXIucGFyc2VkSlNPTi5hdmF0YXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoLmltYWdlID0gZ2V0SW1hZ2VGcm9tVXNlcklEKHVzZXIucGFyc2VkSlNPTi5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBhd2FpdCBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgICAgIHVybDogYmFzZVVSTCArIFwidXNlcnMvXCIgKyB1c2VyaWQgKyBcIi9mb2xsb3dzP2xpbWl0PVwiICsgcGFnZVNpemUgKyBcIiZwYWdlPVwiLFxuICAgICAgICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIGluaXRpYWxQYWdlOiAwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdCh1cmwpLFxuICAgICAgICAgICAgICAgIGdldFBhZ2VOdW1iZXIocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKytwYWdlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhLCBwYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5sZW5ndGggPT0gcGFnZVNpemU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04gfHwgW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoLmZhdm9yaXRlcyA9IHN1YnNjcmlwdGlvbnMubWFwKChzdWIpID0+IHN1Yi50b2tlbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gYXdhaXQgUHJvbWlzZS5hbGwoc3Vic2NyaXB0aW9ucy5tYXAoKHN1YikgPT4gdGhpcy5nZXRDaGFubmVsRGV0YWlscyhzdWIudG9rZW4pKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbIGNoLCBjaGFubmVscyBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgYENvdWxkIG5vdCBnZXQgZmF2b3JpdGVzIGZvciB1c2VyICR7dXNlcm5hbWV9IG9uICR7dGhpcy5uYW1lfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmF2c1JlcXVlc3QodXNlcnMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgdXNlcnMubWFwKCh1c2VyKSA9PiB0aGlzLl9nZXRVc2VySWRGcm9tVXNlcm5hbWUodXNlci5sb2dpbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGlkKSA9PiBiYXNlVVJMICsgXCJ1c2Vycy9cIiArIGlkKSlcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9xcy5xdWV1ZVVwZGF0ZVJlcXVlc3QodXJscywgdGhpcy5fcXMuTE9XX1BSSU9SSVRZLCAoZGF0YSwgdXJsKSA9PiB7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IG5ldyBVc2VyKGRhdGEucGFyc2VkSlNPTi51c2VybmFtZSwgdGhpcy5fdHlwZSk7XG4gICAgICAgICAgICAgICAgaWYoXCJhdmF0YXJzXCIgaW4gZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoLmltYWdlID0gZ2V0SW1hZ2VGcm9tQXZhdGFycyhkYXRhLnBhcnNlZEpTT04uYXZhdGFycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaC5pbWFnZSA9IGdldEltYWdlRnJvbVVzZXJJRChkYXRhLnBhcnNlZEpTT04uaWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFVzZXIgPSB1c2Vycy5maW5kKCh1c3IpID0+IHVzci5sb2dpbiA9PT0gY2gubG9naW4pO1xuICAgICAgICAgICAgICAgIGNoLmlkID0gb2xkVXNlci5pZDtcblxuICAgICAgICAgICAgICAgIG5ldyBQYWdpbmF0aW9uSGVscGVyKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwgKyBcIi9mb2xsb3dzP2xpbWl0PVwiICsgcGFnZVNpemUgKyBcIiZwYWdlPVwiLFxuICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFBhZ2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdCh1cmwpLFxuICAgICAgICAgICAgICAgICAgICBnZXRQYWdlTnVtYmVyOiAocGFnZSkgPT4gcGFnZSArIDEsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoTmV4dFBhZ2UoZGF0YSwgcGFnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmxlbmd0aCA9PSBwYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbXM6IChkYXRhKSA9PiBkYXRhLnBhcnNlZEpTT04gfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IChmb2xsb3dzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaC5mYXZvcml0ZXMgPSBmb2xsb3dzLm1hcCgoc3ViKSA9PiBzdWIudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWR1c2VyXCIsIGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoZm9sbG93cy5maWx0ZXIoKHN1YikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRVc2VyLmZhdm9yaXRlcy5ldmVyeSgoZmF2KSA9PiBmYXYgIT09IHN1Yi50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5tYXAoKHN1YikgPT4gdGhpcy5nZXRDaGFubmVsRGV0YWlscyhzdWIudG9rZW4pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjaGFubmVscykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJuZXdjaGFubmVsc1wiLCBjaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVXNlci5mYXZvcml0ZXMgPSBjaC5mYXZvcml0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbERldGFpbHMoY2hhbm5lbG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJjaGFubmVscy9cIiArIGNoYW5uZWxuYW1lKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYocmVzcG9uc2UucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsRnJvbUpTT04ocmVzcG9uc2UucGFyc2VkSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yIGdldHRpbmcgdGhlIGRldGFpbHMgZm9yIHRoZSBiZWFtIGNoYW5uZWwgXCIgKyBjaGFubmVsbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVJlcXVlc3QoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IGNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gYCR7YmFzZVVSTH1jaGFubmVscy8ke2NoYW5uZWwubG9naW59YCk7XG4gICAgICAgIHRoaXMuX3FzLnF1ZXVlVXBkYXRlUmVxdWVzdCh1cmxzLCB0aGlzLl9xcy5ISUdIX1BSSU9SSVRZLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGdldENoYW5uZWxGcm9tSlNPTihkYXRhLnBhcnNlZEpTT04pO1xuICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJ1cGRhdGVkY2hhbm5lbHNcIiwgY2hhbm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWF0dXJlZENoYW5uZWxzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcImNoYW5uZWxzP2xpbWl0PTgmcGFnZT0wJm9yZGVyPW9ubGluZSUzQWRlc2MlMkN2aWV3ZXJzQ3VycmVudCUzQWRlc2MlMkN2aWV3ZXJzVG90YWwlM0FkZXNjJndoZXJlPXN1c3BlbmRlZC5lcS4wJTJDb25saW5lLmVxLjFcIik7XG4gICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY2hhbnMgPSBkYXRhLnBhcnNlZEpTT047XG4gICAgICAgICAgICBpZihhd2FpdCBub3QodGhpcy5fbWF0dXJlKCkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbnMgPSBjaGFucy5maWx0ZXIoKGNoKSA9PiBjaC5hdWRpZW5jZSAhPT0gXCIxOCtcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGFucy5tYXAoKGNoYW4pID0+IGdldENoYW5uZWxGcm9tSlNPTihjaGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkRpZG4ndCBmaW5kIGFueSBmZWF0dXJlZCBjaGFubmVscyBmb3IgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwiY2hhbm5lbHM/d2hlcmU9b25saW5lLmVxLjElMkN0b2tlbi5lcS5cIiArIHF1ZXJ5KTtcbiAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjaGFucyA9IGRhdGEucGFyc2VkSlNPTjtcbiAgICAgICAgICAgIGlmKGF3YWl0IG5vdCh0aGlzLl9tYXR1cmUoKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFucyA9IGNoYW5zLmZpbHRlcigoY2gpID0+IGNoLmF1ZGllbmNlICE9PSBcIjE4K1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYW5zLm1hcCgoY2hhbikgPT4gZ2V0Q2hhbm5lbEZyb21KU09OKGNoYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiTm8gcmVzdWx0cyBmb3IgXCIgKyBxdWVyeSArIFwiIG9uIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKG5ldyBCZWFtKHR5cGUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9iZWFtLmpzIiwiLyoqXG4gKiBEYWlseW1vdGlvbiBwcm92aWRlci5cbiAqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBwcm92aWRlcnMvZGFpbHltb3Rpb25cbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IEdlbmVyaWNQcm92aWRlciBmcm9tIFwiLi9nZW5lcmljLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBVc2VyIH0gZnJvbSBcIi4uL2NoYW5uZWwvY29yZVwiO1xuaW1wb3J0IHsgcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyLCBQYWdpbmF0aW9uSGVscGVyIH0gZnJvbSBcIi4uL3BhZ2luYXRpb24taGVscGVyXCI7XG5pbXBvcnQgcXMgZnJvbSBcIi4uL3F1ZXJ5c3RyaW5nXCI7XG5cbmNvbnN0IHR5cGUgPSBcImRhaWx5bW90aW9uXCIsXG4gICAgYmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuZGFpbHltb3Rpb24uY29tL1wiLFxuICAgIEFWQVRBUl9TSVpFUyA9IFsgMjUsIDYwLCA4MCwgMTIwLCAxOTAsIDI0MCwgMzYwLCA0ODAsIDcyMCBdLFxuICAgIFVTRVJfRklFTERTID0gXCJzY3JlZW5uYW1lLHVybCxpZCxcIiArIEFWQVRBUl9TSVpFUy5tYXAoKHMpID0+IFwiYXZhdGFyX1wiICsgcyArIFwiX3VybFwiKS5qb2luKFwiLFwiKSxcbiAgICBnZXRDaGFubmVsRnJvbUpTT04gPSAoanNvbiwgZG9Vc2VyID0gZmFsc2UpID0+IHtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBpZihkb1VzZXIpIHtcbiAgICAgICAgICAgIGNoID0gbmV3IFVzZXIoanNvbi5pZCwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaCA9IG5ldyBDaGFubmVsKGpzb24uaWQsIHR5cGUpO1xuICAgICAgICAgICAgY2gudXJsLnB1c2goanNvbi51cmwpO1xuICAgICAgICAgICAgY2guYXJjaGl2ZVVybCA9IGpzb24udXJsO1xuICAgICAgICB9XG4gICAgICAgIGNoLnVuYW1lID0ganNvbi5zY3JlZW5uYW1lO1xuICAgICAgICBjaC5pbWFnZSA9IEFWQVRBUl9TSVpFUy5yZWR1Y2UoKHAsIGMpID0+IHtcbiAgICAgICAgICAgIHBbY10gPSBqc29uWydhdmF0YXJfJyArIGMgKyAnX3VybCddO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sIHt9KTtcblxuICAgICAgICByZXR1cm4gY2g7XG4gICAgfTtcblxuY2xhc3MgRGFpbHltb3Rpb24gZXh0ZW5kcyBHZW5lcmljUHJvdmlkZXIge1xuICAgIF9zdXBwb3J0c0Zhdm9yaXRlcyA9IHRydWU7XG4gICAgX3N1cHBvcnRzRmVhdHVyZWQgPSB0cnVlO1xuXG4gICAgX2dldENoYW5uZWxCeUlEKGlkLCBkb1VzZXIgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVcmwgKyBcInVzZXIvXCIgKyBpZCArIFwiP1wiICsgcXMuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGZpZWxkczogVVNFUl9GSUVMRFNcbiAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYocmVzdWx0Lm9rICYmIHJlc3VsdC5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgaWYoXCJsaXN0XCIgaW4gcmVzdWx0LnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWxGcm9tSlNPTihyZXN1bHQucGFyc2VkSlNPTi5saXN0WzBdLCBkb1VzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWxGcm9tSlNPTihyZXN1bHQucGFyc2VkSlNPTiwgZG9Vc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgQ291bGQgbm90IGdldCBkZXRhaWxzIGZvciAke2lkfSBvbiAke3RoaXMuX3R5cGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRTdHJlYW1EZXRhaWxzRm9yQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVybCArIFwidXNlci9cIiArIGNoYW5uZWwubG9naW4gKyBcIi92aWRlb3M/XCIgKyBxcy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWQ6IGNoYW5uZWwubG9naW4sXG4gICAgICAgICAgICBmaWVsZHM6IFwiY2hhdF9lbWJlZF91cmwsdGl0bGUsdXJsLGNoYW5uZWwubmFtZSxvbmFpcix0aHVtYm5haWxfMjQwX3VybFwiLFxuICAgICAgICAgICAgc29ydDogXCJsaXZlLWF1ZGllbmNlXCIsXG4gICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICB9KSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLm9rICYmIHJlc3BvbnNlLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICBpZihyZXNwb25zZS5wYXJzZWRKU09OLmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSByZXNwb25zZS5wYXJzZWRKU09OLmxpc3RbMF07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hhdFVybCA9IGl0ZW0uY2hhdF9lbWJlZF91cmw7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwudGh1bWJuYWlsID0gaXRlbS50aHVtYm5haWxfdXJsO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnVybCA9IFsgaXRlbS51cmwgXTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jYXRlZ29yeSA9IGl0ZW1bJ2NoYW5uZWwubmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZShpdGVtLm9uYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC50aXRsZSA9IGl0ZW0udGl0bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYENvdWxkIG5vdCB1cGRhdGUgJHtjaGFubmVsLmxvZ2lufSBvbiAke3RoaXMuX3R5cGV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGYXZzKHVzZXJJZCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyKHtcbiAgICAgICAgICAgIHVybDogYmFzZVVybCArIFwidXNlci9cIiArIHVzZXJJZCArIFwiL2ZvbGxvd2luZz9cIiArIHFzLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBVU0VSX0ZJRUxEUyxcbiAgICAgICAgICAgICAgICBsaW1pdDogMTAwXG4gICAgICAgICAgICB9KSArIFwiJnBhZ2U9XCIsXG4gICAgICAgICAgICBwYWdlU2l6ZTogMSxcbiAgICAgICAgICAgIGluaXRpYWxQYWdlOiAxLFxuICAgICAgICAgICAgcmVxdWVzdDogKHVybCkgPT4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KHVybCksXG4gICAgICAgICAgICBmZXRjaE5leHRQYWdlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5qc29uICYmIGRhdGEucGFyc2VkSlNPTi5oYXNfbW9yZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5vayAmJiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5saXN0Lm1hcChnZXRDaGFubmVsRnJvbUpTT04pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFVzZXJGYXZvcml0ZXModXNlcm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhbm5lbERldGFpbHModXNlcm5hbWUsIHRydWUpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRGYXZzKHVzZXIubG9naW4pLnRoZW4oKGNoYW5uZWxzKSA9PiB7XG4gICAgICAgICAgICAgICAgdXNlci5mYXZvcml0ZXMgPSBjaGFubmVscy5tYXAoKGNoKSA9PiBjaC5sb2dpbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gWyB1c2VyLCBjaGFubmVscyBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDaGFubmVsRGV0YWlscyh1c2VybmFtZSwgZG9Vc2VyID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVXJsICsgXCJ1c2Vycz9cIiArIHFzLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1c2VybmFtZXM6IHVzZXJuYW1lLFxuICAgICAgICAgICAgZmllbGRzOiBVU0VSX0ZJRUxEU1xuICAgICAgICB9KSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYocmVzdWx0Lm9rICYmIHJlc3VsdC5wYXJzZWRKU09OICYmIHJlc3VsdC5wYXJzZWRKU09OLmxpc3QgJiYgcmVzdWx0LnBhcnNlZEpTT04ubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbEZyb21KU09OKHJlc3VsdC5wYXJzZWRKU09OLmxpc3RbMF0sIGRvVXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hhbm5lbEJ5SUQodXNlcm5hbWUsIGRvVXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVGYXZzUmVxdWVzdCh1c2Vycykge1xuICAgICAgICBuZXcgUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICB1cmw6IGJhc2VVcmwgKyBcInVzZXJzP1wiICsgcXMuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBpZHM6IHVzZXJzLm1hcCgoY2gpID0+IGNoLmxvZ2luKS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFVTRVJfRklFTERTLFxuICAgICAgICAgICAgICAgIGxpbWl0OiAxMDBcbiAgICAgICAgICAgIH0pICsgXCImcGFnZT1cIixcbiAgICAgICAgICAgIGluaXRpYWxQYWdlOiAxLFxuICAgICAgICAgICAgcGFnZVNpemU6IDEsXG4gICAgICAgICAgICByZXF1ZXN0OiAodXJsLCBjYWxsYmFjaywgaW5pdGlhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KFsgdXJsIF0sIHRoaXMuX3FzLkxPV19QUklPUklUWSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmZXRjaE5leHRQYWdlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5oYXNfbW9yZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5vayAmJiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5saXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLm1hcCgoZCkgPT4gZ2V0Q2hhbm5lbEZyb21KU09OKGQsIHRydWUpKTtcblxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgodXNlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRVc2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5sb2dpbiA9PSB1c2VyLmxvZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0RmF2cyh1c2VyLmxvZ2luKS50aGVuKChjaGFubmVscykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5mYXZvcml0ZXMgPSBjaGFubmVscy5tYXAoKGNoKSA9PiBjaC5sb2dpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZHVzZXJcIiwgdXNlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gY2hhbm5lbHMuZmlsdGVyKChjaCkgPT4gIW9sZFVzZXIuZmF2b3JpdGVzLnNvbWUoKGMpID0+IGMgPT0gY2gubG9naW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJuZXdjaGFubmVsc1wiLCBjaGFubmVscyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFVzZXIuZmF2b3JpdGVzID0gdXNlci5mYXZvcml0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUmVxdWVzdChjaGFubmVscykge1xuICAgICAgICBuZXcgUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICB1cmw6IGJhc2VVcmwgKyBcInVzZXJzP1wiICsgcXMuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBpZHM6IGNoYW5uZWxzLm1hcCgoY2gpID0+IGNoLmxvZ2luKS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFVTRVJfRklFTERTLFxuICAgICAgICAgICAgICAgIGxpbWl0OiAxMDBcbiAgICAgICAgICAgIH0pICsgXCImcGFnZT1cIixcbiAgICAgICAgICAgIGluaXRpYWxQYWdlOiAxLFxuICAgICAgICAgICAgcGFnZVNpemU6IDEsXG4gICAgICAgICAgICByZXF1ZXN0OiAodXJsLCBjYWxsYmFjaywgaW5pdGlhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KFsgdXJsIF0sIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uaGFzX21vcmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbXMoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEub2sgJiYgZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5saXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04ubGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5tYXAoKHYpID0+IGdldENoYW5uZWxGcm9tSlNPTih2KSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChkYXRhLm1hcCgoY2gpID0+IHRoaXMuX2dldFN0cmVhbURldGFpbHNGb3JDaGFubmVsKGNoKSkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChjaGFubmVscykgPT4gZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBjaGFubmVscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ2hhbm5lbCh1c2VybmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGFubmVsRGV0YWlscyh1c2VybmFtZSkudGhlbigoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0cmVhbURldGFpbHNGb3JDaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgdXJsOiBiYXNlVXJsICsgXCJ1c2Vycz9cIiArIHFzLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgaWRzOiBjaGFubmVscy5tYXAoKGNoKSA9PiBjaC5sb2dpbikuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgZmllbGRzOiBVU0VSX0ZJRUxEUyxcbiAgICAgICAgICAgICAgICBsaW1pdDogMTAwXG4gICAgICAgICAgICB9KSArIFwiJnBhZ2U9XCIsXG4gICAgICAgICAgICBwYWdlU2l6ZTogMSxcbiAgICAgICAgICAgIGluaXRpYWxQYWdlOiAxLFxuICAgICAgICAgICAgcmVxdWVzdDogKHVybCkgPT4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KHVybCksXG4gICAgICAgICAgICBmZXRjaE5leHRQYWdlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5oYXNfbW9yZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5saXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04ubGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXNwb25zZS5tYXAoKGNoKSA9PiB0aGlzLl9nZXRTdHJlYW1EZXRhaWxzRm9yQ2hhbm5lbChnZXRDaGFubmVsRnJvbUpTT04oY2gpKSkpO1xuICAgIH1cbiAgICBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgY29uc3QgcSA9IHtcbiAgICAgICAgICAgIGZpZWxkczogXCJvd25lci5pZCxvd25lci5zY3JlZW5uYW1lLG93bmVyLnVybCxjaGF0X2VtYmVkX3VybCx0aXRsZSx1cmwsY2hhbm5lbC5uYW1lLHRodW1ibmFpbF8yNDBfdXJsLFwiICsgQVZBVEFSX1NJWkVTLm1hcCgocykgPT4gXCJvd25lci5hdmF0YXJfXCIgKyBzICsgXCJfdXJsXCIpLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgc29ydDogXCJsaXZlLWF1ZGllbmNlXCIsXG4gICAgICAgICAgICBcImxpdmVfb25haXJcIjogMVxuICAgICAgICB9O1xuICAgICAgICBpZihxdWVyeSkge1xuICAgICAgICAgICAgcS5zZWFyY2ggPSBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVcmwgKyBcInZpZGVvcz9cIiArIHFzLnN0cmluZ2lmeShxKSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYoZGF0YS5vayAmJiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmxpc3QgJiYgZGF0YS5wYXJzZWRKU09OLmxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5saXN0Lm1hcCgoanNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IG5ldyBDaGFubmVsKGpzb25bJ293bmVyLmlkJ10sIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjaC5saXZlLnNldExpdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoLnRpdGxlID0ganNvbi50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgY2gudW5hbWUgPSBqc29uWydvd25lci5zY3JlZW5uYW1lJ107XG4gICAgICAgICAgICAgICAgICAgIGNoLnVybC5wdXNoKGpzb24udXJsLCBqc29uWydvd25lci51cmwnXSk7XG4gICAgICAgICAgICAgICAgICAgIGNoLmFyY2hpdmVVcmwgPSBqc29uWydvd25lci51cmwnXTtcbiAgICAgICAgICAgICAgICAgICAgY2guY2hhdFVybCA9IGpzb24uY2hhdF9lbWJlZF91cmw7XG4gICAgICAgICAgICAgICAgICAgIGNoLmNhdGVnb3J5ID0ganNvblsnY2hhbm5lbC5uYW1lJ107XG4gICAgICAgICAgICAgICAgICAgIGNoLnRodW1ibmFpbCA9IGpzb24udGh1bWJuYWlsXzI0MF91cmw7XG4gICAgICAgICAgICAgICAgICAgIGNoLmltYWdlID0gQVZBVEFSX1NJWkVTLnJlZHVjZSgocCwgcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcFtzXSA9IGpzb25bJ293bmVyLmF2YXRhcl8nICsgcyArICdfdXJsJ107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRGlkbid0IGZpbmQgYW55IHNlYXJjaCByZXN1bHRzIGNoYW5uZWxzIHdpdGggXCIgKyBxdWVyeSArIFwiIGZvciBcIiArIHRoaXMuX3R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShuZXcgRGFpbHltb3Rpb24odHlwZSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL2RhaWx5bW90aW9uLmpzIiwiLyoqXG4gKiBEb3V5dXR2IHByb3ZpZGVyLiBBUEkgcmV2ZXJzZWVuZ2luZWVyaW5nIGlzIGluICMxMjUuXG4gKlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBtb2R1bGUgcHJvdmlkZXJzL2RvdXl1dHZcbiAqIEB0b2RvIHN1cHBvcnQgYWRkaW5nIGJ5IHVybCBzbHVnIG5hbWVcbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbCB9IGZyb20gJy4uL2NoYW5uZWwvY29yZSc7XG5pbXBvcnQgR2VuZXJpY1Byb3ZpZGVyIGZyb20gXCIuL2dlbmVyaWMtcHJvdmlkZXJcIjtcbmltcG9ydCBtZDUgZnJvbSAnbWQ1JztcblxuY29uc3QgdHlwZSA9IFwiZG91eXV0dlwiLFxuICAgIGJhc2VVUkwgPSBcImh0dHA6Ly93d3cuZG91eXV0di5jb20vYXBpL3YxL1wiLFxuICAgIHJvb21VUkwgPSBcImh0dHA6Ly93d3cuZG91eXV0di5jb21cIixcbiAgICBnZXRDaGFubmVsRnJvbUpTT04gPSAoanNvbikgPT4ge1xuICAgICAgICBjb25zdCBjaGFuID0gbmV3IENoYW5uZWwoanNvbi5yb29tX2lkLCB0eXBlKTtcbiAgICAgICAgY2hhbi51bmFtZSA9IGpzb24ucm9vbV9uYW1lO1xuICAgICAgICBjaGFuLnRpdGxlID0ganNvbi5zdWJqZWN0O1xuICAgICAgICBjaGFuLnVybC5wdXNoKHJvb21VUkwgKyBqc29uLnVybCk7XG4gICAgICAgIGNoYW4uaW1hZ2UgPSB7XG4gICAgICAgICAgICAyMDA6IGpzb24ub3duZXJfYXZhdGFyXG4gICAgICAgIH07XG4gICAgICAgIGNoYW4uYXJjaGl2ZVVybCA9IHJvb21VUkwgKyBqc29uLnVybDtcbiAgICAgICAgY2hhbi5saXZlLnNldExpdmUoanNvbi5zaG93X3N0YXR1cyA9PSBcIjFcIik7XG4gICAgICAgIGNoYW4udGh1bWJuYWlsID0ganNvbi5yb29tX3NyYztcbiAgICAgICAgY2hhbi5jYXRlZ29yeSA9IGpzb24uZ2FtZV9uYW1lO1xuICAgICAgICBjaGFuLnZpZXdlcnMgPSBqc29uLm9ubGluZTtcbiAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgfSxcbiAgICBzaWduQVBJID0gKGVuZHBvaW50LCBpZCkgPT4ge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IGVuZHBvaW50ICsgaWQgKyBcIj9haWQ9YW5kcm9pZCZjbGllbnRfc3lzPWFuZHJvaWQmdGltZT1cIiArIERhdGUubm93KCksXG4gICAgICAgICAgICBzaWduID0gbWQ1KGFyZ3VtZW50ICsgJzEyMzEnKTtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50ICsgXCImYXV0aD1cIiArIHNpZ247XG4gICAgfTtcblxuY2xhc3MgRG91eXV0diBleHRlbmRzIEdlbmVyaWNQcm92aWRlciB7XG4gICAgYXV0aFVSTCA9IFsgXCJodHRwOi8vd3d3LmRvdXl1dHYuY29tXCIgXTtcblxuICAgIGdldENoYW5uZWxEZXRhaWxzKHVzZXJuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIHNpZ25BUEkoXCJyb29tL1wiLCB1c2VybmFtZSkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZXJyb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbEZyb21KU09OKGRhdGEucGFyc2VkSlNPTi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGRuJ3QgZ2V0IHJvb20gaW5mbyBmb3IgZG91eXV0diBjaGFubmVsIHdpdGggSUQgXCIgKyB1c2VybmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVJlcXVlc3QoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IGNoYW5uZWxzLm1hcCgoY2gpID0+IGJhc2VVUkwgKyBzaWduQVBJKFwicm9vbS9cIiwgY2gubG9naW4pKTtcbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmVycm9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBnZXRDaGFubmVsRnJvbUpTT04oZGF0YS5wYXJzZWRKU09OLmRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKG5ldyBEb3V5dXR2KHR5cGUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9kb3V5dXR2LmpzIiwiLyoqXG4gKiBSZS1lbWl0cyBldmVudHMgZnJvbSBhbGwgcHJvdmlkZXJzLlxuICpcbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKi9cbmltcG9ydCBwcm92aWRlcnMgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJ2V2ZW50LXRhcmdldC1zaGltJztcblxuY29uc3QgVVNFUl9FVkVOVFMgPSBbXG4gICAgICAgIFwidXBkYXRlZHVzZXJcIixcbiAgICAgICAgXCJuZXdjaGFubmVsc1wiXG4gICAgXSxcbiAgICBCQVNFX0VWRU5UUyA9IFtcbiAgICAgICAgXCJ1cGRhdGVkY2hhbm5lbHNcIlxuICAgIF07XG5cbmNsYXNzIEV2ZW50U2luayBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBmb3IoY29uc3QgcCBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJzW3BdO1xuICAgICAgICAgICAgZm9yKGNvbnN0IGUgb2YgQkFTRV9FVkVOVFMpIHtcbiAgICAgICAgICAgICAgICBwaXBlKHByb3ZpZGVyLCBlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocHJvdmlkZXIuc3VwcG9ydHMuZmF2b3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yKGNvbnN0IGUgb2YgVVNFUl9FVkVOVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGlwZShwcm92aWRlciwgZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudFNpbms7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvZXZlbnRzLmpzIiwiLypcbiAqIENyZWF0ZWQgYnkgTWFydGluIEdpZ2VyXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wXG4gKlxuICogSGl0Ym94IHByb3ZpZGVyXG4gKi9cbmltcG9ydCB7IGVtaXQgfSBmcm9tIFwiLi4vLi4vdXRpbHNcIjtcbmltcG9ydCB7IENoYW5uZWwsIFVzZXIgfSBmcm9tICcuLi9jaGFubmVsL2NvcmUnO1xuaW1wb3J0IEdlbmVyaWNQcm92aWRlciBmcm9tIFwiLi9nZW5lcmljLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIgfSBmcm9tIFwiLi4vcGFnaW5hdGlvbi1oZWxwZXJcIjtcbmltcG9ydCBxdWVyeXN0cmluZyBmcm9tIFwiLi4vcXVlcnlzdHJpbmdcIjtcbmltcG9ydCB7IG5vdCB9IGZyb20gJy4uL2xvZ2ljJztcblxuY29uc3QgdHlwZSA9IFwiaGl0Ym94XCIsXG4gICAgYXJjaGl2ZVVSTCA9IFwiL3ZpZGVvc1wiLFxuICAgIGNoYXRVUkwgPSBcImh0dHBzOi8vaGl0Ym94LnR2L2VtYmVkY2hhdC9cIixcbiAgICBwYWdlU2l6ZSA9IDEwMCxcbiAgICBiYXNlVVJMID0gXCJodHRwczovL2FwaS5oaXRib3gudHZcIixcbiAgICBjZG5VUkwgPSBcImh0dHA6Ly9lZGdlLnNmLmhpdGJveC50dlwiO1xuXG5mdW5jdGlvbiBnZXRDaGFubmVsRnJvbUpzb24oanNvbikge1xuICAgIGNvbnN0IGNobyA9IG5ldyBDaGFubmVsKGpzb24uY2hhbm5lbC51c2VyX25hbWUsIHR5cGUpO1xuICAgIGNoby51bmFtZSA9IGpzb24ubWVkaWFfZGlzcGxheV9uYW1lO1xuICAgIGNoby51cmwucHVzaChqc29uLmNoYW5uZWwuY2hhbm5lbF9saW5rKTtcbiAgICBjaG8uYXJjaGl2ZVVybCA9IGpzb24uY2hhbm5lbC5jaGFubmVsX2xpbmsgKyBhcmNoaXZlVVJMO1xuICAgIGNoby5jaGF0VXJsID0gY2hhdFVSTCArIGpzb24uY2hhbm5lbC51c2VyX25hbWU7XG4gICAgY2hvLmltYWdlID0ge1xuICAgICAgICBcIjIwMFwiOiBjZG5VUkwgKyBqc29uLmNoYW5uZWwudXNlcl9sb2dvLFxuICAgICAgICBcIjUwXCI6IGNkblVSTCArIGpzb24uY2hhbm5lbC51c2VyX2xvZ29fc21hbGxcbiAgICB9O1xuICAgIGNoby50aXRsZSA9IGpzb24ubWVkaWFfc3RhdHVzO1xuICAgIGNoby5jYXRlZ29yeSA9IGpzb24uY2F0ZWdvcnlfbmFtZTtcbiAgICBjaG8udmlld2VycyA9IGpzb24ubWVkaWFfdmlld3M7XG4gICAgY2hvLnRodW1ibmFpbCA9IGNkblVSTCArIGpzb24ubWVkaWFfdGh1bWJuYWlsO1xuICAgIGNoby5saXZlLnNldExpdmUoanNvbi5tZWRpYV9pc19saXZlICE9IFwiMFwiKTtcbiAgICBjaG8ubWF0dXJlID0ganNvbi5tZWRpYV9tYXR1cmUgPT09IFwiMVwiO1xuICAgIHJldHVybiBjaG87XG59XG5cbmNsYXNzIEhpdGJveCBleHRlbmRzIEdlbmVyaWNQcm92aWRlciB7XG4gICAgYXV0aFVSTCA9IFsgXCJodHRwOi8vd3d3LmhpdGJveC50dlwiIF07XG4gICAgX3N1cHBvcnRzRmF2b3JpdGVzID0gdHJ1ZTtcbiAgICBfc3VwcG9ydHNDcmVkZW50aWFscyA9IHRydWU7XG4gICAgX3N1cHBvcnRzRmVhdHVyZWQgPSB0cnVlO1xuXG4gICAgX2dldENoYW5uZWxzKGNoYW5uZWxzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArICcvbWVkaWEvbGl2ZS8nICsgY2hhbm5lbCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEub2sgJiYgZGF0YS5wYXJzZWRKU09OICYmIFwibGl2ZXN0cmVhbVwiIGluIGRhdGEucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbEZyb21Kc29uKGRhdGEucGFyc2VkSlNPTi5saXZlc3RyZWFtWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSkudGhlbigoY2hhbm5lbHMpID0+IGNoYW5uZWxzLmZpbHRlcigoY2hhbm5lbCkgPT4gY2hhbm5lbCAhPT0gbnVsbCkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRVc2VyRmF2b3JpdGVzKHVzZXJuYW1lKSB7XG4gICAgICAgIGNvbnN0IFsgZm9sbG93cywgdXNlciBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyKHtcbiAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyAnL2ZvbGxvd2luZy91c2VyP3VzZXJfbmFtZT0nICsgdXNlcm5hbWUgKyAnJmxpbWl0PScgKyBwYWdlU2l6ZSArICcmb2Zmc2V0PScsXG4gICAgICAgICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogKHVybCkgPT4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KHVybCksXG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhLCBwYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIFwiZm9sbG93aW5nXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5mb2xsb3dpbmcubGVuZ3RoID09IHBhZ2VTaXplO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0SXRlbXMoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJmb2xsb3dpbmdcIiBpbiBkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04uZm9sbG93aW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArICcvdXNlci8nICsgdXNlcm5hbWUpXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGlmKHVzZXIub2sgJiYgdXNlci5wYXJzZWRKU09OICYmIHVzZXIucGFyc2VkSlNPTi51c2VyX25hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzciA9IG5ldyBVc2VyKHVzZXIucGFyc2VkSlNPTi51c2VyX25hbWUsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgdXNyLmltYWdlID0ge1xuICAgICAgICAgICAgICAgIFwiMjAwXCI6IGNkblVSTCArIHVzZXIucGFyc2VkSlNPTi51c2VyX2xvZ28sXG4gICAgICAgICAgICAgICAgXCI1MFwiOiBjZG5VUkwgKyB1c2VyLnBhcnNlZEpTT04udXNlcl9sb2dvX3NtYWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXNyLmZhdm9yaXRlcyA9IGZvbGxvd3MubWFwKChmb2xsb3cpID0+IGZvbGxvdy51c2VyX25hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IHRoaXMuX2dldENoYW5uZWxzKHVzci5mYXZvcml0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFsgdXNyLCBjaGFubmVscyBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBnZXR0aW5nIGluZm8gZm9yIEhpdGJveCB1c2VyIFwiICsgdXNlcm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbm5lbERldGFpbHMoY2hhbm5lbG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgJy9tZWRpYS9saXZlLycgKyBjaGFubmVsbmFtZSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYoZGF0YS5vayAmJiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmxpdmVzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbEZyb21Kc29uKGRhdGEucGFyc2VkSlNPTi5saXZlc3RyZWFtWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgZ2V0dGluZyBkZXRhaWxzIGZvciBIaXRib3ggY2hhbm5lbCBcIiArIGNoYW5uZWxuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlRmF2c1JlcXVlc3QodXNlcnMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IHVzZXJzLm1hcCgodXNlcikgPT4gYmFzZVVSTCArICcvdXNlci8nICsgdXNlci5sb2dpbik7XG4gICAgICAgIHRoaXMuX3FzLnF1ZXVlVXBkYXRlUmVxdWVzdCh1cmxzLCB0aGlzLl9xcy5MT1dfUFJJT1JJVFksIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZihkYXRhLm9rICYmIGRhdGEucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB1c2Vycy5maW5kKCh1c2VyKSA9PiB1c2VyLmxvZ2luID09IGRhdGEucGFyc2VkSlNPTi51c2VyX25hbWUpO1xuICAgICAgICAgICAgICAgIHVzZXIuaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwiMjAwXCI6IGNkblVSTCArIGRhdGEucGFyc2VkSlNPTi51c2VyX2xvZ28sXG4gICAgICAgICAgICAgICAgICAgIFwiNTBcIjogY2RuVVJMICsgZGF0YS5wYXJzZWRKU09OLnVzZXJfbG9nb19zbWFsbFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyAnL2ZvbGxvd2luZy91c2VyP3VzZXJfbmFtZT0nICsgdXNlci5sb2dpbiArICcmbGltaXQ9JyArIHBhZ2VTaXplICsgJyZvZmZzZXQ9JyxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdCh1cmwpLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaE5leHRQYWdlKGRhdGEsIHBhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIFwiZm9sbG93aW5nXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5mb2xsb3dpbmcubGVuZ3RoID09IHBhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJmb2xsb3dpbmdcIiBpbiBkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OLmZvbGxvd2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZvbGxvd3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhbm5lbHMgPSBmb2xsb3dzLmZpbHRlcigoZm9sbG93KSA9PiB1c2VyLmZhdm9yaXRlcy5ldmVyeSgoZmF2KSA9PiBmYXYgIT0gZm9sbG93LnVzZXJfbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmZhdm9yaXRlcyA9IGZvbGxvd3MubWFwKChmb2xsb3cpID0+IGZvbGxvdy51c2VyX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZHVzZXJcIiwgdXNlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDaGFubmVscyhuZXdDaGFubmVscy5tYXAoKGZvbGxvdykgPT4gZm9sbG93LnVzZXJfbmFtZSkpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGNoYW5uZWxzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJuZXdjaGFubmVsc1wiLCBjaGFubmVscyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVSZXF1ZXN0KGNoYW5uZWxzKSB7XG4gICAgICAgIGNvbnN0IHVybHMgPSBjaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGJhc2VVUkwgKyAnL21lZGlhL2xpdmUvJyArIGNoYW5uZWwubG9naW4pO1xuICAgICAgICB0aGlzLl9xcy5xdWV1ZVVwZGF0ZVJlcXVlc3QodXJscywgdGhpcy5fcXMuSElHSF9QUklPUklUWSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEub2sgJiYgZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5saXZlc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBnZXRDaGFubmVsRnJvbUpzb24oZGF0YS5wYXJzZWRKU09OLmxpdmVzdHJlYW1bMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNlYXJjaChxdWVyeSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcIi9tZWRpYS9saXZlL2xpc3Q/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcHVibGljT25seTogdHJ1ZSxcbiAgICAgICAgICAgIGZpbHRlcjogXCJwb3B1bGFyXCIsXG4gICAgICAgICAgICBzZWFyY2g6IHF1ZXJ5XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYoZGF0YS5vayAmJiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmxpdmVzdHJlYW0gJiYgZGF0YS5wYXJzZWRKU09OLmxpdmVzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY2hhbnMgPSBkYXRhLnBhcnNlZEpTT04ubGl2ZXN0cmVhbTtcbiAgICAgICAgICAgIGlmKGF3YWl0IG5vdCh0aGlzLl9tYXR1cmUoKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFucyA9IGNoYW5zLmZpbHRlcigobSkgPT4gbS5tZWRpYV9tYXR1cmUgIT09IFwiMVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYW5zLm1hcCgoY2hhbikgPT4gZ2V0Q2hhbm5lbEZyb21Kc29uKGNoYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiQ291bGRuJ3QgZmluZCBhbnkgY2hhbm5lbHMgZm9yIHRoZSBzZWFyY2ggb24gXCIgKyB0aGlzLm5hbWUgKyBcIiB0aGF0IG1hdGNoIFwiICsgcXVlcnk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9iamVjdC5mcmVlemUobmV3IEhpdGJveCh0eXBlKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvaGl0Ym94LmpzIiwiLyoqXG4gKiBAdG9kbyBpbXBsZW1lbnQgZmF2b3JpdGVzIHN0dWZmXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBwcm92aWRlcnMvbGl2ZXN0cmVhbVxuICovXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeyBDaGFubmVsIH0gZnJvbSAnLi4vY2hhbm5lbC9jb3JlJztcbmltcG9ydCBHZW5lcmljUHJvdmlkZXIgZnJvbSBcIi4vZ2VuZXJpYy1wcm92aWRlclwiO1xuXG5jb25zdCB0eXBlID0gXCJsaXZlc3RyZWFtXCIsXG4gICAgYmFzZVVSTCA9IFwiLmFwaS5jaGFubmVsLmxpdmVzdHJlYW0uY29tLzIuMC9cIjtcblxuZnVuY3Rpb24gZ2V0Q2hhbm5lbEFQSVVybChjaGFubmVsbG9naW4pIHtcbiAgICByZXR1cm4gXCJodHRwOi8veFwiICsgY2hhbm5lbGxvZ2luLnJlcGxhY2UoL18vZywgXCItXCIpICsgXCJ4XCIgKyBiYXNlVVJMO1xufVxuXG5jbGFzcyBMaXZlc3RyZWFtIGV4dGVuZHMgR2VuZXJpY1Byb3ZpZGVyIHtcbiAgICBhdXRoVVJMID0gW1xuICAgICAgICBcImh0dHA6Ly9uZXcubGl2ZXN0cmVhbS5jb21cIixcbiAgICAgICAgXCJodHRwczovL3NlY3VyZS5saXZlc3RyZWFtLmNvbVwiXG4gICAgXTtcblxuICAgIGFzeW5jIGdldENoYW5uZWxEZXRhaWxzKHVzZXJuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNoID0gbmV3IENoYW5uZWwodXNlcm5hbWUudG9Mb3dlckNhc2UoKSwgdGhpcy5fdHlwZSksXG4gICAgICAgICAgICBbIGRhdGEsIHJlc3BvbnNlIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGdldENoYW5uZWxBUElVcmwoY2gubG9naW4pICsgXCJpbmZvLmpzb25cIiksXG4gICAgICAgICAgICAgICAgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGdldENoYW5uZWxBUElVcmwoY2gubG9naW4pICsgXCJsYXRlc3RjbGlwcy5qc29uP21heHJlc3VsdHM9MVwiKVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5jaGFubmVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDcmVhdGluZyBsaXZlc3RyZWFtIGNoYW5uZWxcIik7XG4gICAgICAgICAgICBjaC51bmFtZSA9IGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLnRpdGxlO1xuICAgICAgICAgICAgY2gudGl0bGUgPSBcIlwiO1xuICAgICAgICAgICAgY2gudXJsLnB1c2goZGF0YS5wYXJzZWRKU09OLmNoYW5uZWwubGluayk7XG4gICAgICAgICAgICBjaC5pbWFnZSA9IHsgXCIxMDBcIjogZGF0YS5wYXJzZWRKU09OLmNoYW5uZWwuaW1hZ2UudXJsIH07XG4gICAgICAgICAgICBjaC5jYXRlZ29yeSA9IGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLmNhdGVnb3J5O1xuICAgICAgICAgICAgY2gubGl2ZS5zZXRMaXZlKGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLmlzTGl2ZSk7XG4gICAgICAgICAgICBjaC52aWV3ZXJzID0gZGF0YS5wYXJzZWRKU09OLmNoYW5uZWwuY3VycmVudFZpZXdlckNvdW50O1xuICAgICAgICAgICAgY2guYXJjaGl2ZVVybCA9IGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLmxpbms7XG4gICAgICAgICAgICBjaC5jaGF0VXJsID0gZGF0YS5wYXJzZWRKU09OLmNoYW5uZWwubGluayArIFwiL2NoYXRcIjtcblxuICAgICAgICAgICAgaWYocmVzcG9uc2UucGFyc2VkSlNPTiAmJiByZXNwb25zZS5wYXJzZWRKU09OLmNoYW5uZWwuaXRlbSAmJiByZXNwb25zZS5wYXJzZWRKU09OLmNoYW5uZWwuaXRlbS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2gudGh1bWJuYWlsID0gcmVzcG9uc2UucGFyc2VkSlNPTi5jaGFubmVsLml0ZW1bMF0udGh1bWJuYWlsW1wiQHVybFwiXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBnZXR0aW5nIGRldGFpbHMgZm9yIHRoZSBMaXZlc3RyZWFtIGNoYW5uZWwgXCIgKyB1c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVSZXF1ZXN0KGNoYW5uZWxzKSB7XG4gICAgICAgIGNvbnN0IHVybHMgPSBjaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGdldENoYW5uZWxBUElVcmwoY2hhbm5lbC5sb2dpbikgKyBcImxpdmVzdGF0dXMuanNvblwiKTtcbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIChkYXRhLCB1cmwpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RMb2dpbiA9IHVybC5tYXRjaCgvaHR0cDpcXC9cXC94KFthLXpBLVowLTktXSspeFxcLi8pWzFdLnJlcGxhY2UoXCItXCIsIFwiX1wiKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWxzLmZpbmQoKGNoYW5uZWwpID0+IHJlcXVlc3RMb2dpbiA9PSBjaGFubmVsLmxvZ2luKTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZShkYXRhLnBhcnNlZEpTT04uY2hhbm5lbC5pc0xpdmUpO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudmlld2VycyA9IGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLmN1cnJlbnRWaWV3ZXJDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoZ2V0Q2hhbm5lbEFQSVVybChjaGFubmVsLmxvZ2luKSArIFwibGF0ZXN0Y2xpcHMuanNvbj9tYXhyZXN1bHRzPTFcIikudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJjaGFubmVsXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLml0ZW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnRodW1ibmFpbCA9IGRhdGEucGFyc2VkSlNPTi5jaGFubmVsLml0ZW1bMF0udGh1bWJuYWlsW1wiQHVybFwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZGNoYW5uZWxzXCIsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9iamVjdC5mcmVlemUobmV3IExpdmVzdHJlYW0odHlwZSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL2xpdmVzdHJlYW0uanMiLCIvKipcbiAqIE1MRy50diBQcm92aWRlclxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBtb2R1bGUgcHJvdmlkZXJzL21sZ1xuICovXG4vKlxuSW5vZmZpY2lhbCBNTEcudHYgKG1ham9yIGxlYWd1ZSBnYW1pbmcgc3RyZWFtcykgQVBJIGRvYzpcblxuVXNlcm5hbWU6IGNsZWFydGV4dCB1c2VybmFtZSB1c2VkIGluIHRoZSBjaGFubmVsIFVSTFxuc3RyZWFtX25hbWU6IG1sZ1swLTldKywgd2hpY2ggc2VlbXMgdG8gYmUgdGhlIHN0cmVhbSBJRFxuY2hhbm5lbF9pZDogWzAtOV0rLCB3aGljaCBzZWVtcyB0byBiZSB0aGUgSUQgZm9yIHRoZSBjaGFubmVsICh1c2VkIGluIGltYWdlIFVSTHMgYW5kIGNoYXQpXG5cblxuaHR0cDovL3R2Lm1ham9ybGVhZ3VlZ2FtaW5nLmNvbS9jaGFubmVsL3t1c2VybmFtZX1cbmh0dHA6Ly9jaGF0Lm1ham9ybGVhZ3VlZ2FtaW5nLmNvbS97Y2hhbm5lbF9pZH1cblxuXG5hbGwgb2YgdGhlc2Ugc2VlbSB0byBhbHNvIHN1cHBvcnQgSlNPTlAgd2l0aCB0aGUgY2FsbGJhY2s9IHBhcmFtZXRlci5cbmh0dHA6Ly93d3cubWFqb3JsZWFndWVnYW1pbmcuY29tL3BsYXllci9jb25maWcuanNvbj9pZD17dXNlcm5hbWV9IHVzZXJuYW1lIC0+IG1lZGlhWzBdLmNoYW5uZWxcbmh0dHA6Ly9zdHJlYW1hcGkubWFqb3JsZWFndWVnYW1pbmcuY29tL3NlcnZpY2Uvc3RyZWFtcy9hbGwgc3RhdHVzIG9mIGFsbCBzdHJlYW1zIHdpdGggc3RyZWFtX25hbWUgYW5kIGNoYW5uZWxfaWRcbmh0dHA6Ly9zdHJlYW1hcGkubWFqb3JsZWFndWVnYW1pbmcuY29tL3NlcnZpY2Uvc3RyZWFtcy9zdGF0dXMve3N0cmVhbV9uYW1lfSBzdGF0dXMgYW5kIHZpZXdlciBjb3VudCBvZiBqdXN0IHRoZSBzcGVjaWZpZWQgc3RyZWFtXG4gICAgc3RhdHVzOiAtMSBmb3Igb2ZmbGluZSwgMSBmb3IgbGl2ZSwgMiBmb3IgcmVicm9hZGNhc3Rcbmh0dHA6Ly93d3cubWFqb3JsZWFndWVnYW1pbmcuY29tL2FwaS9jaGFubmVscy9hbGwuanMgQWxsIHRoZSBpbmZvIGFib3V0IGFsbCB0aGUgY2hhbm5lbHNcbiAgICBmaWVsZCBwYXJhbWV0ZXIgY2FuIGxpbWl0IHRoZSBmaWVsZHMuIFlvdSdsbCBmaW5kIHRoZSBhdmFpbGFibGUgZmllbGRzIGlmIHlvdSBkb24ndCBzcGVjaWZ5IGFueVxuaHR0cDovL3d3dy5tYWpvcmxlYWd1ZWdhbWluZy5jb20vYXBpL2dhbWVzL2FsbC5qcyBBbGwgbmFtZXMgYW5kIGltYWdlcyBmb3IgYWxsIGdhbWVfaWQgdmFsdWVzXG5odHRwOi8vc3RyZWFtYXBpLm1ham9ybGVhZ3VlZ2FtaW5nLmNvbS9zZXJ2aWNlL3N0cmVhbXMvcGxheWJhY2sve3N0cmVhbSBuYW1lfT9mb3JtYXQ9YWxsIHBsYXliYWNrIFVSTCArIG5hbWUgJiBpZFxuXG5odHRwczovL2FjY291bnRzLm1ham9ybGVhZ3VlZ2FtaW5nLmNvbS9mb2xsb3dzL3JldHJpZXZlIHJldHVybnMgYWxsIHRoZSBjaGFubmVsIGlkcyB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIChjb29raWUgbWxnX2xvZ2luIGZvciB1c2VybmFtZSwgbWxnX2lkIGZvciB0aGUgaWQpIGZvbGxvd3NcblRoZXJlIGFyZSBhbHNvIHRoZSBhY3Rpb25zIHRvIGZvbGxvdyBhbmQgdW5mb2xsb3cgYSBjaGFubmVsLCBidXQgSSBhbSBub3Qgc3VyZSBob3cgdGhleSB3b3JrLCBhcyBJIGRvbid0IGNhcmUuXG5cbiovXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeyBDaGFubmVsIH0gZnJvbSAnLi4vY2hhbm5lbC9jb3JlJztcbmltcG9ydCBwcmVmcyBmcm9tIFwiLi4vcHJlZmVyZW5jZXNcIjtcbmltcG9ydCBHZW5lcmljUHJvdmlkZXIgZnJvbSBcIi4vZ2VuZXJpYy1wcm92aWRlclwiO1xuaW1wb3J0IExpdmVTdGF0ZSBmcm9tIFwiLi4vY2hhbm5lbC9saXZlLXN0YXRlXCI7XG5cbmNvbnN0IHR5cGUgPSBcIm1sZ1wiLFxuICAgIGNoYXRVUkwgPSBcImh0dHBzOi8vY2hhdC5tYWpvcmxlYWd1ZWdhbWluZy5jb20vXCIsXG4gICAgYmFzZVVSTCA9ICdodHRwczovL3N0cmVhbWFwaS5tYWpvcmxlYWd1ZWdhbWluZy5jb20vc2VydmljZS9zdHJlYW1zLycsXG4gICAgaW5mb1VSTCA9ICdodHRwczovL3d3dy5tYWpvcmxlYWd1ZWdhbWluZy5jb20vYXBpL2NoYW5uZWxzL2FsbC5qcycsXG4gICAgZ2FtZVVSTCA9ICdodHRwczovL3d3dy5tYWpvcmxlYWd1ZWdhbWluZy5jb20vYXBpL2dhbWVzL2FsbC5qcycsXG4gICAgaW5mb0FyZ3MgPSBcIj9maWVsZHM9aWQsc2x1ZyxuYW1lLHN0cmVhbV9uYW1lLHN1YnRpdGxlLGltYWdlXzFfMSxpbWFnZV8xNl85X21lZGl1bSx1cmwsYnJhY2tldF91cmwsZ2FtZV9pZFwiO1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAbmFtZSBTdGF0dXNcbiAqIEByZWFkb25seVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE9mZmxpbmU9LTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMaXZlPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSZWJyb2FkY2FzdD0yXG4gKi9cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6cHJvdmlkZXJzL21sZ35TdGF0dXN9IHN0YXR1cyAtIFN0YXRlIG9mIHRoZSBjaGFubmVsLlxuICogQHJldHVybnMge2Jvb2xlYW59IElmIHRoZSBjaGFubmVsIHNob3VsZCBiZSBjb25zaWRlcmVkIGxpdmUuXG4gKiBAYXN5bmNcbiAqL1xuZnVuY3Rpb24gaXNMaXZlKHN0YXR1cykge1xuICAgIHJldHVybiBwcmVmcy5nZXQoXCJtbGdfc2hvd1JlYnJvYWRjYXN0c1wiKS50aGVuKChzaG93UmVicm9hZGNhc3RzKSA9PiBzdGF0dXMgIT0gLTEgJiYgKHNob3dSZWJyb2FkY2FzdHMgfHwgc3RhdHVzICE9IDIpKTtcbn1cblxuLy8gVGFrZXMgYSBnYW1lX2lkXG5sZXQgZ2FtZXMgPSBbXTtcblxuY2xhc3MgTUxHIGV4dGVuZHMgR2VuZXJpY1Byb3ZpZGVyIHtcbiAgICBhc3luYyBfZ2V0R2FtZShpZCkge1xuICAgICAgICBjb25zdCBnYW1lID0gZ2FtZXMuZmluZCgoZykgPT4gZy5pZCA9PSBpZCk7XG4gICAgICAgIGlmKCFnYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGdhbWVVUkwpO1xuICAgICAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5kYXRhLml0ZW1zICYmIGRhdGEucGFyc2VkSlNPTi5kYXRhLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGdhbWVzID0gZGF0YS5wYXJzZWRKU09OLmRhdGEuaXRlbXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5kYXRhLml0ZW1zLmZpbmQoKGcpID0+IGcuaWQgPT0gaWQpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkYXRhLnBhcnNlZEpTT04gPyBkYXRhLnBhcnNlZEpTT04uZXJyb3JzIDogXCJDb3VsZCBub3QgZmV0Y2ggZ2FtZXMgZm9yIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdhbWUubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZ2V0Q2hhbm5lbEZyb21KU09OKGpzb25DaGFubmVsKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIk1MRzpnZXRDaGFubmVsRnJvbUpTT05cIik7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBDaGFubmVsKGpzb25DaGFubmVsLnN0cmVhbV9uYW1lLCB0aGlzLl90eXBlKTtcbiAgICAgICAgcmV0LnVuYW1lID0ganNvbkNoYW5uZWwubmFtZTtcbiAgICAgICAgcmV0LnVybC5wdXNoKGpzb25DaGFubmVsLnVybCk7XG4gICAgICAgIHJldC5hcmNoaXZlVXJsID0ganNvbkNoYW5uZWwuYnJhY2tldF91cmwgPyBqc29uQ2hhbm5lbC5icmFja2V0X3VybCA6IGpzb25DaGFubmVsLnVybDtcbiAgICAgICAgcmV0LmNoYXRVcmwgPSBjaGF0VVJMICsganNvbkNoYW5uZWwuaWQ7XG4gICAgICAgIHJldC5pbWFnZSA9IHsgXCIyMDBcIjoganNvbkNoYW5uZWwuaW1hZ2VfMV8xIH07XG4gICAgICAgIHJldC50aXRsZSA9IGpzb25DaGFubmVsLnN1YnRpdGxlO1xuICAgICAgICByZXQudGh1bWJuYWlsID0ganNvbkNoYW5uZWwuaW1hZ2VfMTZfOV9tZWRpdW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnYW1lID0gYXdhaXQgdGhpcy5fZ2V0R2FtZShqc29uQ2hhbm5lbC5nYW1lX2lkKTtcbiAgICAgICAgICAgIHJldC5jYXRlZ29yeSA9IGdhbWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gaW5nb3JlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGFubmVsRGV0YWlscyhjaGFubmVsbmFtZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGluZm9VUkwgKyBpbmZvQXJncyk7XG4gICAgICAgIGlmKGRhdGEub2sgJiYgZGF0YS5wYXJzZWRKU09OLnN0YXR1c19jb2RlID09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgY2hvID0gZGF0YS5wYXJzZWRKU09OLmRhdGEuaXRlbXMuZmluZCgoY2gpID0+IGNoLnNsdWcudG9Mb3dlckNhc2UoKSA9PSBjaGFubmVsbmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmKGNobykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDaGFubmVsRnJvbUpTT04oY2hvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGdldCB0aGUgY2hhbm5lbCBkZXRhaWxzIGZvciBcIiArIGNoYW5uZWxuYW1lICsgXCIgZm9yIFwiICsgdGhpcy5uYW1lO1xuICAgIH1cbiAgICB1cGRhdGVSZXF1ZXN0KGNoYW5uZWxzKSB7XG4gICAgICAgIHRoaXMuX3FzLnF1ZXVlVXBkYXRlUmVxdWVzdChbIGJhc2VVUkwgKyBcImFsbFwiIF0sIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGluZm9VUkwgKyBpbmZvQXJncyk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uc3RhdHVzX2NvZGUgPT0gMjAwICYmIGluZm8ucGFyc2VkSlNPTiAmJiBpbmZvLnBhcnNlZEpTT04uc3RhdHVzX2NvZGUgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5zID0gZGF0YS5wYXJzZWRKU09OLmRhdGEuaXRlbXMuZmlsdGVyKChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxzLnNvbWUoKGNoYW5uZWwpID0+IHN0YXR1cy5zdHJlYW1fbmFtZSA9PSBjaGFubmVsLmxvZ2luKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNoYW5zID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hhbnMubWFwKGFzeW5jIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IHRoaXMuX2dldENoYW5uZWxGcm9tSlNPTihpbmZvLnBhcnNlZEpTT04uZGF0YS5pdGVtcy5maW5kKChjaCkgPT4gY2guaWQgPT0gc3RhdHVzLmNoYW5uZWxfaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhdHVzLnN0YXR1cyA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUgPSBuZXcgTGl2ZVN0YXRlKExpdmVTdGF0ZS5SRUJST0FEQ0FTVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZShhd2FpdCBpc0xpdmUoc3RhdHVzLnN0YXR1cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZGNoYW5uZWxzXCIsIGNoYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUNoYW5uZWwoY2hhbm5lbG5hbWUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTUxHLnVwZGF0ZUNoYW5uZWxcIik7XG4gICAgICAgIGNvbnN0IFsgZGF0YSwgaW5mbyBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyAnc3RhdHVzLycgKyBjaGFubmVsbmFtZSksXG4gICAgICAgICAgICB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoaW5mb1VSTCArIGluZm9BcmdzKVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTUxHLnVwZGF0ZUNoYW5uZWwucmVxdWVzdENhbGxiYWNrXCIpO1xuICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLnN0YXR1c19jb2RlID09IDIwMCAmJiBpbmZvLnBhcnNlZEpTT04gJiYgaW5mby5wYXJzZWRKU09OLnN0YXR1c19jb2RlID09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBpbmZvLnBhcnNlZEpTT04uZGF0YS5pdGVtcy5maW5kKChjaCkgPT4gY2guaWQgPT0gZGF0YS5wYXJzZWRKU09OLmRhdGEuY2hhbm5lbF9pZCksXG4gICAgICAgICAgICAgICAgY2hhbm5lbCA9IGF3YWl0IHRoaXMuX2dldENoYW5uZWxGcm9tSlNPTihpZCk7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04uZGF0YS5zdGF0dXMgPT0gMikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZSA9IG5ldyBMaXZlU3RhdGUoTGl2ZVN0YXRlLlJFQlJPQURDQVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKGF3YWl0IGlzTGl2ZShkYXRhLnBhcnNlZEpTT04uZGF0YS5zdGF0dXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5uZWwudmlld2VycyA9IGRhdGEucGFyc2VkSlNPTi5kYXRhLnZpZXdlcnM7XG5cbiAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd2VudCB3cm9uZyB3aGVuIHVwZGF0aW5nIFwiICsgY2hhbm5lbG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTUxHLnVwZGF0ZUNoYW5uZWxzXCIpO1xuICAgICAgICBjb25zdCBbIGRhdGEsIGluZm8gXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJhbGxcIiksXG4gICAgICAgICAgICB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoaW5mb1VSTCArIGluZm9BcmdzKVxuICAgICAgICBdKTtcblxuICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLnN0YXR1c19jb2RlID09IDIwMCAmJiBpbmZvLnBhcnNlZEpTT04gJiYgaW5mby5wYXJzZWRKU09OLnN0YXR1c19jb2RlID09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgZm9sbG93ZWRDaGFubmVscyA9IGRhdGEucGFyc2VkSlNPTi5kYXRhLml0ZW1zLmZpbHRlcigoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxzLnNvbWUoKGNoYW5uZWwpID0+IHN0YXR1cy5zdHJlYW1fbmFtZSA9PSBjaGFubmVsLmxvZ2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZvbGxvd2VkQ2hhbm5lbHMubWFwKGFzeW5jIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGluZm8ucGFyc2VkSlNPTi5kYXRhLml0ZW1zLmZpbmQoKGNoKSA9PiBjaC5pZCA9PSBzdGF0dXMuY2hhbm5lbF9pZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IHRoaXMuX2dldENoYW5uZWxGcm9tSlNPTihpZCk7XG4gICAgICAgICAgICAgICAgaWYoc3RhdHVzLnN0YXR1cyA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZSA9IG5ldyBMaXZlU3RhdGUoTGl2ZVN0YXRlLlJFQlJPQURDQVNUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKGF3YWl0IGlzTGl2ZShzdGF0dXMuc3RhdHVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiQ291bGQgbm90IHVwZGF0ZSBjaGFubmVsc1wiO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShuZXcgTUxHKHR5cGUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9tbGcuanMiLCIvKipcbiAqIE5ldyBsaXZlc3RyZWFtIHByb3ZpZGVyLiBGb3IgQVBJIHJldmVyc2VlbmlnbmVlcmluZyBzZWUgSXNzdWUgIzk5XG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBwcm92aWRlcnMvbmV3LWxpdmVzdHJlYW1cbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbCwgVXNlciB9IGZyb20gXCIuLi9jaGFubmVsL2NvcmVcIjtcbmltcG9ydCBHZW5lcmljUHJvdmlkZXIgZnJvbSBcIi4vZ2VuZXJpYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyIH0gZnJvbSBcIi4uL3BhZ2luYXRpb24taGVscGVyXCI7XG5cbmNvbnN0IHR5cGUgPSBcIm5ld2xpdmVzdHJlYW1cIixcbiAgICBiYXNlVVJMID0gXCJodHRwOi8vbGl2ZXN0cmVhbS5jb20vYXBpL2FjY291bnRzL1wiLFxuICAgIGdldENoYW5uZWxGcm9tSlNPTiA9IChqc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW4gPSBuZXcgQ2hhbm5lbChqc29uLnNob3J0X25hbWUgfHwganNvbi5pZCwgdHlwZSk7XG4gICAgICAgIGNoYW4udW5hbWUgPSBqc29uLmZ1bGxfbmFtZTtcbiAgICAgICAgY2hhbi5pbWFnZSA9IHtcbiAgICAgICAgICAgIFtqc29uLnBpY3R1cmUud2lkdGhdOiBqc29uLnBpY3R1cmUudXJsLFxuICAgICAgICAgICAgXCIxNzBcIjoganNvbi5waWN0dXJlLnNtYWxsX3VybCxcbiAgICAgICAgICAgIFwiNTBcIjoganNvbi5waWN0dXJlLnRodW1iX3VybFxuICAgICAgICB9O1xuICAgICAgICBjaGFuLmNhdGVnb3J5ID0ganNvbi5jYXRlZ29yeV9uYW1lO1xuICAgICAgICBjaGFuLmFyY2hpdmVVcmwgPSBcImh0dHA6Ly9saXZlc3RyZWFtLmNvbS9cIiArIGNoYW4ubG9naW47XG4gICAgICAgIGNoYW4uY2hhdFVybCA9IFwiaHR0cDovL2xpdmVzdHJlYW0uY29tL1wiICsgY2hhbi5sb2dpbjtcbiAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgfTtcblxuY2xhc3MgTmV3TGl2ZXN0cmVhbSBleHRlbmRzIEdlbmVyaWNQcm92aWRlciB7XG4gICAgYXV0aFVSTCA9IFsgXCJodHRwOi8vbGl2ZXN0cmVhbS5jb21cIiBdO1xuICAgIHN1cHBvcnRzRmF2b3JpdGVzID0gdHJ1ZTtcblxuICAgIGFzeW5jIF9nZXRDaGFubmVsU3RhdHVzKGpzb24sIGNoYW5uZWwpIHtcbiAgICAgICAvLyBDaGVja3MgaWYgdGhlcmUgYXJlIGFueSB1cGNvbWluZyBvciBwYXN0IGV2ZW50cyBhbmQgaWYgeWVzLCBpZiBvbmUgaXMgY3VycmVudGx5IGJlaW5nIGJyb2FkY2FzdC5cbiAgICAgICAgY29uc3QgZXZlbnQgPSAoQXJyYXkuaXNBcnJheShqc29uLnVwY29taW5nX2V2ZW50cy5kYXRhKSAmJiBqc29uLnVwY29taW5nX2V2ZW50cy5kYXRhLmZpbmQoKGV2ZW50KSA9PiBldmVudC5icm9hZGNhc3RfaWQgIT0gLTEpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoanNvbi5wYXN0X2V2ZW50cy5kYXRhKSAmJiBqc29uLnBhc3RfZXZlbnRzLmRhdGEuZmluZCgoZXZlbnQpID0+IGV2ZW50LmJyb2FkY2FzdF9pZCAhPSAtMSkpO1xuXG4gICAgICAgIGlmKGV2ZW50KSB7XG4gICAgICAgICAgICBjaGFubmVsLnRpdGxlID0gZXZlbnQuZnVsbF9uYW1lO1xuICAgICAgICAgICAgY2hhbm5lbC52aWV3ZXJzID0gZXZlbnQudmlld2VyX2NvdW50O1xuICAgICAgICAgICAgY2hhbm5lbC51cmwucHVzaChcImh0dHA6Ly9saXZlc3RyZWFtLmNvbS9cIiArIGNoYW5uZWwubG9naW4gKyBcIi9ldmVudHMvXCIgKyBldmVudC5pZCk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBqc29uLmlkICsgXCIvZXZlbnRzL1wiICsgZXZlbnQuaWQgKyBcIi9zdHJlYW1faW5mb1wiKTtcblxuICAgICAgICAgICAgaWYoaW5mby5wYXJzZWRKU09OICYmICEoXCJtZXNzYWdlXCIgaW4gaW5mby5wYXJzZWRKU09OKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKGluZm8ucGFyc2VkSlNPTi5pc19saXZlKTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLnRodW1ibmFpbCA9IGluZm8ucGFyc2VkSlNPTi50aHVtYm5haWxfdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH1cbiAgICBhc3luYyBnZXRVc2VyRmF2b3JpdGVzKHVzZXJuYW1lKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIHVzZXJuYW1lKTtcblxuICAgICAgICBpZih1c2VyLnBhcnNlZEpTT04gJiYgXCJpZFwiIGluIHVzZXIucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgY29uc3QgdXNyID0gbmV3IFVzZXIodXNlci5wYXJzZWRKU09OLnNob3J0X25hbWUgfHwgdXNlci5wYXJzZWRKU09OLmlkLCB0aGlzLl90eXBlKTtcbiAgICAgICAgICAgIHVzci51bmFtZSA9IHVzZXIucGFyc2VkSlNPTi5mdWxsX25hbWU7XG4gICAgICAgICAgICB1c3IuaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgW3VzZXIucGFyc2VkSlNPTi5waWN0dXJlLndpZHRoXTogdXNlci5wYXJzZWRKU09OLnBpY3R1cmUudXJsLFxuICAgICAgICAgICAgICAgIFwiMTcwXCI6IHVzZXIucGFyc2VkSlNPTi5waWN0dXJlLnNtYWxsX3VybCxcbiAgICAgICAgICAgICAgICBcIjUwXCI6IHVzZXIucGFyc2VkSlNPTi5waWN0dXJlLnRodW1iX3VybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZvbGxvd3MgPSBhd2FpdCBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyB1c2VyLnBhcnNlZEpTT04uaWQgKyBcIi9mb2xsb3dpbmc/bWF4SXRlbXM9NTAmcGFnZT1cIixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IDUwLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiAodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZldGNoTmV4dFBhZ2UoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04udG90YWwgPiB0aGlzLnJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW1zKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBcImRhdGFcIiBpbiBkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFBhZ2VOdW1iZXIocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2UgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2hhbm5lbHMgPSBmb2xsb3dzLm1hcCgoZm9sbG93KSA9PiBnZXRDaGFubmVsRnJvbUpTT04oZm9sbG93KSk7XG5cbiAgICAgICAgICAgIHVzci5mYXZvcml0ZXMgPSBjaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwubG9naW4pO1xuICAgICAgICAgICAgcmV0dXJuIFsgdXNyLCBjaGFubmVscyBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJDb3VsZG4ndCBnZXQgZmF2b3JpdGVzIGZvciB0aGUgY2hhbm5lbCBcIiArIHVzZXJuYW1lICsgXCIgb24gXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbm5lbERldGFpbHMoY2hhbm5lbG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgY2hhbm5lbG5hbWUpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBcImlkXCIgaW4gZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWxGcm9tSlNPTihkYXRhLnBhcnNlZEpTT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDb3VsZG4ndCBnZXQgZGV0YWlscyBmb3IgdGhlIFwiICsgdGhpcy5uYW1lICsgXCIgY2hhbm5lbCBcIiArIGNoYW5uZWxuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlRmF2c1JlcXVlc3QodXNlcnMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IHVzZXJzLm1hcCgodXNlcikgPT4gYmFzZVVSTCArIHVzZXIubG9naW4pO1xuICAgICAgICB0aGlzLl9xcy5xdWV1ZVVwZGF0ZVJlcXVlc3QodXJscywgdGhpcy5fcXMuTE9XX1BSSU9SSVRZLCAodXNlcikgPT4ge1xuICAgICAgICAgICAgaWYodXNlci5wYXJzZWRKU09OICYmIFwiaWRcIiBpbiB1c2VyLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c3IgPSB1c2Vycy5maW5kKCh1KSA9PiB1LmxvZ2luID09IHVzZXIucGFyc2VkSlNPTi5pZCB8fCB1LmxvZ2luID09IHVzZXIucGFyc2VkSlNPTi5zaG9ydF9uYW1lKTtcbiAgICAgICAgICAgICAgICB1c3IudW5hbWUgPSB1c2VyLnBhcnNlZEpTT04uZnVsbF9uYW1lO1xuICAgICAgICAgICAgICAgIHVzci5pbWFnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgW3VzZXIucGFyc2VkSlNPTi5waWN0dXJlLndpZHRoXTogdXNlci5wYXJzZWRKU09OLnBpY3R1cmUudXJsLFxuICAgICAgICAgICAgICAgICAgICBcIjE3MFwiOiB1c2VyLnBhcnNlZEpTT04ucGljdHVyZS5zbWFsbF91cmwsXG4gICAgICAgICAgICAgICAgICAgIFwiNTBcIjogdXNlci5wYXJzZWRKU09OLnBpY3R1cmUudGh1bWJfdXJsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyB1c2VyLnBhcnNlZEpTT04uaWQgKyBcIi9mb2xsb3dpbmc/bWF4SXRlbXM9NTAmcGFnZT1cIixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IDUwLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiAodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZldGNoTmV4dFBhZ2UoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04udG90YWwgPiB0aGlzLnJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW1zKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBcImRhdGFcIiBpbiBkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFBhZ2VOdW1iZXIocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2UgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbigoZm9sbG93cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IGZvbGxvd3MubWFwKChmb2xsb3cpID0+IGdldENoYW5uZWxGcm9tSlNPTihmb2xsb3cpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoYW5uZWxzID0gY2hhbm5lbHMuZmlsdGVyKChjaGFubmVsKSA9PiB1c3IuZmF2b3JpdGVzLnNvbWUoKGNoKSA9PiBjaC5sb2dpbiA9PSBjaGFubmVsLmxvZ2luKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5ld0NoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzci5mYXZvcml0ZXMgPSBjaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwubG9naW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJ1cGRhdGVkdXNlclwiLCB1c3IpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwibmV3Y2hhbm5lbHNcIiwgbmV3Q2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUmVxdWVzdChjaGFubmVscykge1xuICAgICAgICBjb25zdCB1cmxzID0gY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBiYXNlVVJMICsgY2hhbm5lbC5sb2dpbik7XG4gICAgICAgIHRoaXMuX3FzLnF1ZXVlVXBkYXRlUmVxdWVzdCh1cmxzLCB0aGlzLl9xcy5ISUdIX1BSSU9SSVRZLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIFwiaWRcIiBpbiBkYXRhLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gZ2V0Q2hhbm5lbEZyb21KU09OKGRhdGEucGFyc2VkSlNPTik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRDaGFubmVsU3RhdHVzKGRhdGEucGFyc2VkSlNPTiwgY2hhbm5lbCkudGhlbigoY2hhbm5lbCkgPT57XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJ1cGRhdGVkY2hhbm5lbHNcIiwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDaGFubmVsKGNoYW5uZWxuYW1lKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIGNoYW5uZWxuYW1lKTtcblxuICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJpZFwiIGluIGRhdGEucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGdldENoYW5uZWxGcm9tSlNPTihkYXRhLnBhcnNlZEpTT04pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hhbm5lbFN0YXR1cyhkYXRhLnBhcnNlZEpTT04sIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJDb3VsZG4ndCBnZXQgZGV0YWlscyBmb3IgdGhlIG5ldyBsaXZlc3RyZWFtIGNoYW5uZWwgXCIgKyBjaGFubmVsbmFtZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShuZXcgTmV3TGl2ZXN0cmVhbSh0eXBlKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvbmV3LWxpdmVzdHJlYW0uanMiLCIvKipcbiAqIFByb3ZpZGVyIGZvciBwaWNhcnRvLlxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBtb2R1bGUgcHJvdmlkZXJzL3BpY2FydG9cbiAqIEB0b2RvIEZpeCBsaXZlIHN0YXR1cyBkZXRlY3Rpb24uIFByb2JhYmx5IG5vdCBwb3NzaWJsZSBiZWZvcmUgcGljYXJ0byBnZXRzIGFuIEFQSS5cbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHsgQ2hhbm5lbCB9IGZyb20gJy4uL2NoYW5uZWwvY29yZSc7XG5pbXBvcnQgR2VuZXJpY1Byb3ZpZGVyIGZyb20gXCIuL2dlbmVyaWMtcHJvdmlkZXJcIjtcblxuY29uc3QgdHlwZSA9IFwicGljYXJ0b1wiLFxuICAgIGJhc2VVUkwgPSAnaHR0cHM6Ly9wdHZhcHBhcGkucGljYXJ0by50dicsXG4gICAgYXBpS2V5ID0gJzAzZTI2Mjk0LWI3OTMtMTFlNS05YTQxLTAwNTA1Njk4NGJkNCc7XG5cbmZ1bmN0aW9uIGdldENoYW5uZWxGcm9tSlNPTihqc29uQ2hhbikge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDaGFubmVsKGpzb25DaGFuLmNoYW5uZWwudG9Mb3dlckNhc2UoKSwgdHlwZSk7XG4gICAgcmV0LnVuYW1lID0ganNvbkNoYW4uY2hhbm5lbDtcbiAgICByZXQuaW1hZ2UgPSB7IDEwMToganNvbkNoYW4uYXZhdGFyX3VybCB9O1xuICAgIHJldC50aHVtYm5haWwgPSBqc29uQ2hhbi50aHVtYm5haWxfdXJsO1xuICAgIHJldC51cmwucHVzaChcImh0dHBzOi8vcGljYXJ0by50di9cIiArIHJldC5sb2dpbik7XG4gICAgcmV0LmFyY2hpdmVVcmwgPSBcImh0dHBzOi8vcGljYXJ0by50di9cIiArIHJldC5sb2dpbjtcbiAgICByZXQuY2hhdFVybCA9IFwiaHR0cHM6Ly9waWNhcnRvLnR2L2NoYXRwb3BvdXQvXCIgKyByZXQubG9naW47XG4gICAgcmV0LmxpdmUuc2V0TGl2ZShqc29uQ2hhbi5pc19vbmxpbmUpO1xuICAgIHJldC5tYXR1cmUgPSBqc29uQ2hhbi5pc19uc2Z3O1xuICAgIHJldC52aWV3ZXJzID0ganNvbkNoYW4uY3VycmVudF92aWV3ZXJzO1xuICAgIHJldC50aXRsZSA9IGpzb25DaGFuLmNoYW5uZWxfdGl0bGU7XG4gICAgcmV0LmNhdGVnb3J5ID0ganNvbkNoYW4uaXNfbXVsdGlzdHJlYW0gPyBicm93c2VyLmkxOG4uZ2V0TWVzc2FnZShcInByb3ZpZGVyUGljYXJ0b011bHRpc3RyZWFtXCIpIDoganNvbkNoYW4uY29udGVudF90eXBlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmNsYXNzIFBpY2FydG8gZXh0ZW5kcyBHZW5lcmljUHJvdmlkZXIge1xuICAgIGF1dGhVUkwgPSBbIFwiaHR0cHM6Ly9waWNhcnRvLnR2XCIgXTtcblxuICAgIGdldENoYW5uZWxEZXRhaWxzKGNoYW5uZWxuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYCR7YmFzZVVSTH0vY2hhbm5lbC8ke2NoYW5uZWxuYW1lLnRvTG93ZXJDYXNlKCl9P2tleT0ke2FwaUtleX1gKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZihyZXNwLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsRnJvbUpTT04ocmVzcC5wYXJzZUpTT04pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYENoYW5uZWwgJHtjaGFubmVsbmFtZX0gZG9lcyBub3QgZXhpc3QgZm9yICR7dGhpcy5uYW1lfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVJlcXVlc3QoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IGNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gYCR7YmFzZVVSTH0vY2hhbm5lbC8ke2NoYW5uZWwubG9naW59P2tleT0ke2FwaUtleX1gKTtcbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIChwYWdlKSA9PiB7XG4gICAgICAgICAgICBpZihwYWdlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGdldENoYW5uZWxGcm9tSlNPTihwYWdlLnBhcnNlSlNPTik7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBjaGFubmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKG5ldyBQaWNhcnRvKHR5cGUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3Byb3ZpZGVycy9waWNhcnRvLmpzIiwiLyoqXG4gKiBUd2l0Y2ggUHJvdmlkZXIuXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBwcm92aWRlcnMvdHdpdGNoXG4gKiBAdG9kbyBpbnZlc3RpZ2F0ZSBkZWxheWVkIHRpdGxlIHVwZGF0ZXNcbiAqL1xuLy9UT0RPIHByb3Blcmx5IHdhaXQgZm9yIGNsaWVudElEXG5pbXBvcnQgeyBlbWl0LCBmaWx0ZXJBc3luYyB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHByZWZzIGZyb20gXCIuLi9wcmVmZXJlbmNlc1wiO1xuaW1wb3J0IHF1ZXJ5c3RyaW5nIGZyb20gXCIuLi9xdWVyeXN0cmluZ1wiO1xuaW1wb3J0IExpdmVTdGF0ZSBmcm9tIFwiLi4vY2hhbm5lbC9saXZlLXN0YXRlXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBVc2VyIH0gZnJvbSAnLi4vY2hhbm5lbC9jb3JlJztcbmltcG9ydCB7IHByb21pc2VkUGFnaW5hdGlvbkhlbHBlciwgUGFnaW5hdGlvbkhlbHBlciB9IGZyb20gJy4uL3BhZ2luYXRpb24taGVscGVyJztcbmltcG9ydCBHZW5lcmljUHJvdmlkZXIgZnJvbSBcIi4vZ2VuZXJpYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgbm90IH0gZnJvbSAnLi4vbG9naWMnO1xuXG5jb25zdCB0eXBlID0gXCJ0d2l0Y2hcIixcbiAgICBhcmNoaXZlVVJMID0gXCIvdmlkZW9zL2FsbFwiLFxuICAgIGNoYXRVUkwgPSBcIi9jaGF0XCIsXG4gICAgYmFzZVVSTCA9ICdodHRwczovL2FwaS50d2l0Y2gudHYva3Jha2VuJyxcbiAgICBoZWFkZXJzID0geyAnQ2xpZW50LUlEJzogJycsICdBY2NlcHQnOiAnYXBwbGljYXRpb24vdm5kLnR3aXRjaHR2LnYzK2pzb24nIH0sXG4gICAgZGVmYXVsdEF2YXRhciA9IFwiaHR0cHM6Ly9zdGF0aWMtY2RuLmp0dm53Lm5ldC9qdHZfdXNlcl9waWN0dXJlcy94YXJ0aC80MDRfdXNlcl8zMDB4MzAwLnBuZ1wiLFxuICAgIGl0ZW1zUGVyUGFnZSA9IDEwMCxcbiAgICBpZE9mQ2hhbm5lbCA9IG5ldyBNYXAoKSxcbiAgICBTSVpFUyA9IFsgJzUwJywgJzcwJywgJzE1MCcsICczMDAnIF0sXG4gICAgdXJsRm9yU2l6ZSA9IChpbWdVUkwsIHNpemUpID0+IGltZ1VSTC5yZXBsYWNlKFwiMzAweDMwMFwiLCBzaXplICsgXCJ4XCIgKyBzaXplKSxcbiAgICBnZXRJbWFnZU9iaiA9IChpbWdVUkwgPSBkZWZhdWx0QXZhdGFyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICBTSVpFUy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICByZXRbc10gPSB1cmxGb3JTaXplKGltZ1VSTCwgcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZGVkdXBlID0gKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIGEuZmlsdGVyKChjKSA9PiBiLmV2ZXJ5KChkKSA9PiBjLmlkICE9PSBkLmlkKSk7XG4gICAgfTtcbnByZWZzLmdldCgndHdpdGNoX2NsaWVudElkJykudGhlbigoaWQpID0+IHtcbiAgICBoZWFkZXJzWydDbGllbnQtSUQnXSA9IGlkO1xufSk7XG5cbmZ1bmN0aW9uIGdldENoYW5uZWxGcm9tSlNPTihqc29uQ2hhbm5lbCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDaGFubmVsKGpzb25DaGFubmVsLm5hbWUsIHR5cGUpO1xuICAgIHJldC51bmFtZSA9IGpzb25DaGFubmVsLmRpc3BsYXlfbmFtZTtcbiAgICByZXQudXJsLnB1c2goanNvbkNoYW5uZWwudXJsKTtcbiAgICByZXQuYXJjaGl2ZVVybCA9IGpzb25DaGFubmVsLnVybCArIGFyY2hpdmVVUkw7XG4gICAgcmV0LmNoYXRVcmwgPSBqc29uQ2hhbm5lbC51cmwgKyBjaGF0VVJMO1xuICAgIHJldC5pbWFnZSA9IGdldEltYWdlT2JqKGpzb25DaGFubmVsLmxvZ28gPyBqc29uQ2hhbm5lbC5sb2dvIDogZGVmYXVsdEF2YXRhcik7XG4gICAgcmV0LnRpdGxlID0ganNvbkNoYW5uZWwuc3RhdHVzO1xuICAgIHJldC5jYXRlZ29yeSA9IGpzb25DaGFubmVsLmdhbWU7XG4gICAgcmV0Lm1hdHVyZSA9IGpzb25DaGFubmVsLm1hdHVyZTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmVhbVR5cGVQYXJhbShkZWxpbSA9IFwiJlwiKSB7XG4gICAgcmV0dXJuIHByZWZzLmdldCgndHdpdGNoX3Nob3dQbGF5bGlzdCcpLnRoZW4oKHNob3dQbGF5bGlzdCkgPT4ge1xuICAgICAgICBpZihzaG93UGxheWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxpbSArIFwic3RyZWFtX3R5cGU9YWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsaW0gKyBcIiZzdHJlYW1fdHlwZT1saXZlXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuY2xhc3MgVHdpdGNoIGV4dGVuZHMgR2VuZXJpY1Byb3ZpZGVyIHtcbiAgICBhdXRoVVJMID0gW1xuICAgICAgICBcImh0dHA6Ly93d3cudHdpdGNoLnR2XCIsXG4gICAgICAgIFwiaHR0cHM6Ly9zZWN1cmUudHdpdGNoLnR2XCIsXG4gICAgICAgIFwiaHR0cHM6Ly9wYXNzcG9ydC50d2l0Y2gudHZcIlxuICAgIF07XG4gICAgX3N1cHBvcnRzRmF2b3JpdGVzID0gdHJ1ZTtcbiAgICBfc3VwcG9ydHNDcmVkZW50aWFscyA9IHRydWU7XG4gICAgX3N1cHBvcnRzRmVhdHVyZWQgPSB0cnVlO1xuXG4gICAgYXN5bmMgZ2V0VXNlckZhdm9yaXRlcyh1c2VybmFtZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyAnL3VzZXJzLycgKyB1c2VybmFtZSwgaGVhZGVycyk7XG5cbiAgICAgICAgaWYoZGF0YS5qc29uICYmICFkYXRhLmpzb24uZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gYXdhaXQgcHJvbWlzZWRQYWdpbmF0aW9uSGVscGVyKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBiYXNlVVJMICsgJy91c2Vycy8nICsgdXNlcm5hbWUgKyAnL2ZvbGxvd3MvY2hhbm5lbHM/bGltaXQ9JyArIGl0ZW1zUGVyUGFnZSArICcmb2Zmc2V0PScsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplOiBpdGVtc1BlclBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIFwiZm9sbG93c1wiIGluIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZm9sbG93cy5sZW5ndGggPT0gaXRlbXNQZXJQYWdlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJmb2xsb3dzXCIgaW4gZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5mb2xsb3dzLm1hcCgoYykgPT4gZ2V0Q2hhbm5lbEZyb21KU09OKGMuY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXNlciA9IG5ldyBVc2VyKGRhdGEucGFyc2VkSlNPTi5uYW1lLCB0aGlzLl90eXBlKTtcbiAgICAgICAgICAgIHVzZXIudW5hbWUgPSBkYXRhLnBhcnNlZEpTT04uZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgdXNlci5pbWFnZSA9IGdldEltYWdlT2JqKGRhdGEucGFyc2VkSlNPTi5sb2dvID8gZGF0YS5wYXJzZWRKU09OLmxvZ28gOiBkZWZhdWx0QXZhdGFyKTtcbiAgICAgICAgICAgIHVzZXIuZmF2b3JpdGVzID0gY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsLmxvZ2luKTtcblxuICAgICAgICAgICAgcmV0dXJuIFsgdXNlciwgY2hhbm5lbHMgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiQ291bGRuJ3QgZmV0Y2ggdHdpdGNoIHVzZXIgXCIgKyB1c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGFubmVsRGV0YWlscyhjaGFubmVsbmFtZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJ0d2l0Y2guZ2V0Q2hhbm5lbERldGFpbHNcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArICcvY2hhbm5lbHMvJyArIGNoYW5uZWxuYW1lLCBoZWFkZXJzKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgIWRhdGEucGFyc2VkSlNPTi5lcnJvcikge1xuICAgICAgICAgICAgICAgIGlkT2ZDaGFubmVsLnNldChkYXRhLnBhcnNlZEpTT04ubmFtZSwgZGF0YS5wYXJzZWRKU09OLl9pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWxGcm9tSlNPTihkYXRhLnBhcnNlZEpTT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGF0YS5wYXJzZWRKU09OID8gZGF0YS5wYXJzZWRKU09OLmVycm9yIDogXCJDb3VsZCBub3QgZmV0Y2ggZGV0YWlscyBmb3IgXCIgKyB0aGlzLm5hbWUgKyBcIiBjaGFubmVsIFwiICsgY2hhbm5lbG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVGYXZzUmVxdWVzdCh1c2Vycykge1xuICAgICAgICBjb25zdCB1cmxzID0gdXNlcnMubWFwKCh1c2VyKSA9PiBiYXNlVVJMICsgJy91c2Vycy8nICsgdXNlci5sb2dpbik7XG5cbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkxPV19QUklPUklUWSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiAhZGF0YS5wYXJzZWRKU09OLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlciA9IHVzZXJzLmZpbmQoKHVzZXIpID0+IHVzZXIubG9naW4gPT0gZGF0YS5wYXJzZWRKU09OLm5hbWUpO1xuICAgICAgICAgICAgICAgIHVzZXIudW5hbWUgPSBkYXRhLnBhcnNlZEpTT04uZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgICAgIHVzZXIuaW1hZ2UgPSBnZXRJbWFnZU9iaihkYXRhLnBhcnNlZEpTT04ubG9nbyA/IGRhdGEucGFyc2VkSlNPTi5sb2dvIDogZGVmYXVsdEF2YXRhcik7XG5cbiAgICAgICAgICAgICAgICBuZXcgUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYmFzZVVSTCArICcvdXNlcnMvJyArIHVzZXIubG9naW4gKyAnL2ZvbGxvd3MvY2hhbm5lbHM/bGltaXQ9JyArIGl0ZW1zUGVyUGFnZSArICcmb2Zmc2V0PScsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplOiBpdGVtc1BlclBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmIFwiZm9sbG93c1wiIGluIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uZm9sbG93cy5sZW5ndGggPT0gaXRlbXNQZXJQYWdlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJmb2xsb3dzXCIgaW4gZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5mb2xsb3dzLm1hcCgoYykgPT4gZ2V0Q2hhbm5lbEZyb21KU09OKGMuY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiAoZm9sbG93cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcIm5ld2NoYW5uZWxzXCIsIGZvbGxvd3MuZmlsdGVyKChjKSA9PiB1c2VyLmZhdm9yaXRlcy5ldmVyeSgobmFtZSkgPT4gbmFtZSAhPT0gYy5sb2dpbikpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5mYXZvcml0ZXMgPSBmb2xsb3dzLm1hcCgoYykgPT4gYy5sb2dpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZHVzZXJcIiwgdXNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGVhZGVycyk7XG4gICAgfVxuICAgIHVwZGF0ZVJlcXVlc3QoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbHNTdHJpbmcgPSBjaGFubmVscy5tYXAoKGMpID0+IGMubG9naW4pLmpvaW4oXCIsXCIpO1xuICAgICAgICBuZXcgUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyBcIi9zdHJlYW1zP2NoYW5uZWw9XCIgKyBjaGFubmVsc1N0cmluZyArIFwiJnN0cmVhbV90eXBlPWFsbCZsaW1pdD1cIiArIGl0ZW1zUGVyUGFnZSArIFwiJm9mZnNldD1cIixcbiAgICAgICAgICAgIHBhZ2VTaXplOiBpdGVtc1BlclBhZ2UsXG4gICAgICAgICAgICByZXF1ZXN0OiAodXJsLCBjYWxsYmFjaywgaW5pdGlhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KFsgdXJsIF0sIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIGNhbGxiYWNrLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhLCBwYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04gJiYgXCJzdHJlYW1zXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5zdHJlYW1zLmxlbmd0aCA9PSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJdGVtczogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJzdHJlYW1zXCIgaW4gZGF0YS5wYXJzZWRKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHJlYW1zID0gZGF0YS5wYXJzZWRKU09OLnN0cmVhbXM7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwcmVmcy50d2l0Y2hfc2hvd1BsYXlsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zID0gc3RyZWFtcy5maWx0ZXIoKHMpID0+ICFzLmlzX3BsYXlsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtcy5tYXAoKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hvID0gZ2V0Q2hhbm5lbEZyb21KU09OKG9iai5jaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoby52aWV3ZXJzID0gb2JqLnZpZXdlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG8udGh1bWJuYWlsID0gb2JqLnByZXZpZXcubWVkaXVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqLmlzX3BsYXlsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvLmxpdmUgPSBuZXcgTGl2ZVN0YXRlKExpdmVTdGF0ZS5SRUJST0FEQ0FTVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaG8ubGl2ZS5zZXRMaXZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2xkQ2hhbiA9IGNoYW5uZWxzLmZpbmQoKGNoKSA9PiBjaG8ubG9naW4gPT0gY2gubG9naW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYob2xkQ2hhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluZENoYW4gPSAoY2hhbiwgY2gpID0+IGNoLmxvZ2luID09IGNoYW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IGkgb2YgaWRPZkNoYW5uZWwuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlbMV0gPT0gb2JqLmNoYW5uZWwuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDaGFuID0gY2hhbm5lbHMuZmluZChmaW5kQ2hhbi5iaW5kKG51bGwsIGlbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9sZENoYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYob2xkQ2hhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvLmlkID0gb2xkQ2hhbi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDaGFuLmxpdmUgPSBjaG8ubGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaG87XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpdmVDaGFucyA9IGF3YWl0IGZpbHRlckFzeW5jKGRhdGEsIChjaG8pID0+IGNoby5saXZlLmlzTGl2ZShMaXZlU3RhdGUuVE9XQVJEX09GRkxJTkUpKTtcbiAgICAgICAgICAgICAgICBpZihsaXZlQ2hhbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQodGhpcywgXCJ1cGRhdGVkY2hhbm5lbHNcIiwgbGl2ZUNoYW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobGl2ZUNoYW5zLmxlbmd0aCAhPSBjaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZmxpbmVDaGFucyA9IGRlZHVwZShjaGFubmVscywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYXlsaXN0Q2hhbnMgPSBhd2FpdCBmaWx0ZXJBc3luYyhkYXRhLCAoY2hvKSA9PiBub3QoY2hvLmxpdmUuaXNMaXZlKExpdmVTdGF0ZS5UT1dBUkRfT0ZGTElORSkpKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUNoYW5zID0gb2ZmbGluZUNoYW5zLmNvbmNhdChwbGF5bGlzdENoYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5zID0gYXdhaXQgdGhpcy5fZ2V0SG9zdGVkQ2hhbm5lbHMob2ZmbGluZUNoYW5zLCBsaXZlQ2hhbnMpO1xuICAgICAgICAgICAgICAgICAgICBjaGFucyA9IGF3YWl0IFByb21pc2UuYWxsKGNoYW5zLm1hcCgoY2hhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hhbi5saXZlLnN0YXRlID09IExpdmVTdGF0ZS5SRUJST0FEQ0FTVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBY3RpdmVQbGF5bGlzdEluZm8oY2hhbikudGhlbigobWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuLnRpdGxlID0gbWV0YS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi5jYXRlZ29yeSA9IG1ldGEuZ2FtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi50aHVtYm5haWwgPSBtZXRhLnRodW1ibmFpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4gY2hhbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZGNoYW5uZWxzXCIsIGNoYW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDaGFubmVsKGNoYW5uZWxuYW1lLCBpZ25vcmVIb3N0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBbIGRhdGEsIGNoYW5uZWwgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGdldFN0cmVhbVR5cGVQYXJhbShcIj9cIikudGhlbigocCkgPT4gdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyAnL3N0cmVhbXMvJyArIGNoYW5uZWxuYW1lICsgcCwgaGVhZGVycykpLFxuICAgICAgICAgICAgdGhpcy5nZXRDaGFubmVsRGV0YWlscyhjaGFubmVsbmFtZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5zdHJlYW0gIT09IG51bGwgJiZcbiAgICAgICAgICAgKCFpZ25vcmVIb3N0ZWQgfHwgIWRhdGEucGFyc2VkSlNPTi5zdHJlYW0uaXNfcGxheWxpc3QpKSB7XG4gICAgICAgICAgICBjaGFubmVsLnZpZXdlcnMgPSBkYXRhLnBhcnNlZEpTT04uc3RyZWFtLnZpZXdlcnM7XG4gICAgICAgICAgICBjaGFubmVsLnRodW1ibmFpbCA9IGRhdGEucGFyc2VkSlNPTi5zdHJlYW0ucHJldmlldy5tZWRpdW07XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04uc3RyZWFtLmlzX3BsYXlsaXN0KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5saXZlID0gbmV3IExpdmVTdGF0ZShMaXZlU3RhdGUuUkVCUk9BRENBU1QpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBhd2FpdCB0aGlzLl9nZXRBY3RpdmVQbGF5bGlzdEluZm8oY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwudGl0bGUgPSBtZXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNhdGVnb3J5ID0gbWV0YS5nYW1lO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnRodW1ibmFpbCA9IG1ldGEudGh1bWJuYWlsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5saXZlLnNldExpdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihhd2FpdCBjaGFubmVsLmxpdmUuaXNMaXZlKExpdmVTdGF0ZS5UT1dBUkRfT0ZGTElORSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoIWlnbm9yZUhvc3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRIb3N0ZWRDaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgbG9naW5zID0gY2hhbm5lbHMubWFwKChjKSA9PiBjLmxvZ2luKSxcbiAgICAgICAgICAgIGNoYW5uZWxzU3RyaW5nID0gbG9naW5zLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgc3RyZWFtVHlwZVBhcmFtID0gYXdhaXQgZ2V0U3RyZWFtVHlwZVBhcmFtKCksXG4gICAgICAgICAgICBsaXZlQ2hhbm5lbHMgPSBhd2FpdCBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgICAgIHVybDogYmFzZVVSTCArICcvc3RyZWFtcz9jaGFubmVsPScgKyBjaGFubmVsc1N0cmluZyArIHN0cmVhbVR5cGVQYXJhbSArICcmbGltaXQ9JyArIGl0ZW1zUGVyUGFnZSArICcmb2Zmc2V0PScsXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IGl0ZW1zUGVyUGFnZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiAodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsLCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZldGNoTmV4dFBhZ2UoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OICYmICFkYXRhLnBhcnNlZEpTT04uZXJyb3IgJiYgZGF0YS5wYXJzZWRKU09OLnN0cmVhbXMubGVuZ3RoID09IGl0ZW1zUGVyUGFnZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEl0ZW1zKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmICFkYXRhLnBhcnNlZEpTT04uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04uc3RyZWFtcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBjaG8sXG4gICAgICAgICAgICByZXQgPSBhd2FpdCBQcm9taXNlLmFsbChsaXZlQ2hhbm5lbHMubWFwKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICBjaG8gPSBnZXRDaGFubmVsRnJvbUpTT04ob2JqLmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIGNoby52aWV3ZXJzID0gb2JqLnZpZXdlcnM7XG4gICAgICAgICAgICAgICAgY2hvLnRodW1ibmFpbCA9IG9iai5wcmV2aWV3Lm1lZGl1bTtcbiAgICAgICAgICAgICAgICBpZihvYmouaXNfcGxheWxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvLmxpdmUgPSBuZXcgTGl2ZVN0YXRlKExpdmVTdGF0ZS5SRUJST0FEQ0FTVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaG8ubGl2ZS5zZXRMaXZlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGxvZ2lucy5pbmNsdWRlcyhjaG8ubG9naW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoby5pZCA9IGNoYW5uZWxzW2xvZ2lucy5pbmRleE9mKGNoby5sb2dpbildLmlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNobyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2hhbm5lbHMubWFwKChjKSA9PiB0aGlzLl9nZXRDaGFubmVsSWQoYykpKS50aGVuKChpZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5zb21lKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlkID09PSBvYmouY2hhbm5lbC5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvLmlkID0gY2hhbm5lbHNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaG87XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBjb25zdCBsaXZlQ2hhbnMgPSBhd2FpdCBmaWx0ZXJBc3luYyhyZXQsIChjaG8pID0+IGNoby5saXZlLmlzTGl2ZShMaXZlU3RhdGUuVE9XQVJEX09GRkxJTkUpKTtcblxuICAgICAgICBpZihsaXZlQ2hhbnMubGVuZ3RoICE9IGNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcGxheWxpc3RDaGFucyA9IChhd2FpdCBQcm9taXNlLmFsbChyZXQubWFwKGFzeW5jIChjaG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZihhd2FpdCBub3QoY2hvLmxpdmUuaXNMaXZlKExpdmVTdGF0ZS5UT1dBUkRfT0ZGTElORSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gYXdhaXQgdGhpcy5fZ2V0QWN0aXZlUGxheWxpc3RJbmZvKGNobyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG8udGl0bGUgPSBtZXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvLmNhdGVnb3J5ID0gbWV0YS5nYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvLnRodW1ibmFpbCA9IG1ldGEudGh1bWJuYWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHsgLyogZW10cHkgKi8gfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pKSkuZmlsdGVyKChjKSA9PiBjICE9PSBudWxsKTtcbiAgICAgICAgICAgIGxldCBvZmZsaW5lQ2hhbnMgPSBkZWR1cGUoY2hhbm5lbHMsIHJldCk7XG4gICAgICAgICAgICBvZmZsaW5lQ2hhbnMgPSBvZmZsaW5lQ2hhbnMuY29uY2F0KHBsYXlsaXN0Q2hhbnMpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmQ2hhbnMgPSBhd2FpdCB0aGlzLl9nZXRIb3N0ZWRDaGFubmVscyhvZmZsaW5lQ2hhbnMsIGxpdmVDaGFucyk7XG4gICAgICAgICAgICByZXQgPSBsaXZlQ2hhbnMuY29uY2F0KG9mZkNoYW5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGFzeW5jIGdldEZlYXR1cmVkQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwiL3N0cmVhbXMvZmVhdHVyZWRcIiwgaGVhZGVycyk7XG4gICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBcImZlYXR1cmVkXCIgaW4gZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5mZWF0dXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjaGFucyA9IGRhdGEucGFyc2VkSlNPTi5mZWF0dXJlZDtcbiAgICAgICAgICAgIGlmKGF3YWl0IG5vdCh0aGlzLl9tYXR1cmUoKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFucyA9IGNoYW5zLmZpbHRlcigoY2hhbikgPT4gIWNoYW4uc3RyZWFtLmNoYW5uZWwubWF0dXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYW5zLm1hcCgoY2hhbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBnZXRDaGFubmVsRnJvbUpTT04oY2hhbi5zdHJlYW0uY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC52aWV3ZXJzID0gY2hhbi5zdHJlYW0udmlld2VycztcbiAgICAgICAgICAgICAgICBjaGFubmVsLnRodW1ibmFpbCA9IGNoYW4uc3RyZWFtLnByZXZpZXcubWVkaXVtO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBnZXQgYW55IGZlYXR1cmVkIGNoYW5uZWwgZm9yIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlYXJjaChxdWVyeSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcIi9zZWFyY2gvc3RyZWFtcz9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh7IHE6IHF1ZXJ5IH0pLCBoZWFkZXJzKTtcbiAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIFwic3RyZWFtc1wiIGluIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uc3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjaGFucyA9IGRhdGEucGFyc2VkSlNPTi5zdHJlYW1zO1xuICAgICAgICAgICAgaWYoYXdhaXQgbm90KHRoaXMuX21hdHVyZSgpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5zID0gY2hhbnMuZmlsdGVyKChjaGFuKSA9PiAhY2hhbi5jaGFubmVsLm1hdHVyZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGFucy5tYXAoKGNoYW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gZ2V0Q2hhbm5lbEZyb21KU09OKGNoYW4uY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC52aWV3ZXJzID0gY2hhbi52aWV3ZXJzO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudGh1bWJuYWlsID0gY2hhbi5wcmV2aWV3Lm1lZGl1bTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJObyByZXN1bHRzIGZvciB0aGUgc2VhcmNoIFwiICsgcXVlcnkgKyBcIiBvbiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q2hhbm5lbElkKGNoYW5uZWwpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBpZCBmb3IgZWFjaCBjaGFubmVsLlxuICAgICAgICBpZihpZE9mQ2hhbm5lbC5oYXMoY2hhbm5lbC5sb2dpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaWRPZkNoYW5uZWwuZ2V0KGNoYW5uZWwubG9naW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwiL2NoYW5uZWxzL1wiICsgY2hhbm5lbC5sb2dpbiwgaGVhZGVycykudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHJlc3AucGFyc2VkSlNPTiAmJiBcIl9pZFwiIGluIHJlc3AucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgICAgICAgICBpZE9mQ2hhbm5lbC5zZXQoY2hhbm5lbC5sb2dpbiwgcmVzcC5wYXJzZWRKU09OLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNoYW5uZWwubG9naW4gIT0gcmVzcC5wYXJzZWRKU09OLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkT2ZDaGFubmVsLnNldChyZXNwLnBhcnNlZEpTT04ubmFtZSwgcmVzcC5wYXJzZWRKU09OLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3AucGFyc2VkSlNPTi5faWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoKSA9PiBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZ2V0SG9zdGVkQ2hhbm5lbHMoY2hhbm5lbHMsIGxpdmVDaGFucykge1xuICAgICAgICBpZihhd2FpdCBwcmVmcy5nZXQoXCJ0d2l0Y2hfc2hvd0hvc3RpbmdcIikpIHtcbiAgICAgICAgICAgIGxldCBjaGFubmVsSWRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiB0aGlzLl9nZXRDaGFubmVsSWQoY2hhbm5lbCkpKTtcbiAgICAgICAgICAgIGNoYW5uZWxJZHMgPSBjaGFubmVsSWRzLmZpbHRlcigoaWQpID0+IGlkICE9PSBudWxsKTtcblxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDaGFucyA9IEFycmF5LmlzQXJyYXkobGl2ZUNoYW5zKSA/IGNoYW5uZWxzLmNvbmNhdChsaXZlQ2hhbnMpIDogY2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChcImh0dHBzOi8vdG1pLnR3aXRjaC50di9ob3N0cz9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIFwiaW5jbHVkZV9sb2dpbnNcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogY2hhbm5lbElkcy5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgIH0pLCBoZWFkZXJzKTtcblxuICAgICAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIFwiaG9zdHNcIiBpbiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggaG9zdGVkIGNoYW5uZWwgZm9yIGhpcyBzdGF0dXNcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZGF0YS5wYXJzZWRKU09OLmhvc3RzLm1hcChhc3luYyAoaG9zdGluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhbiA9IGNoYW5uZWxzLmZpbmQoKGNoKSA9PiBjaC5sb2dpbiA9PT0gaG9zdGluZy5ob3N0X2xvZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuID0gYXdhaXQgdGhpcy51cGRhdGVDaGFubmVsKGhvc3RpbmcuaG9zdF9sb2dpbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuLmlkID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hhbm5lbHMubWFwKChjKSA9PiB0aGlzLl9nZXRDaGFubmVsSWQoYykpKS50aGVuKChpZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMuc29tZSgoaWQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaWQgPT09IGhvc3RpbmcuaG9zdF9sb2dpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpZCA9IGNoYW5uZWxzW2ldLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihob3N0aW5nLnRhcmdldF9sb2dpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0NoYW5zLmV2ZXJ5KChjaCkgPT4gY2gubG9naW4gIT09IGhvc3RpbmcudGFyZ2V0X2xvZ2luKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgaG9zdGVkIGNoYW5uZWwncyBzdGF0dXMsIHNpbmNlIGhlIGlzbid0IGEgY2hhbm5lbCB3ZSBhbHJlYWR5IGhhdmUgaW4gb3VyIGxpc3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0ZWRDaGFubmVsID0gYXdhaXQgdGhpcy51cGRhdGVDaGFubmVsKGhvc3RpbmcudGFyZ2V0X2xvZ2luLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhd2FpdCBob3N0ZWRDaGFubmVsLmxpdmUuaXNMaXZlKExpdmVTdGF0ZS5UT1dBUkRfT0ZGTElORSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi50aXRsZSA9IGhvc3RlZENoYW5uZWwudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW4udGh1bWJuYWlsID0gaG9zdGVkQ2hhbm5lbC50aHVtYm5haWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW4udmlld2VycyA9IGhvc3RlZENoYW5uZWwudmlld2VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi5jYXRlZ29yeSA9IGhvc3RlZENoYW5uZWwuY2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW4ubGl2ZSA9IG5ldyBMaXZlU3RhdGUoTGl2ZVN0YXRlLlJFRElSRUNUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi5saXZlLmFsdGVybmF0ZVVzZXJuYW1lID0gaG9zdGVkQ2hhbm5lbC51bmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi5saXZlLmFsdGVybmF0ZVVSTCA9IGhvc3RlZENoYW5uZWwudXJsWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi5saXZlLnNldExpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoYW4ubGl2ZS5zdGF0ZSAhPSBMaXZlU3RhdGUuUkVCUk9BRENBU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbi5saXZlLnNldExpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoYW4ubGl2ZS5zdGF0ZSAhPSBMaXZlU3RhdGUuUkVCUk9BRENBU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuLmxpdmUuc2V0TGl2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWxzLmZvckVhY2goKGNoYW4pID0+IHtcbiAgICAgICAgICAgIGlmKGNoYW4ubGl2ZS5zdGF0ZSAhPSBMaXZlU3RhdGUuUkVCUk9BRENBU1QpIHtcbiAgICAgICAgICAgICAgICBjaGFuLmxpdmUuc2V0TGl2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhbm5lbHM7XG4gICAgfVxuICAgIF9nZXRIb3N0ZWRDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEhvc3RlZENoYW5uZWxzKFsgY2hhbm5lbCBdKS50aGVuKChjaHMpID0+IGNoc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBY3RpdmVQbGF5bGlzdEluZm8oY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuX2dldENoYW5uZWxJZChjaGFubmVsKSxcbiAgICAgICAgICAgIHBsYXlsaXN0ID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KFwiaHR0cHM6Ly9hcGkudHdpdGNoLnR2L2FwaS9wbGF5bGlzdHMvY2hhbm5lbHMvXCIgKyBpZCwgaGVhZGVycyk7XG5cbiAgICAgICAgaWYocGxheWxpc3QucGFyc2VkSlNPTiAmJiBwbGF5bGlzdC5wYXJzZWRKU09OLmVuYWJsZWQgJiYgcGxheWxpc3QucGFyc2VkSlNPTi5hY3RpdmUgJiYgcGxheWxpc3QucGFyc2VkSlNPTi5wbGF5aGVhZCkge1xuICAgICAgICAgICAgY29uc3QgcGxheWhlYWQgPSBwbGF5bGlzdC5wYXJzZWRKU09OLnBsYXloZWFkLFxuICAgICAgICAgICAgICAgIHZvZCA9IGF3YWl0IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCIvdmlkZW9zL3ZcIiArIHBsYXloZWFkLnZvZHNbcGxheWhlYWQuYWN0aXZlX3ZvZF9pbmRleF0uaWQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgaWYodm9kLnBhcnNlZEpTT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdm9kLnBhcnNlZEpTT04udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGdhbWU6IHZvZC5wYXJzZWRKU09OLmdhbWUsXG4gICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbDogdm9kLnBhcnNlZEpTT04ucHJldmlld1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlZPRCBub3QgZm91bmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiTm90IGEgY2hhbm5lbCB3aXRoIGFuIGFjdGl2ZSBwbGF5bGlzdFwiO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKG5ldyBUd2l0Y2godHlwZSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcHJvdmlkZXJzL3R3aXRjaC5qcyIsIi8qXG4gKiBDcmVhdGVkIGJ5IE1hcnRpbiBHaWdlclxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMFxuICovXG5pbXBvcnQgeyBlbWl0IH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeyBDaGFubmVsIH0gZnJvbSAnLi4vY2hhbm5lbC9jb3JlJztcbmltcG9ydCBHZW5lcmljUHJvdmlkZXIgZnJvbSBcIi4vZ2VuZXJpYy1wcm92aWRlclwiO1xuXG5jb25zdCB0eXBlID0gXCJ1c3RyZWFtXCIsXG4gICAgY2hhdFVSTCA9IFwiaHR0cDovL3VzdHJlYW0udHYvc29jaWFsc3RyZWFtL1wiLFxuICAgIGJhc2VVUkwgPSAnaHR0cHM6Ly9hcGkudXN0cmVhbS50di8nO1xuXG5mdW5jdGlvbiBnZXRDaGFubmVsRnJvbUpTT04oanNvbkNoYW5uZWwpIHtcbiAgICBjb25zb2xlLmluZm8oXCJ1c3RyZWFtOmdldENoYW5uZWxGcm9tSlNPTlwiKTtcbiAgICBjb25zdCByZXQgPSBuZXcgQ2hhbm5lbChqc29uQ2hhbm5lbC5pZCwgdHlwZSk7XG4gICAgcmV0LnVuYW1lID0ganNvbkNoYW5uZWwudGl0bGU7XG5cbiAgICAvLyBVcmwgc3R1ZmYuIEl0J3MgcHJldHR5IGZ1bi5cbiAgICBpZihcIm9yaWdpbmFsVXJsXCIgaW4ganNvbkNoYW5uZWwpIHtcbiAgICAgICAgcmV0LnVybC5wdXNoKGpzb25DaGFubmVsLm9yaWdpbmFsVXJsKTtcbiAgICAgICAgcmV0LmFyY2hpdmVVcmwgPSBqc29uQ2hhbm5lbC5vcmlnaW5hbFVybDtcbiAgICB9XG4gICAgaWYoXCJ1cmxcIiBpbiBqc29uQ2hhbm5lbCkge1xuICAgICAgICByZXQudXJsLnB1c2goXCJodHRwOi8vd3d3LnVzdHJlYW0udHYvY2hhbm5lbC9cIiArIGpzb25DaGFubmVsLnVybCk7XG4gICAgICAgIGlmKCFyZXQuYXJjaGl2ZVVybCkge1xuICAgICAgICAgICAgcmV0LmFyY2hpdmVVcmwgPSBcImh0dHA6Ly93d3cudXN0cmVhbS50di9jaGFubmVsL1wiICsganNvbkNoYW5uZWwudXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmKFwidGlueXVybFwiIGluIGpzb25DaGFubmVsKSB7XG4gICAgICAgIHJldC51cmwucHVzaChqc29uQ2hhbm5lbC50aW55dXJsKTtcbiAgICAgICAgaWYoIXJldC5hcmNoaXZlVXJsKSB7XG4gICAgICAgICAgICByZXQuYXJjaGl2ZVVybCA9IFwiaHR0cDovL3d3dy51c3RyZWFtLnR2L2NoYW5uZWwvXCIgKyBqc29uQ2hhbm5lbC51cmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0LmNoYXRVcmwgPSBjaGF0VVJMICsganNvbkNoYW5uZWwuaWQ7XG5cbiAgICBpZihcInBpY3R1cmVcIiBpbiBqc29uQ2hhbm5lbCkge1xuICAgICAgICByZXQuaW1hZ2UgPSB7fTtcbiAgICAgICAgbGV0IHNpemU7XG4gICAgICAgIE9iamVjdC5rZXlzKGpzb25DaGFubmVsLnBpY3R1cmUpLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIHNpemUgPSBzLnNwbGl0KFwieFwiKVswXTtcbiAgICAgICAgICAgIHJldC5pbWFnZVtzaXplXSA9IGpzb25DaGFubmVsLnBpY3R1cmVbc107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0LmltYWdlID0geyBcIjQ4XCI6IGpzb25DaGFubmVsLm93bmVyLnBpY3R1cmUgfTtcbiAgICB9XG4gICAgaWYoXCJ0YWdzXCIgaW4ganNvbkNoYW5uZWwgJiYganNvbkNoYW5uZWwudGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldC5jYXRlZ29yeSA9IGpzb25DaGFubmVsLnRhZ3NbMF07XG4gICAgfVxuICAgIHJldC5saXZlLnNldExpdmUoanNvbkNoYW5uZWwuc3RhdHVzID09IFwibGl2ZVwiKTtcbiAgICBpZihcInRodW1ibmFpbFwiIGluIGpzb25DaGFubmVsKSB7XG4gICAgICAgIHJldC50aHVtYm5haWwgPSBqc29uQ2hhbm5lbC50aHVtYm5haWwubGl2ZTtcbiAgICB9XG4gICAgaWYoXCJzdGF0c1wiIGluIGpzb25DaGFubmVsKSB7XG4gICAgICAgIHJldC52aWV3ZXJzID0ganNvbkNoYW5uZWwuc3RhdHVzID09IFwibGl2ZVwiID8ganNvbkNoYW5uZWwuc3RhdHMudmlld2VyIDoganNvbkNoYW5uZWwuc3RhdHMudmlld2VyX3RvdGFsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jbGFzcyBVc3RyZWFtIGV4dGVuZHMgR2VuZXJpY1Byb3ZpZGVyIHtcbiAgICBhdXRoVVJMID0gWyBcImh0dHA6Ly91c3RyZWFtLnR2XCIgXTtcblxuICAgIGFzeW5jIGdldENoYW5uZWxEZXRhaWxzKGNoYW5uZWxuYW1lKSB7XG4gICAgICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KFwiaHR0cDovL3d3dy51c3RyZWFtLnR2L1wiICsgY2hhbm5lbG5hbWUpLFxuICAgICAgICAgICAgcmV0cmllZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCFkYXRhLm9rKSB7XG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KFwiaHR0cDovL3d3dy51c3RyZWFtLnR2L2NoYW5uZWwvXCIgKyBjaGFubmVsbmFtZSk7XG4gICAgICAgICAgICBpZighZGF0YS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgZ2V0dGluZyBjaGFubmVsIGRldGFpbHMgZm9yIGNoYW5uZWwgXCIgKyBjaGFubmVsbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGRhdGEudGV4dCgpLFxuICAgICAgICAgICAgY2hhbm5lbElkID0gcGFnZS5tYXRjaCgvPG1ldGEgbmFtZT1cInVzdHJlYW06Y2hhbm5lbF9pZFwiIGNvbnRlbnQ9XCIoWzAtOV0rKVwiPi8pWzFdLFxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsSWQgKyBcIi5qc29uXCIpO1xuXG4gICAgICAgIGlmKHJlc3BvbnNlLnBhcnNlZEpTT04gJiYgXCJjaGFubmVsXCIgaW4gcmVzcG9uc2UucGFyc2VkSlNPTikge1xuICAgICAgICAgICAgY29uc3QganNvbkNoYW5uZWwgPSByZXNwb25zZS5wYXJzZWRKU09OLmNoYW5uZWw7XG5cbiAgICAgICAgICAgIGlmKCFyZXRyaWVkKSB7XG4gICAgICAgICAgICAgICAganNvbkNoYW5uZWwub3JpZ2luYWxVcmwgPSBcImh0dHA6Ly91c3RyZWFtLnR2L1wiICsgY2hhbm5lbG5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsRnJvbUpTT04oanNvbkNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBnZXR0aW5nIGNoYW5uZWwgZGV0YWlscyBmb3IgY2hhbm5lbCBcIiArIGNoYW5uZWxuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVJlcXVlc3QoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IGNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gYmFzZVVSTCArIFwiY2hhbm5lbHMvXCIgKyBjaGFubmVsLmxvZ2luICsgXCIuanNvblwiKTtcbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkhJR0hfUFJJT1JJVFksIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZGNoYW5uZWxzXCIsIGdldENoYW5uZWxGcm9tSlNPTihkYXRhLnBhcnNlZEpTT04uY2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ2hhbm5lbChjaGFubmVsbmFtZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJVc3RyZWFtLnVwZGF0ZUNoYW5uZWxcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArICdjaGFubmVscy8nICsgY2hhbm5lbG5hbWUgKyBcIi5qc29uXCIpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVzdHJlYW0udXBkYXRlQ2hhbm5lbC5yZXF1ZXN0Q2FsbGJhY2tcIik7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbEZyb21KU09OKGRhdGEucGFyc2VkSlNPTi5jaGFubmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHVwZGF0ZSBjaGFubmVsIFwiICsgY2hhbm5lbG5hbWUgKyBcIiBmb3IgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShuZXcgVXN0cmVhbSh0eXBlKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMvdXN0cmVhbS5qcyIsIi8qKlxuICogWW91VHViZSBwcm92aWRlclxuICogQGF1dGhvciBNYXJ0aW4gR2lnZXJcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBtb2R1bGUgcHJvdmlkZXJzL3lvdXR1YmVcbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHByZWZzIGZyb20gXCIuLi9wcmVmZXJlbmNlc1wiO1xuaW1wb3J0IHF1ZXJ5c3RyaW5nIGZyb20gXCIuLi9xdWVyeXN0cmluZ1wiO1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gXCJ1bmRlcnNjb3JlXCI7XG5pbXBvcnQgeyBDaGFubmVsLCBVc2VyIH0gZnJvbSAnLi4vY2hhbm5lbC9jb3JlJztcbmltcG9ydCB7IHByb21pc2VkUGFnaW5hdGlvbkhlbHBlciB9IGZyb20gJy4uL3BhZ2luYXRpb24taGVscGVyJztcbmltcG9ydCBHZW5lcmljUHJvdmlkZXIgZnJvbSBcIi4vZ2VuZXJpYy1wcm92aWRlclwiO1xuXG5jb25zdCB0eXBlID0gXCJ5b3V0dWJlXCIsXG4gICAgYXBpS2V5ID0gcHJlZnMuZ2V0KCd5b3V0dWJlX2FwaUtleScpLFxuICAgIGJhc2VVUkwgPSBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3lvdXR1YmUvdjMvXCIsXG4gICAgZ2V0TG9jYWxlID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gYnJvd3Nlci5pMThuLmdldFVJTGFuZ3VhZ2UoKTtcbiAgICB9O1xuXG5jbGFzcyBZb3VUdWJlIGV4dGVuZHMgR2VuZXJpY1Byb3ZpZGVyIHtcbiAgICBhdXRoVVJMID0gWyBcImh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbVwiIF07XG4gICAgX3N1cHBvcnRzRmF2b3JpdGVzID0gdHJ1ZTtcbiAgICBfc3VwcG9ydHNGZWF0dXJlZCA9IHRydWU7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcih0eXBlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbmFtZSBmb3IgYSBjYXRlZ29yeS4gRG9lcyBjYWNoaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXJndW1lbnQge3N0cmluZ30gY2F0ZWdvcnlJZFxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqIEBhc3luY1xuICAgICAgICAgKiBAdG9kbyBIYW5kbGUgbG9jYWxlIGNoYW5nZXMgLT4gdXNlIG1lbW9pemUgYW5kIG1ha2UgbGFuZyBhbiBhcmd1bWVudD9cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2V0Q2F0ZWdvcnkgPSBtZW1vaXplKGFzeW5jIChjYXRlZ29yeUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8odGhpcy5uYW1lICsgXCIuX2dldENhdGVnb3J5KFwiLCBjYXRlZ29yeUlkLCBcIilcIik7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcInZpZGVvQ2F0ZWdvcmllcz9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgXCJwYXJ0XCI6IFwic25pcHBldFwiLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogY2F0ZWdvcnlJZCxcbiAgICAgICAgICAgICAgICBcImhsXCI6IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgICAgIFwia2V5XCI6IGF3YWl0IGFwaUtleVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgXCJpdGVtc1wiIGluIGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5zbmlwcGV0LnRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoaWQpID0+IGlkICsgXCJ8XCIgKyBnZXRMb2NhbGUoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2dldENoYW5uZWxCeUlkKGNoYW5uZWxJZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcImNoYW5uZWxzP1wiICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhcnQ6IFwic25pcHBldFwiLFxuICAgICAgICAgICAgICAgIGlkOiBjaGFubmVsSWQsXG4gICAgICAgICAgICAgICAgZmllbGRzOiBcIml0ZW1zKHNuaXBwZXQvdGl0bGUsc25pcHBldC90aHVtYm5haWxzKVwiLFxuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uaXRlbXMgJiYgZGF0YS5wYXJzZWRKU09OLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBuZXcgQ2hhbm5lbChjaGFubmVsSWQsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgY2gudXJsLnB1c2goXCJodHRwczovL3lvdXR1YmUuY29tL2NoYW5uZWwvXCIgKyBjaC5sb2dpbiArIFwiL2xpdmVcIik7XG4gICAgICAgICAgICBjaC51cmwucHVzaChcImh0dHBzOi8vZ2FtaW5nLnlvdXR1YmUuY29tL2NoYW5uZWwvXCIgKyBjaC5sb2dpbiArIFwiL2xpdmVcIik7XG4gICAgICAgICAgICBjaC5hcmNoaXZlVXJsID0gXCJodHRwczovL3lvdXR1YmUuY29tL2NoYW5uZWwvXCIgKyBjaC5sb2dpbiArIFwiL3ZpZGVvc1wiO1xuICAgICAgICAgICAgY2guY2hhdFVybCA9IFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2gubG9naW4gKyBcIi9kaXNjdXNzaW9uXCI7XG4gICAgICAgICAgICBjaC5pbWFnZSA9IHtcbiAgICAgICAgICAgICAgICBcIjg4XCI6IGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5zbmlwcGV0LnRodW1ibmFpbHMuZGVmYXVsdC51cmwsXG4gICAgICAgICAgICAgICAgXCIyNDBcIjogZGF0YS5wYXJzZWRKU09OLml0ZW1zWzBdLnNuaXBwZXQudGh1bWJuYWlscy5oaWdoLnVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoLnVuYW1lID0gZGF0YS5wYXJzZWRKU09OLml0ZW1zWzBdLnNuaXBwZXQudGl0bGU7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkdldHRpbmcgY2hhbm5lbCBkZXRhaWxzIGZhaWxlZDogXCIgKyBkYXRhLnN0YXR1cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFVzZXJGYXZvcml0ZXModXNlcm5hbWUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJjaGFubmVscz9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXJ0OiBcImlkLHNuaXBwZXRcIixcbiAgICAgICAgICAgICAgICBmb3JVc2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgZmllbGRzOiBcIml0ZW1zKGlkLHNuaXBwZXQvdGl0bGUsc25pcHBldC90aHVtYm5haWxzKVwiLFxuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYoZGF0YS5wYXJzZWRKU09OICYmIGRhdGEucGFyc2VkSlNPTi5pdGVtcyAmJiBkYXRhLnBhcnNlZEpTT04uaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IG5ldyBVc2VyKGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5pZCwgdGhpcy5fdHlwZSksXG4gICAgICAgICAgICAgICAgc3Vic09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQ6IFwic25pcHBldFwiLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsSWQ6IGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbWF4UmVzdWx0czogNTAsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwYWdlID0gMDtcbiAgICAgICAgICAgIGNoLmltYWdlID0ge1xuICAgICAgICAgICAgICAgIFwiODhcIjogZGF0YS5wYXJzZWRKU09OLml0ZW1zWzBdLnNuaXBwZXQudGh1bWJuYWlscy5kZWZhdWx0LnVybCxcbiAgICAgICAgICAgICAgICBcIjI0MFwiOiBkYXRhLnBhcnNlZEpTT04uaXRlbXNbMF0uc25pcHBldC50aHVtYm5haWxzLmhpZ2gudXJsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2gudW5hbWUgPSBkYXRhLnBhcnNlZEpTT04uaXRlbXNbMF0uc25pcHBldC50aXRsZTtcblxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGF3YWl0IHByb21pc2VkUGFnaW5hdGlvbkhlbHBlcih7XG4gICAgICAgICAgICAgICAgdXJsOiBiYXNlVVJMICsgXCJzdWJzY3JpcHRpb25zP1wiICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHN1YnNPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBwYWdlU2l6ZTogc3Vic09wdGlvbnMubWF4UmVzdWx0cyxcbiAgICAgICAgICAgICAgICBpbml0aWFsUGFnZTogXCJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiAodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFBhZ2VOdW1iZXIocGFnZSwgcGFnZVNpemUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5uZXh0UGFnZVRva2VuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0UGFnZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLml0ZW1zICYmIGRhdGEucGFyc2VkSlNPTi5wYWdlSW5mby50b3RhbFJlc3VsdHMgPiBkYXRhLnBhcnNlZEpTT04ucGFnZUluZm8ucmVzdWx0c1BlclBhZ2UgKiArK3BhZ2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRJdGVtcyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04uaXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYoc3Vic2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaC5mYXZvcml0ZXMgPSBzdWJzY3JpcHRpb25zLm1hcCgoc3ViKSA9PiBzdWIuc25pcHBldC5yZXNvdXJjZUlkLmNoYW5uZWxJZCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHN1YnNjcmlwdGlvbnMubWFwKChzdWIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gbmV3IENoYW5uZWwoc3ViLnNuaXBwZXQucmVzb3VyY2VJZC5jaGFubmVsSWQsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXQuYXJjaGl2ZVVybCA9IFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgcmV0LmxvZ2luICsgXCIvdmlkZW9zXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldC5jaGF0VXJsID0gXCJodHRwczovL3lvdXR1YmUuY29tL2NoYW5uZWwvXCIgKyByZXQubG9naW4gKyBcIi9kaXNjdXNzaW9uXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldC5pbWFnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiODhcIjogc3ViLnNuaXBwZXQudGh1bWJuYWlscy5kZWZhdWx0LnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiMjQwXCI6IHN1Yi5zbmlwcGV0LnRodW1ibmFpbHMuaGlnaC51cmxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnVuYW1lID0gc3ViLnNuaXBwZXQudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gWyBjaCwgY2hhbm5lbHMgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKiBAdG9kbyBTb21ldGltZXMgbmVlZHMgb0F1dGggZm9yIHNvbWUgcmVhc29uLCBJIGd1ZXNzIHByaXZhY3lcbiAgICAgICAgICAgICAgICAgICogc2V0dGluZ3MuIFRoaXMgYWxzbyB0cmlnZ2VycyB3aGVuIHRoZSB1c2VyIGZvbGxvd3Mgbm9vbmUuICovXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYW4ndCBnZXQgZmF2b3JpdGVzIGZvciB5b3V0dWJlIHVzZXIgXCIgKyB1c2VybmFtZSArIFwiIHdpdGhvdXQgb0F1dGggYXMgc29tZWJvZHkgd2l0aCByZWFkaW5nIHJpZ2h0cyBvZiB0aGlzIHVzZXIncyBzdWJzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBnZXR0aW5nIGRldGFpbHMgZm9yIHlvdXR1YmUgdXNlciBcIiArIHVzZXJuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldENoYW5uZWxEZXRhaWxzKHVzZXJuYW1lKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwiY2hhbm5lbHM/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGFydDogXCJpZCxzbmlwcGV0XCIsXG4gICAgICAgICAgICAgICAgZm9yVXNlcm5hbWU6IHVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkczogXCJpdGVtcyhpZCxzbmlwcGV0L3RpdGxlLHNuaXBwZXQvdGh1bWJuYWlscylcIixcbiAgICAgICAgICAgICAgICBrZXk6IGF3YWl0IGFwaUtleVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLml0ZW1zICYmIGRhdGEucGFyc2VkSlNPTi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gbmV3IENoYW5uZWwoZGF0YS5wYXJzZWRKU09OLml0ZW1zWzBdLmlkLCB0aGlzLl90eXBlKTtcbiAgICAgICAgICAgIGNoLnVybC5wdXNoKFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2gubG9naW4pO1xuICAgICAgICAgICAgY2guYXJjaGl2ZVVybCA9IFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2gubG9naW4gKyBcIi92aWRlb3NcIjtcbiAgICAgICAgICAgIGNoLmNoYXRVcmwgPSBcImh0dHBzOi8veW91dHViZS5jb20vY2hhbm5lbC9cIiArIGNoLmxvZ2luICsgXCIvZGlzY3Vzc2lvblwiO1xuICAgICAgICAgICAgY2guaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgXCI4OFwiOiBkYXRhLnBhcnNlZEpTT04uaXRlbXNbMF0uc25pcHBldC50aHVtYm5haWxzLmRlZmF1bHQudXJsLFxuICAgICAgICAgICAgICAgIFwiMjQwXCI6IGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5zbmlwcGV0LnRodW1ibmFpbHMuaGlnaC51cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaC51bmFtZSA9IGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5zbmlwcGV0LnRpdGxlO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IHRoZSBjaGFubmVsIGJ5IElEIGlmIHdlIGNhbid0IGdldCBpdCBieSB1c2VybmFtZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDaGFubmVsQnlJZCh1c2VybmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmF2c1JlcXVlc3QodXNlcnMpIHtcbiAgICAgICAgY29uc3QgdXJscyA9IGF3YWl0IFByb21pc2UuYWxsKHVzZXJzLm1hcChhc3luYyAodXNlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VVUkwgKyBcImNoYW5uZWxzP1wiICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydDogXCJpZCxzbmlwcGV0XCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1c2VyLmxvZ2luLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IFwiaXRlbXMoaWQsc25pcHBldC90aXRsZSxzbmlwcGV0L3RodW1ibmFpbHMpXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5fcXMucXVldWVVcGRhdGVSZXF1ZXN0KHVybHMsIHRoaXMuX3FzLkxPV19QUklPUklUWSwgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uaXRlbXMgJiYgZGF0YS5wYXJzZWRKU09OLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gbmV3IFVzZXIoZGF0YS5wYXJzZWRKU09OLml0ZW1zWzBdLmlkLCB0aGlzLl90eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0OiBcInNuaXBwZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZDogZGF0YS5wYXJzZWRKU09OLml0ZW1zWzBdLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UmVzdWx0czogNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGF3YWl0IGFwaUtleVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBwYWdlID0gMDtcbiAgICAgICAgICAgICAgICBjaC5pbWFnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCI4OFwiOiBkYXRhLnBhcnNlZEpTT04uaXRlbXNbMF0uc25pcHBldC50aHVtYm5haWxzLmRlZmF1bHQudXJsLFxuICAgICAgICAgICAgICAgICAgICBcIjI0MFwiOiBkYXRhLnBhcnNlZEpTT04uaXRlbXNbMF0uc25pcHBldC50aHVtYm5haWxzLmhpZ2gudXJsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaC51bmFtZSA9IGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5zbmlwcGV0LnRpdGxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBhd2FpdCBwcm9taXNlZFBhZ2luYXRpb25IZWxwZXIoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwgKyBcInN1YnNjcmlwdGlvbnM/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoc3Vic09wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZTogc3Vic09wdGlvbnMubWF4UmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFBhZ2U6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6ICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFnZU51bWJlcihwYWdlLCBwYWdlU2l6ZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGFyc2VkSlNPTi5uZXh0UGFnZVRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmZXRjaE5leHRQYWdlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLml0ZW1zICYmIGRhdGEucGFyc2VkSlNPTi5wYWdlSW5mby50b3RhbFJlc3VsdHMgPiBkYXRhLnBhcnNlZEpTT04ucGFnZUluZm8ucmVzdWx0c1BlclBhZ2UgKiArK3BhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW1zKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGEucGFyc2VkSlNPTiAmJiBkYXRhLnBhcnNlZEpTT04uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5wYXJzZWRKU09OLml0ZW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYoc3Vic2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkVXNlciA9IHVzZXJzLmZpbmQoKHVzcikgPT4gdXNyLmxvZ2luID09PSBjaC5sb2dpbik7XG4gICAgICAgICAgICAgICAgICAgIGNoLmlkID0gb2xkVXNlci5pZDtcbiAgICAgICAgICAgICAgICAgICAgY2guZmF2b3JpdGVzID0gc3Vic2NyaXB0aW9ucy5tYXAoKHN1YikgPT4gc3ViLnNuaXBwZXQucmVzb3VyY2VJZC5jaGFubmVsSWQpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwidXBkYXRlZHVzZXJcIiwgY2gpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0KHRoaXMsIFwibmV3Y2hhbm5lbHNcIiwgc3Vic2NyaXB0aW9ucy5maWx0ZXIoKGZvbGxvdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFvbGRVc2VyLmZhdm9yaXRlcy5zb21lKChmYXYpID0+IGZhdiA9PT0gZm9sbG93LnNuaXBwZXQucmVzb3VyY2VJZC5jaGFubmVsSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KS5tYXAoKHN1YikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gbmV3IENoYW5uZWwoc3ViLnNuaXBwZXQucmVzb3VyY2VJZC5jaGFubmVsSWQsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LmFyY2hpdmVVcmwgPSBcImh0dHBzOi8veW91dHViZS5jb20vY2hhbm5lbC9cIiArIGNoLmxvZ2luICsgXCIvdmlkZW9zXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuY2hhdFVybCA9IFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2gubG9naW4gKyBcIi9kaXNjdXNzaW9uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI4OFwiOiBzdWIuc25pcHBldC50aHVtYm5haWxzLmRlZmF1bHQudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiMjQwXCI6IHN1Yi5zbmlwcGV0LnRodW1ibmFpbHMuaGlnaC51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQudW5hbWUgPSBzdWIuc25pcHBldC50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICBvbGRVc2VyLmZhdm9yaXRlcyA9IGNoLmZhdm9yaXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdG9kbyBTb21ldGltZXMgbmVlZHMgb0F1dGggZm9yIHNvbWUgcmVhc29uLCBJIGd1ZXNzIHByaXZhY3kgc2V0dGluZ3MuICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbid0IGdldCBmYXZvcml0ZXMgZm9yIHlvdXR1YmUgdXNlciBcIiArIGNoLnVuYW1lICsgXCIgd2l0aG91dCBvQXV0aCBhcyBzb21lYm9keSB3aXRoIHJlYWRpbmcgcmlnaHRzIG9mIHRoaXMgdXNlcidzIHN1YnMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVJlcXVlc3QoY2hhbm5lbHMpIHtcbiAgICAgICAgbGV0IG9mZmxpbmVDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGlkcyA9IFtdLFxuICAgICAgICAgICAgdXJscyA9IGF3YWl0IFByb21pc2UuYWxsKGNoYW5uZWxzLm1hcChhc3luYyAoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVVJMICsgXCJzZWFyY2g/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0OiBcImlkXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZDogY2hhbm5lbC5sb2dpbixcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBcIml0ZW1zKGlkL3ZpZGVvSWQpXCIsXG4gICAgICAgICAgICAgICAgICAgIG1heFJlc3VsdHM6IDEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogXCJsaXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBhd2FpdCBhcGlLZXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGdldExpdmVTdHJlYW1zID0gYXN5bmMgKGlkcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvcyA9IGF3YWl0IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJ2aWRlb3M/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0OiBcImlkLCBzbmlwcGV0LCBsaXZlU3RyZWFtaW5nRGV0YWlsc1wiLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWRzLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IFwiaXRlbXMoaWQsc25pcHBldChjaGFubmVsSWQsdGl0bGUsdGh1bWJuYWlscy9tZWRpdW0vdXJsLGNhdGVnb3J5SWQpLGxpdmVTdHJlYW1pbmdEZXRhaWxzL2NvbmN1cnJlbnRWaWV3ZXJzKVwiLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGF3YWl0IGFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgaGw6IGdldExvY2FsZSgpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmKHZpZGVvcy5wYXJzZWRKU09OICYmIHZpZGVvcy5wYXJzZWRKU09OLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2aWRlb3MucGFyc2VkSlNPTi5pdGVtcy5tYXAoKHZpZGVvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2F0ZWdvcnkodmlkZW8uc25pcHBldC5jYXRlZ29yeUlkKS50aGVuKChjYXRlZ29yeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVscy5maW5kKChjaGFubmVsKSA9PiBjaGFubmVsLmxvZ2luID09IHZpZGVvLnNuaXBwZXQuY2hhbm5lbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnVybCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL3lvdXR1YmUuY29tL3dhdGNoP3Y9XCIgKyB2aWRlby5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL2dhbWluZy55b3V0dWJlLmNvbS93YXRjaD92PVwiICsgdmlkZW8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2hhbm5lbC5sb2dpbiArIFwiL2xpdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL2dhbWluZy55b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2hhbm5lbC5sb2dpbiArIFwiL2xpdmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC50aXRsZSA9IHZpZGVvLnNuaXBwZXQudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC50aHVtYm5haWwgPSB2aWRlby5zbmlwcGV0LnRodW1ibmFpbHMubWVkaXVtLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnZpZXdlcnMgPSB2aWRlby5saXZlU3RyZWFtaW5nRGV0YWlscy5jb25jdXJyZW50Vmlld2VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJDb3VsZCBub3QgZmluZCB0aGUgZ2l2ZW4gc3RyZWFtXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmUgPSAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZihpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZsaW5lQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoaWRzLmxlbmd0aCArIG9mZmxpbmVDb3VudCA9PSBjaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TGl2ZVN0cmVhbXMoaWRzLmpvaW4oXCIsXCIpKS50aGVuKChjaGFucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBjaGFucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vVE9ETyB0aGVyZSBzaG91bGQgYmUgYSB3YXkgdG8gZG8gdGhpcyB3aXRoIGEgZ2VuZXJhdG9yLlxuXG4gICAgICAgIHRoaXMuX3FzLnF1ZXVlVXBkYXRlUmVxdWVzdCh1cmxzLCB0aGlzLl9xcy5ISUdIX1BSSU9SSVRZLCAoZGF0YSwgdXJsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsTG9naW4gPSB1cmwubWF0Y2goL2NoYW5uZWxJZD0oW1xcdy1dKyk/Ji8pWzFdLFxuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVscy5maW5kKChjaGFubmVsKSA9PiBjaGFubmVsTG9naW4gPT0gY2hhbm5lbC5sb2dpbik7XG4gICAgICAgICAgICBpZihkYXRhLnBhcnNlZEpTT04gJiYgZGF0YS5wYXJzZWRKU09OLml0ZW1zICYmIGRhdGEucGFyc2VkSlNPTi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lKGRhdGEucGFyc2VkSlNPTi5pdGVtc1swXS5pZC52aWRlb0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLnVybCA9IFsgXCJodHRwczovL3lvdXR1YmUuY29tL2NoYW5uZWwvXCIgKyBjaGFubmVsLmxvZ2luIF07XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcInVwZGF0ZWRjaGFubmVsc1wiLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDaGFubmVsKGNoYW5uZWxsb2dpbikge1xuICAgICAgICBjb25zdCBbIGNoLCByZXNwb25zZSBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fZ2V0Q2hhbm5lbEJ5SWQoY2hhbm5lbGxvZ2luKSxcbiAgICAgICAgICAgIGFwaUtleS50aGVuKChrZXkpID0+IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJzZWFyY2g/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHBhcnQ6IFwiaWRcIixcbiAgICAgICAgICAgICAgICBjaGFubmVsSWQ6IGNoYW5uZWxsb2dpbixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFwiaXRlbXMoaWQvdmlkZW9JZClcIixcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiAxLFxuICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogXCJsaXZlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgfSkpKVxuICAgICAgICBdKTtcblxuICAgICAgICBpZihyZXNwb25zZS5wYXJzZWRKU09OICYmIHJlc3BvbnNlLnBhcnNlZEpTT04uaXRlbXMpIHtcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlLnBhcnNlZEpTT04uaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2gubGl2ZS5zZXRMaXZlKHRydWUpO1xuICAgICAgICAgICAgICAgIGNoLnVybC5wdXNoKFwiaHR0cHM6Ly95b3V0dWJlLmNvbS93YXRjaD92PVwiICsgcmVzcG9uc2UucGFyc2VkSlNPTi5pdGVtc1swXS5pZC52aWRlb0lkKTtcbiAgICAgICAgICAgICAgICBjaC51cmwucHVzaChcImh0dHBzOi8vZ2FtaW5nLnlvdXR1YmUuY29tL3dhdGNoP3Y9XCIgKyByZXNwb25zZS5wYXJzZWRKU09OLml0ZW1zWzBdLmlkLnZpZGVvSWQpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwidmlkZW9zP1wiICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgcGFydDogXCJzbmlwcGV0LCBsaXZlU3RyZWFtaW5nRGV0YWlsc1wiLFxuICAgICAgICAgICAgICAgICAgICBpZDogcmVzcG9uc2UucGFyc2VkSlNPTi5pdGVtc1swXS5pZC52aWRlb0lkLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IFwiaXRlbXMoc25pcHBldChjYXRlZ29yeUlkLHRpdGxlLHRodW1ibmFpbHMvbWVkaXVtL3VybCksbGl2ZVN0cmVhbWluZ0RldGFpbHMvY29uY3VycmVudFZpZXdlcnMpXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICBobDogZ2V0TG9jYWxlKClcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYodmlkZW8ucGFyc2VkSlNPTiAmJiB2aWRlby5wYXJzZWRKU09OLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoLnRpdGxlID0gdmlkZW8ucGFyc2VkSlNPTi5pdGVtc1swXS5zbmlwcGV0LnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBjaC50aHVtYm5haWwgPSB2aWRlby5wYXJzZWRKU09OLml0ZW1zWzBdLnNuaXBwZXQudGh1bWJuYWlscy5tZWRpdW0udXJsO1xuICAgICAgICAgICAgICAgICAgICBjaC52aWV3ZXJzID0gdmlkZW8ucGFyc2VkSlNPTi5pdGVtc1swXS5saXZlU3RyZWFtaW5nRGV0YWlscy5jb25jdXJyZW50Vmlld2VycztcbiAgICAgICAgICAgICAgICAgICAgY2guY2F0ZWdvcnkgPSBhd2FpdCB0aGlzLl9nZXRDYXRlZ29yeSh2aWRlby5wYXJzZWRKU09OLml0ZW1zWzBdLnNuaXBwZXQuY2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2gubGl2ZS5zZXRMaXZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjaC51cmwucHVzaChcImh0dHBzOi8veW91dHViZS5jb20vY2hhbm5lbC9cIiArIGNoLmxvZ2luKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUNoYW5uZWxzKGNoYW5uZWxzKSB7XG4gICAgICAgIGxldCBzdHJlYW1JZHMgPSBhd2FpdCBQcm9taXNlLmFsbChjaGFubmVscy5tYXAoYXN5bmMgKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcInNlYXJjaD9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcGFydDogXCJpZFwiLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxJZDogY2hhbm5lbC5sb2dpbixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFwiaXRlbXMoaWQvdmlkZW9JZClcIixcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiAxLFxuICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogXCJsaXZlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZighcmVzcG9uc2UucGFyc2VkSlNPTiB8fCAhcmVzcG9uc2UucGFyc2VkSlNPTi5pdGVtcyB8fCAhcmVzcG9uc2UucGFyc2VkSlNPTi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmxpdmUuc2V0TGl2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC51cmwgPSBbIFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2hhbm5lbC5sb2dpbiBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBhcnNlZEpTT04uaXRlbXNbMF0uaWQudmlkZW9JZDtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHN0cmVhbUlkcyA9IHN0cmVhbUlkcy5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gbnVsbCk7XG5cbiAgICAgICAgY29uc3QgdmlkZW9zID0gYXdhaXQgdGhpcy5fcXMucXVldWVSZXF1ZXN0KGJhc2VVUkwgKyBcInZpZGVvcz9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwYXJ0OiBcImlkLCBzbmlwcGV0LCBsaXZlU3RyZWFtaW5nRGV0YWlsc1wiLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkcy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgIGZpZWxkczogXCJpdGVtcyhpZCxzbmlwcGV0KGNoYW5uZWxJZCx0aXRsZSx0aHVtYm5haWxzL21lZGl1bS91cmwsY2F0ZWdvcnlJZCksbGl2ZVN0cmVhbWluZ0RldGFpbHMvY29uY3VycmVudFZpZXdlcnMpXCIsXG4gICAgICAgICAgICBrZXk6IGF3YWl0IGFwaUtleSxcbiAgICAgICAgICAgIGhsOiBnZXRMb2NhbGUoKVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYodmlkZW9zLnBhcnNlZEpTT04gJiYgdmlkZW9zLnBhcnNlZEpTT04uaXRlbXMpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHZpZGVvcy5wYXJzZWRKU09OLml0ZW1zLm1hcCgodmlkZW8pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2F0ZWdvcnkodmlkZW8uc25pcHBldC5jYXRlZ29yeUlkKS50aGVuKChjYXRlZ29yeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHMuZmluZCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5sb2dpbiA9PSB2aWRlby5zbmlwcGV0LmNoYW5uZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnVybCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly95b3V0dWJlLmNvbS93YXRjaD92PVwiICsgdmlkZW8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vZ2FtaW5nLnlvdXR1YmUuY29tL3dhdGNoP3Y9XCIgKyB2aWRlby5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly95b3V0dWJlLmNvbS9jaGFubmVsL1wiICsgY2hhbm5lbC5sb2dpbiArIFwiL2xpdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9nYW1pbmcueW91dHViZS5jb20vY2hhbm5lbC9cIiArIGNoYW5uZWwubG9naW4gKyBcIi9saXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC50aXRsZSA9IHZpZGVvLnNuaXBwZXQudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwudGh1bWJuYWlsID0gdmlkZW8uc25pcHBldC50aHVtYm5haWxzLm1lZGl1bS51cmw7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwudmlld2VycyA9IHZpZGVvLmxpdmVTdHJlYW1pbmdEZXRhaWxzLmNvbmN1cnJlbnRWaWV3ZXJzO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5uZWxzO1xuICAgIH1cbiAgICBhc3luYyBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9xcy5xdWV1ZVJlcXVlc3QoYmFzZVVSTCArIFwic2VhcmNoP1wiICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHBhcnQ6IFwiaWRcIixcbiAgICAgICAgICAgIGZpZWxkczogXCJpdGVtcyhpZC92aWRlb0lkKVwiLFxuICAgICAgICAgICAgZXZlbnRUeXBlOiBcImxpdmVcIixcbiAgICAgICAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgICAgICAgIG9yZGVyOiBcInJlbGV2YW5jZVwiLFxuICAgICAgICAgICAgcmVsZXZhbmNlTGFuZ3VhZ2U6IGJyb3dzZXIuaTE4bi5nZXRVSUxhbmd1YWdlKCkuc3Vic3RyKDAsIDIpLFxuICAgICAgICAgICAgc2FmZVNlYXJjaDogKGF3YWl0IHRoaXMuX21hdHVyZSgpKSA/IFwibW9kZXJhdGVcIiA6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICBxOiBxdWVyeSxcbiAgICAgICAgICAgIGtleTogYXdhaXQgYXBpS2V5XG4gICAgICAgIH0pKTtcblxuICAgICAgICBsZXQgc3RyZWFtSWRzO1xuICAgICAgICBpZihyZXNwb25zZS5wYXJzZWRKU09OICYmIHJlc3BvbnNlLnBhcnNlZEpTT04uaXRlbXMgJiYgcmVzcG9uc2UucGFyc2VkSlNPTi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbUlkcyA9IHJlc3BvbnNlLnBhcnNlZEpTT04uaXRlbXMubWFwKChlbnRyeSkgPT4gZW50cnkuaWQudmlkZW9JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vIHNlYXJjaCByZXN1bHRzIGZvdW5kIGZvciBcIiArIHRoaXMubmFtZSArIFwiIHdpdGggXCIgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZpZGVvcyA9IGF3YWl0IHRoaXMuX3FzLnF1ZXVlUmVxdWVzdChiYXNlVVJMICsgXCJ2aWRlb3M/XCIgKyBxdWVyeXN0cmluZy5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGFydDogXCJpZCxzbmlwcGV0LGxpdmVTdHJlYW1pbmdEZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHN0cmVhbUlkcy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFwiaXRlbXMoaWQsc25pcHBldChjaGFubmVsSWQsdGl0bGUsdGh1bWJuYWlscy9tZWRpdW0vdXJsLGNhdGVnb3J5SWQpLGxpdmVTdHJlYW1pbmdEZXRhaWxzL2NvbmN1cnJlbnRWaWV3ZXJzKVwiLFxuICAgICAgICAgICAgICAgIGtleTogKGF3YWl0IGFwaUtleSksXG4gICAgICAgICAgICAgICAgaGw6IGdldExvY2FsZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICApKTtcblxuICAgICAgICBpZih2aWRlb3MucGFyc2VkSlNPTiAmJiB2aWRlb3MucGFyc2VkSlNPTi5pdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZpZGVvcy5wYXJzZWRKU09OLml0ZW1zLm1hcChhc3luYyAodmlkZW8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgdGhpcy5fZ2V0Q2hhbm5lbEJ5SWQodmlkZW8uc25pcHBldC5jaGFubmVsSWQpO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubGl2ZS5zZXRMaXZlKHRydWUpO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudXJsID0gW1xuICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8veW91dHViZS5jb20vd2F0Y2g/dj1cIiArIHZpZGVvLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vZ2FtaW5nLnlvdXR1YmUuY29tL3dhdGNoP3Y9XCIgKyB2aWRlby5pZFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2hhbm5lbC50aXRsZSA9IHZpZGVvLnNuaXBwZXQudGl0bGU7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC50aHVtYm5haWwgPSB2aWRlby5zbmlwcGV0LnRodW1ibmFpbHMubWVkaXVtLnVybDtcbiAgICAgICAgICAgICAgICBpZihcImxpdmVTdHJlYW1pbmdEZXRhaWxzXCIgaW4gdmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC52aWV3ZXJzID0gdmlkZW8ubGl2ZVN0cmVhbWluZ0RldGFpbHMuY29uY3VycmVudFZpZXdlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2F0ZWdvcnkgPSBhd2FpdCB0aGlzLl9nZXRDYXRlZ29yeSh2aWRlby5zbmlwcGV0LmNhdGVnb3J5SWQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBcIk5vbmUgb2YgdGhlIHNlYXJjaHJlc3VsdHMgZXhpc3QgZm9yIFwiICsgdGhpcy5uYW1lO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShuZXcgWW91VHViZSh0eXBlKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmFja2dyb3VuZC9wcm92aWRlcnMveW91dHViZS5qcyIsIi8qKlxuICogUXVldWUgaW5mcmFzdHJ1Y3R1cmUgZm9yIHVwZGF0aW5nIGluZm9cbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIHF1ZXVlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICdldmVudC10YXJnZXQtc2hpbSc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gZXh0ZXJuYWw6c2RrL3JlcXVlc3QuUmVxdWVzdE9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvU0RLL0hpZ2gtTGV2ZWxfQVBJcy9yZXF1ZXN0I1JlcXVlc3QlMjhvcHRpb25zJTI5fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2V4dGVybmFsOnNkay9yZXF1ZXN0LlJlcXVlc3RPcHRpb25zfSBSZXF1ZXN0SW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkXG4gKi9cbi8qKlxuICogQGNsYXNzIG1vZHVsZTpxdWV1ZS5SZXF1ZXN0UXVldWVcbiAqIEBleHRlbmRzIGV4dGVybmFsOkV2ZW50VGFyZ2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3RRdWV1ZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICAvKipcbiAgICAgKiBJRCBvZiB0aGUgcXVldWUgaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyP31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbGFybU5hbWUgPSBcIm1haW4tcXVldWVcIjtcbiAgICAvKipcbiAgICAgKiBMYXN0IElEIGFzc2lnbmVkIHRvIGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbGFzdElEID0gLTE7XG4gICAgLyoqXG4gICAgICogVGltZSBpbnRlcnZhbCBiZXR3ZWVuIGZldGNoZWQgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBpbnRlcnZhbCA9IDA7XG4gICAgYW1vdW50ID0gMC41O1xuICAgIG1heFNpemUgPSAxMDtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0UXVldWUgT2JqZWN0LlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHthcnJheS48bW9kdWxlOnF1ZXVlflJlcXVlc3RJbmZvPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuXG4gICAgICAgIGJyb3dzZXIuYWxhcm1zLm9uQWxhcm0uYWRkTGlzdGVuZXIoKGFsYXJtKSA9PiB7XG4gICAgICAgICAgICBpZihhbGFybS5uYW1lID09IHRoaXMuX2FsYXJtTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCgxLCBNYXRoLm1pbih0aGlzLnF1ZXVlLmxlbmd0aCAqIHRoaXMuYW1vdW50LCB0aGlzLm1heFNpemUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFJlcXVlc3RCYXRjaChzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlcXVlc3QgdG8gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtleHRlcm5hbDpzZGsvcmVxdWVzdC5SZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdGlvbnMgLSBPcHRpb25zIGZvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBJRCBvZiB0aGUgYWRkZWQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhZGRSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChPYmplY3QuYXNzaWduKHsgaWQ6ICsrdGhpcy5sYXN0SUQsIG1ldGhvZDogXCJHRVRcIiB9LCByZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIGluZGV4IGluIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSByZXF1ZXN0IHRvIGZldGNoLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0UmVxdWVzdChpbmRleCkge1xuICAgICAgICBjb25zdCBzcGVjID0gdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICBmZXRjaChzcGVjLnVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogc3BlYy5oZWFkZXJzLFxuICAgICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25DbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICByZXR1cm4ganNvbkNsb25lLmpzb24oKS50aGVuKChqc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyc2VkSlNPTiA9IGpzb247XG4gICAgICAgICAgICAgICAgc3BlYy5vbkNvbXBsZXRlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uQ29tcGxldGUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICBpZihzcGVjLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3BlYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHF1ZXJ5IC0gSUQgb3IgVVJMIG9mIHRoZSByZXF1ZXN0IHRvIGZldGNoLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0UmVxdWVzdEJ5SWQocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVxdWVzdCh0aGlzLmdldFJlcXVlc3RJbmRleChxdWVyeSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBtdWx0aXBsZSByZXF1ZXN0cyBmcm9tIHRoZSB0b3Agb2YgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiYXRjaFNpemU9dGhpcy5xdWV1ZS5sZW5ndGhdIC0gTnVtYmVyIG9mIHJlcXVlc3RzIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldFJlcXVlc3RCYXRjaChiYXRjaFNpemUgPSB0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpZihiYXRjaFNpemUgPiB0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gdGhpcy5xdWV1ZS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmF0Y2hTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVxdWVzdCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgYW4gaW50ZXJ2YWwgdG8gZmV0Y2ggYSBjZXJ0YWluIGFtb3VudCBvZiByZXF1ZXN0cyBwZXJpb2RpY2FsbHkuXG4gICAgICogQ2FuIGFsc28gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIC0gSW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBBIHBlcmNlbnRhZ2Ugb2YgcmVxdWVzdHMgdG8gZ2V0IHBlciBiYXRjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U2l6ZSAtIFRoZSBtYXggbnVtYmVyIG9mIHJlcXVlc3RzIHRvIGdldCBwZXIgYmF0Y2guXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBhc3luYyBhdXRvRmV0Y2goaW50ZXJ2YWwsIGFtb3VudCwgbWF4U2l6ZSkge1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgICAgICBpZih0aGlzLndvcmtpbmdPblF1ZXVlKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IGJyb3dzZXIuYWxhcm1zLmNsZWFyKHRoaXMuX2FsYXJtTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICBicm93c2VyLmFsYXJtcy5jcmVhdGUodGhpcy5fYWxhcm1OYW1lLCB7XG4gICAgICAgICAgICAgICAgcGVyaW9kSW5NaW51dGVzOiBpbnRlcnZhbCAvIDYwMDAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHJlcXVlc3RzIGFuZCBvbmdvaW5nIGludGVydmFscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmKHRoaXMud29ya2luZ09uUXVldWUoKSkge1xuICAgICAgICAgICAgYnJvd3Nlci5hbGFybXMuY2xlYXIodGhpcy5fYWxhcm1OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsID0gMDtcbiAgICAgICAgaWYodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSByZXF1ZXN0IGlzIHN0aWxsIGluIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcXVlcnkgLSBJRCBvciBVUkwgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdldGhlciB0aGUgcmVxdWVzdCBpcyBzdGlsbCBxdWV1ZWQuXG4gICAgICovXG4gICAgcmVxdWVzdFF1ZXVlZChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0SW5kZXgocXVlcnkpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBxdWVyeSAtIElEIG9yIFVSTCBvZiB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBJbmRleCBvZiB0aGUgcmVxdWVzdC4gLTEgaWYgdGhlIHJlcXVlc3QgY291bGRuJ3QgYmVcbiAgICAgKiBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SW5kZXgocXVlcnkpIHtcbiAgICAgICAgaWYodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuZmluZEluZGV4KChyZXEpID0+IHJlcS51cmwgPT09IHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHR5cGVvZiBxdWVyeSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmZpbmRJbmRleCgocmVxKSA9PiByZXEuaWQgPT09IHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGVyaWRvaWNhbGx5IGZldGNoaW5nIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlcmUgaXMgYW4gaW50ZXJ2YWwgc2V0IHVwLlxuICAgICAqL1xuICAgIHdvcmtpbmdPblF1ZXVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcXVlcnkgLSBJRCBvciBVUkwgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSByZXF1ZXN0IGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlUmVxdWVzdChxdWVyeSkge1xuICAgICAgICBpZih0aGlzLnJlcXVlc3RRdWV1ZWQocXVlcnkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltRdWV1ZV0+IHJlbW92aW5nIHJlcXVlc3RcIik7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNwbGljZSh0aGlzLmdldFJlcXVlc3RJbmRleChxdWVyeSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL3F1ZXVlL2luZGV4LmpzIiwiLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1wYXJhbSAqL1xuLyoqXG4gKiBAYXV0aG9yIE1hcnRpbiBHaWdlclxuICogQGxpY2Vuc2UgTVBMLTIuMFxuICogQG1vZHVsZSBxdWV1ZS9wYXVzZWFibGVcbiAqIEByZXF1aXJlcyBtb2R1bGU6cXVldWVcbiAqL1xuaW1wb3J0IFJlcXVlc3RRdWV1ZSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFF1ZXVlT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVydmFsIC0gSW50ZXJ2YWwgdG8gZmV0Y2ggYmF0Y2hlcyBpbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbW91bnQgLSBQZXJjZW50YWdlIG9mIHRoZSBxdWV1ZSB0byBmZXRjaCBwZXIgYmF0Y2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2l6ZSAtIE1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIHBlciBiYXRjaC5cbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6cXVldWUvcGF1c2VhYmxlLlBhdXNlYWJsZVF1ZXVlI3BhdXNlXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTpxdWV1ZS9wYXVzZWFibGUuUGF1c2VhYmxlUXVldWUjcmVzdW1lXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG1vZHVsZTpxdWV1ZS5SZXF1ZXN0UXVldWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF1c2VhYmxlUXVldWUgZXh0ZW5kcyBSZXF1ZXN0UXVldWUge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgX2NvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBQYXVzZWFibGUgcXVldWUsIHBhdXNlcyBiYXNlZCBvbiB0aGUgbmV0d29yayBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0c1xuICAgICAqIEBleHRlbmRzIG1vZHVsZTpxdWV1ZS5SZXF1ZXN0UXVldWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTpxdWV1ZS9wYXVzZWFibGV+UXVldWVPcHRpb25zP31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXVlU3RhdGUgPSB7fTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgKCkgPT4gdGhpcy5wYXVzZSgpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsICgpID0+IHRoaXMucmVzdW1lKCksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXV0b0ZldGNoKGludGVydmFsLCBhbW91bnQgPSB0aGlzLl9xdWV1ZVN0YXRlLmFtb3VudCwgbWF4U2l6ZSA9IHRoaXMuX3F1ZXVlU3RhdGUubWF4U2l6ZSkge1xuICAgICAgICBpZihpbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICAgIG1heFNpemVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9jb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihuYXZpZ2F0b3Iub25MaW5lIHx8IGludGVydmFsID09PSAwKSB7XG4gICAgICAgICAgICBzdXBlci5hdXRvRmV0Y2goaW50ZXJ2YWwsIGFtb3VudCwgbWF4U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJpbHkgaGFsdCBleGVjdXRpb24gb2YgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQGZpcmVzIG1vZHVsZTpxdWV1ZS9wYXVzZWFibGUuUGF1c2VhYmxlUXVldWUjcGF1c2VcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICBpZih0aGlzLl9jb25maWd1cmVkICYmIHRoaXMuaW50ZXJ2YWwgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0ZldGNoKDApO1xuICAgICAgICAgICAgZW1pdCh0aGlzLCBcInBhdXNlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAZmlyZXMgbW9kdWxlOnF1ZXVlL3BhdXNlYWJsZS5QYXVzZWFibGVRdWV1ZSNyZXN1bWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYodGhpcy5fY29uZmlndXJlZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvRmV0Y2godGhpcy5fcXVldWVTdGF0ZS5pbnRlcnZhbCk7XG4gICAgICAgICAgICBlbWl0KHRoaXMsIFwicmVzdW1lXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcXVldWUvcGF1c2VhYmxlLmpzIiwiLyoqXG4gKiBRdWV1ZSB3aXRoIHByaW9yaXplZCwgcGVyc2lzdGFudCBhbmQgbGVzcyBvZnRlbiBmZXRjaGVkIHJlcXVlc3RzLlxuICpcbiAqIEBhdXRob3IgTWFydGluIEdpZ2VyXG4gKiBAbGljZW5zZSBNUEwtMi4wXG4gKiBAbW9kdWxlIHF1ZXVlL3VwZGF0ZVxuICogQHJlcXVpcmVzIG1vZHVsZTpxdWV1ZS9wYXVzZWFibGVcbiAqL1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IFBhdXNlYWJsZVF1ZXVlIGZyb20gXCIuL3BhdXNlYWJsZVwiO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlcmUgaXMgYSBuZXcgcHJpb3JpemVkIGl0ZW0gYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICpcbiAqIEBldmVudCBtb2R1bGU6cXVldWUvdXBkYXRlLlVwZGF0ZVF1ZXVlI3F1ZXVlcHJpb3JpemVkXG4gKi9cbi8qKlxuICogRmlyZWQgd2hlbiBhbGwgcHJpb3JpemVkIGl0ZW1zIGluIHRoZSBxdWV1ZSB3ZXJlIGZldGNoZWQuXG4gKlxuICogQGV2ZW50IG1vZHVsZTpxdWV1ZS91cGRhdGUuVXBkYXRlUXVldWUjYWxscHJpb3JpemVkbG9hZGVkXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgbW9kdWxlOnF1ZXVlL3VwZGF0ZS5VcGRhdGVRdWV1ZVxuICogQGV4dGVuZHMgbW9kdWxlOnF1ZXVlL3BhdXNlYWJsZS5QYXVzZWFibGVRdWV1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGRhdGVRdWV1ZSBleHRlbmRzIFBhdXNlYWJsZVF1ZXVlIHtcbiAgICAvKipcbiAgICAgKiBBIHF1ZXVlIHdpdGggcHJpb3JpemVkLCBwZXJzaXN0ZW50IGFuZCBsZXNzIG9mdGVuIGZldGNoZWQgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSByZXF1ZXN0IHRvIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXh0ZXJuYWw6c2RrL3JlcXVlc3QuUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RBcmdzIC0gUmVxdXN0IEFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwZXJzaXN0ZW50PWZhbHNlXSAtIElmIHRoZSByZXF1ZXN0IHNob3VsZCBiZSByZWFkZGVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBxdWV1ZSB3aGVuZXZlciBpdCB3YXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmlvcml6ZWQ9ZmFsc2VdIC0gSWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIHByaW9yaXplZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXIgb3RoZXIgcmVxdWVzdHMgaW4gdGhlIHF1ZXVlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBub3QgYmUgdHJ1ZSB3aGVuIHRoZSByZXF1ZXN0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGVyc2lzdGVudCBhbmQgbm90IHNraXBwaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpcD0wXSAtIE51bWJlciBvZiB0aW1lcyB0byBza2lwIHRoaXMgcmVxdWVzdCBiZWZvcmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGluZyBpdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0IGlkLlxuICAgICAqIEBmaXJlcyBtb2R1bGU6cXVldWUvdXBkYXRlLlVwZGF0ZVF1ZXVlI3F1ZXVlcHJpb3JpemVkXG4gICAgICovXG4gICAgYWRkUmVxdWVzdChyZXF1ZXN0QXJncywgcGVyc2lzdGVudCA9IGZhbHNlLCBwcmlvcml6ZWQgPSBmYWxzZSwgc2tpcCA9IDApIHtcbiAgICAgICAgLy8gb25seSBhbGxvdyBwcmlvcml6ZWQgaWYgaXRzIGVpdGhlciBub3QgYSBwZXJzaXN0ZW50IHJlcXVlc3Qgb3IgaXQgc2tpcHNcbiAgICAgICAgLy8gc2tpcHBpbmcgcmVxdWVzdHMgYXJlIG9ubHkgcHJpb3JpemVkIGZvciB0aGUgZmlyc3QgdGltZSB0aGUgYXJlIGFjdHVhbGx5IHNlbnRcbiAgICAgICAgLy8gaG93ZXZlciB0aGV5IHdpbGwgdGhlIGZpcnN0IHRpbWUgbm90IHNraXAuXG4gICAgICAgIHByaW9yaXplZCA9IHByaW9yaXplZCAmJiAoIXBlcnNpc3RlbnQgfHwgc2tpcCA+IDApO1xuXG4gICAgICAgIGlmKCF0aGlzLmNvbnRhaW5zUHJpb3JpemVkKCkgJiYgcHJpb3JpemVkKSB7XG4gICAgICAgICAgICBlbWl0KHRoaXMsIFwicXVldWVwcmlvcml6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZFJlcXVlc3QoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBwZXJzaXN0OiBwZXJzaXN0ZW50LFxuICAgICAgICAgICAgcHJpb3JpemU6IHByaW9yaXplZCxcbiAgICAgICAgICAgIHNraXAsXG4gICAgICAgICAgICBza2lwcGVkOiAwXG4gICAgICAgIH0sIHJlcXVlc3RBcmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIG11bHRpcGxlIHJlcXVlc3RzIGZyb20gdGhlIHRvcCBvZiB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBJbmRleCBvZiB0aGUgcmVxdWVzdCB0byBmZXRjaC5cbiAgICAgKiBAZmlyZXMgbW9kdWxlOnF1ZXVlL3VwZGF0ZS5VcGRhdGVRdWV1ZSNhbGxwcmlvcml6ZWRsb2FkZWRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldFJlcXVlc3QoaW5kZXgpIHtcbiAgICAgICAgaWYodGhpcy5nZXRGaXJzdFByaW9yaXplZCgpKSB7XG4gICAgICAgICAgICBpZighdGhpcy5jb250YWluc1ByaW9yaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgZW1pdCh0aGlzLCBcImFsbHByaW9yaXplZGxvYWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVxdWVzdEJ5SW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBmaXJzdCBwcmlvcml6ZWQgcmVxdWVzdCBpbiB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgYSBwcmlvcml6ZWQgcmVxdWVzdCB3YXMgZmV0Y2hlZC5cbiAgICAgKi9cbiAgICBnZXRGaXJzdFByaW9yaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuc29tZSgocmVxLCBpKSA9PiB7XG4gICAgICAgICAgICBpZihyZXEucHJpb3JpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFJlcXVlc3RCeUluZGV4KGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIHJlcXVlc3QgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gSW5kZXggaW4gdGhlIHF1ZXVlIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0UmVxdWVzdEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKHRoaXMucXVldWUubGVuZ3RoICsgXCIgam9icyBsZWZ0IGluIHRoZSBxdWV1ZS5cIik7XG4gICAgICAgIGlmKHRoaXMucXVldWVbaW5kZXhdLnNraXAgPiB0aGlzLnF1ZXVlW2luZGV4XS5za2lwcGVkICYmXG4gICAgICAgICAgICF0aGlzLnF1ZXVlW2luZGV4XS5wcmlvcml6ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUXVldWVdPiBTa2lwcGluZyBcIiArIHRoaXMucXVldWVbaW5kZXhdLnVybCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlW2luZGV4XS5za2lwcGVkKys7XG5cbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSlbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUXVldWVdPiBHZXR0aW5nIFwiICsgdGhpcy5xdWV1ZVtpbmRleF0udXJsKTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gc3VwZXIuZ2V0UmVxdWVzdChpbmRleCk7XG4gICAgICAgICAgICBpZihyZXEucGVyc2lzdCkge1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwbGljYXRpb24gb2YgdGhlIHNraXBwaW5nIGxvZ2ljIGluIHRoZSBhZGRSZXF1ZXN0IG1ldGhvZFxuICAgICAgICAgICAgICAgIGlmKHJlcS5za2lwID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXEuc2tpcHBlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlcS5wcmlvcml6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnByaW9yaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcXVldWUgaGFzIGEgcHJpb3JpemVkIHJlcXVlc3Qgd2FpdGluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZXJlIGlzIGEgcHJpb3JpemVkIHJlcXVlc3QgaW4gdGhlIHF1ZXVlLlxuICAgICAqL1xuICAgIGNvbnRhaW5zUHJpb3JpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5zb21lKChpdGVtKSA9PiBpdGVtLnByaW9yaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIHByaW9yaXplZCByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIEBmaXJlcyBtb2R1bGU6cXVldWUvdXBkYXRlLlVwZGF0ZVF1ZXVlI2FsbHByaW9yaXplZGxvYWRlZFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0QWxsUHJpb3JpemVkKCkge1xuICAgICAgICB0aGlzLnF1ZXVlLmZpbHRlcigocmVxKSA9PiByZXEucHJpb3JpemUpLmZvckVhY2goKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nZXRGaXJzdFByaW9yaXplZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1pdCh0aGlzLCBcImFsbHByaW9yaXplZGxvYWRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBzdXBlci5yZXN1bWUoKTtcbiAgICAgICAgaWYodGhpcy5jb250YWluc1ByaW9yaXplZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEFsbFByaW9yaXplZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2JhY2tncm91bmQvcXVldWUvdXBkYXRlLmpzIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZTY0bWFwXG4gICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcblxuICBjcnlwdCA9IHtcbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiBsZWZ0XG4gICAgcm90bDogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8IGIpIHwgKG4gPj4+ICgzMiAtIGIpKTtcbiAgICB9LFxuXG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gcmlnaHRcbiAgICByb3RyOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgKDMyIC0gYikpIHwgKG4gPj4+IGIpO1xuICAgIH0sXG5cbiAgICAvLyBTd2FwIGJpZy1lbmRpYW4gdG8gbGl0dGxlLWVuZGlhbiBhbmQgdmljZSB2ZXJzYVxuICAgIGVuZGlhbjogZnVuY3Rpb24obikge1xuICAgICAgLy8gSWYgbnVtYmVyIGdpdmVuLCBzd2FwIGVuZGlhblxuICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdC5yb3RsKG4sIDgpICYgMHgwMEZGMDBGRiB8IGNyeXB0LnJvdGwobiwgMjQpICYgMHhGRjAwRkYwMDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxzZSwgYXNzdW1lIGFycmF5IGFuZCBzd2FwIGFsbCBpdGVtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgICAgICBuW2ldID0gY3J5cHQuZW5kaWFuKG5baV0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIGFueSBsZW5ndGggb2YgcmFuZG9tIGJ5dGVzXG4gICAgcmFuZG9tQnl0ZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW107IG4gPiAwOyBuLS0pXG4gICAgICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGJpZy1lbmRpYW4gMzItYml0IHdvcmRzXG4gICAgYnl0ZXNUb1dvcmRzOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgd29yZHMgPSBbXSwgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOClcbiAgICAgICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBiaWctZW5kaWFuIDMyLWJpdCB3b3JkcyB0byBhIGJ5dGUgYXJyYXlcbiAgICB3b3Jkc1RvQnl0ZXM6IGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpXG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAgICBieXRlc1RvSGV4OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBoZXhUb0J5dGVzOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZS02NCBzdHJpbmdcbiAgICBieXRlc1RvQmFzZTY0OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgYmFzZTY0ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPD0gYnl0ZXMubGVuZ3RoICogOClcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopKSAmIDB4M0YpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiYXNlNjQucHVzaCgnPScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJhc2UtNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGJhc2U2NFRvQnl0ZXM6IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgLy8gUmVtb3ZlIG5vbi1iYXNlLTY0IGNoYXJhY3RlcnNcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2lnLCAnJyk7XG5cbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwLCBpbW9kNCA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoO1xuICAgICAgICAgIGltb2Q0ID0gKytpICUgNCkge1xuICAgICAgICBpZiAoaW1vZDQgPT0gMCkgY29udGludWU7XG4gICAgICAgIGJ5dGVzLnB1c2goKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICYgKE1hdGgucG93KDIsIC0yICogaW1vZDQgKyA4KSAtIDEpKSA8PCAoaW1vZDQgKiAyKSlcbiAgICAgICAgICAgIHwgKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpID4+PiAoNiAtIGltb2Q0ICogMikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcnlwdDtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3J5cHQvY3J5cHQuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYVxuICogQGNvcHlyaWdodCAyMDE1IFRvcnUgTmFnYXNoaW1hLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU2VlIExJQ0VOU0UgZmlsZSBpbiByb290IGRpcmVjdG9yeSBmb3IgZnVsbCBsaWNlbnNlLlxuICovXG5cInVzZSBzdHJpY3RcIlxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIENvbW1vbnMgPSByZXF1aXJlKFwiLi9jb21tb25zXCIpXG52YXIgTElTVEVORVJTID0gQ29tbW9ucy5MSVNURU5FUlNcbnZhciBBVFRSSUJVVEUgPSBDb21tb25zLkFUVFJJQlVURVxudmFyIG5ld05vZGUgPSBDb21tb25zLm5ld05vZGVcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEdldHMgYSBzcGVjaWZpZWQgYXR0cmlidXRlIGxpc3RlbmVyIGZyb20gYSBnaXZlbiBFdmVudFRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgLSBBbiBFdmVudFRhcmdldCBvYmplY3QgdG8gZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBBbiBldmVudCB0eXBlIHRvIGdldC5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbnxudWxsfSBUaGUgZm91bmQgYXR0cmlidXRlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVMaXN0ZW5lcihldmVudFRhcmdldCwgdHlwZSkge1xuICAgIHZhciBub2RlID0gZXZlbnRUYXJnZXRbTElTVEVORVJTXVt0eXBlXVxuICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUua2luZCA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5saXN0ZW5lclxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBTZXRzIGEgc3BlY2lmaWVkIGF0dHJpYnV0ZSBsaXN0ZW5lciB0byBhIGdpdmVuIEV2ZW50VGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCAtIEFuIEV2ZW50VGFyZ2V0IG9iamVjdCB0byBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEFuIGV2ZW50IHR5cGUgdG8gc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBsaXN0ZW5lciAtIEEgbGlzdGVuZXIgdG8gYmUgc2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZUxpc3RlbmVyKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgbGlzdGVuZXIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IG51bGxcbiAgICB2YXIgbm9kZSA9IGV2ZW50VGFyZ2V0W0xJU1RFTkVSU11bdHlwZV1cbiAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLmtpbmQgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldFtMSVNURU5FUlNdW3R5cGVdID0gbm9kZS5uZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgfVxuXG4gICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICBpZiAobGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJldiA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudFRhcmdldFtMSVNURU5FUlNdW3R5cGVdID0gbmV3Tm9kZShsaXN0ZW5lciwgQVRUUklCVVRFKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZShsaXN0ZW5lciwgQVRUUklCVVRFKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWMgSW50ZXJmYWNlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogRGVmaW5lcyBhbiBgRXZlbnRUYXJnZXRgIGltcGxlbWVudGF0aW9uIHdoaWNoIGhhcyBgb25mb29iYXJgIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gRXZlbnRUYXJnZXRCYXNlIC0gQSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIEV2ZW50VGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gdHlwZXMgLSBBIGxpc3Qgb2YgZXZlbnQgdHlwZXMgd2hpY2ggYXJlIGRlZmluZWQgYXMgYXR0cmlidXRlIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudFRhcmdldH0gVGhlIGRlZmluZWQgYEV2ZW50VGFyZ2V0YCBpbXBsZW1lbnRhdGlvbiB3aGljaCBoYXMgYXR0cmlidXRlIGxpc3RlbmVycy5cbiAqL1xubW9kdWxlLmV4cG9ydHMuZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQgPSBmdW5jdGlvbihFdmVudFRhcmdldEJhc2UsIHR5cGVzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIGN1c3RvbSBldmVudCB0YXJnZXQuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIEV2ZW50VGFyZ2V0QmFzZS5jYWxsKHRoaXMpXG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0ZXIgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9XG5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgZGVzY3JpcHRlcltcIm9uXCIgKyB0eXBlXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZUxpc3RlbmVyKHRoaXMsIHR5cGUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZUxpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgRXZlbnRUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldEJhc2UucHJvdG90eXBlLCBkZXNjcmlwdGVyKVxuXG4gICAgcmV0dXJuIEV2ZW50VGFyZ2V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXZlbnQtdGFyZ2V0LXNoaW0vbGliL2N1c3RvbS1ldmVudC10YXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYVxuICogQGNvcHlyaWdodCAyMDE1IFRvcnUgTmFnYXNoaW1hLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU2VlIExJQ0VOU0UgZmlsZSBpbiByb290IGRpcmVjdG9yeSBmb3IgZnVsbCBsaWNlbnNlLlxuICovXG5cInVzZSBzdHJpY3RcIlxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNyZWF0ZVVuaXF1ZUtleSA9IHJlcXVpcmUoXCIuL2NvbW1vbnNcIikuY3JlYXRlVW5pcXVlS2V5XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENvbnN0c250c1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRoZSBrZXkgb2YgdGhlIGZsYWcgd2hpY2ggaXMgdHVybmVkIG9uIGJ5IGBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25gIG1ldGhvZC5cbiAqXG4gKiBAdHlwZSB7c3ltYm9sfHN0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBTVE9QX0lNTUVESUFURV9QUk9QQUdBVElPTl9GTEFHID1cbiAgICBjcmVhdGVVbmlxdWVLZXkoXCJzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbl9mbGFnXCIpXG5cbi8qKlxuICogVGhlIGtleSBvZiB0aGUgZmxhZyB3aGljaCBpcyB0dXJuZWQgb24gYnkgYHByZXZlbnREZWZhdWx0YCBtZXRob2QuXG4gKlxuICogQHR5cGUge3N5bWJvbHxzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQ0FOQ0VMRURfRkxBRyA9IGNyZWF0ZVVuaXF1ZUtleShcImNhbmNlbGVkX2ZsYWdcIilcblxuLyoqXG4gKiBUaGUga2V5IG9mIHRoZSBmbGFnIHRoYXQgaXQgY2Fubm90IHVzZSBgcHJldmVudERlZmF1bHRgIG1ldGhvZC5cbiAqXG4gKiBAdHlwZSB7c3ltYm9sfHN0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBQQVNTSVZFX0xJU1RFTkVSX0ZMQUcgPSBjcmVhdGVVbmlxdWVLZXkoXCJwYXNzaXZlX2xpc3RlbmVyX2ZsYWdcIilcblxuLyoqXG4gKiBUaGUga2V5IG9mIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKlxuICogQHR5cGUge3N5bWJvbHxzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgT1JJR0lOQUxfRVZFTlQgPSBjcmVhdGVVbmlxdWVLZXkoXCJvcmlnaW5hbF9ldmVudFwiKVxuXG4vKipcbiAqIE1ldGhvZCBkZWZpbml0aW9ucyBmb3IgdGhlIGV2ZW50IHdyYXBwZXIuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB3cmFwcGVyUHJvdG90eXBlRGVmaW5pdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0b3BQcm9wYWdhdGlvbjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXNbT1JJR0lOQUxfRVZFTlRdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUuc3RvcFByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSksXG5cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IE9iamVjdC5mcmVlemUoe1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgdGhpc1tTVE9QX0lNTUVESUFURV9QUk9QQUdBVElPTl9GTEFHXSA9IHRydWVcblxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzW09SSUdJTkFMX0VWRU5UXVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pLFxuXG4gICAgcHJldmVudERlZmF1bHQ6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tQQVNTSVZFX0xJU1RFTkVSX0ZMQUddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tDQU5DRUxFRF9GTEFHXSA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzW09SSUdJTkFMX0VWRU5UXVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KSxcblxuICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tDQU5DRUxFRF9GTEFHXVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSksXG59KVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWMgSW50ZXJmYWNlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzLlNUT1BfSU1NRURJQVRFX1BST1BBR0FUSU9OX0ZMQUcgPSBTVE9QX0lNTUVESUFURV9QUk9QQUdBVElPTl9GTEFHXG5tb2R1bGUuZXhwb3J0cy5QQVNTSVZFX0xJU1RFTkVSX0ZMQUcgPSBQQVNTSVZFX0xJU1RFTkVSX0ZMQUdcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IHdyYXBwZXIuXG4gKlxuICogV2UgY2Fubm90IG1vZGlmeSBzZXZlcmFsIHByb3BlcnRpZXMgb2YgYEV2ZW50YCBvYmplY3QsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSB3cmFwcGVyLlxuICogUGx1cywgdGhpcyB3cmFwcGVyIHN1cHBvcnRzIG5vbiBgRXZlbnRgIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtFdmVudHx7dHlwZTogc3RyaW5nfX0gZXZlbnQgLSBBbiBvcmlnaW5hbCBldmVudCB0byBjcmVhdGUgdGhlIHdyYXBwZXIuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCAtIFRoZSBldmVudCB0YXJnZXQgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0V2ZW50fSBUaGUgY3JlYXRlZCB3cmFwcGVyLiBUaGlzIG9iamVjdCBpcyBpbXBsZW1lbnRlZCBgRXZlbnRgIGludGVyZmFjZS5cbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUV2ZW50V3JhcHBlciA9IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50V3JhcHBlcihldmVudCwgZXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGltZVN0YW1wID0gKFxuICAgICAgICB0eXBlb2YgZXZlbnQudGltZVN0YW1wID09PSBcIm51bWJlclwiID8gZXZlbnQudGltZVN0YW1wIDogRGF0ZS5ub3coKVxuICAgIClcbiAgICB2YXIgcHJvcGVydHlEZWZpbml0aW9uID0ge1xuICAgICAgICB0eXBlOiB7dmFsdWU6IGV2ZW50LnR5cGUsIGVudW1lcmFibGU6IHRydWV9LFxuICAgICAgICB0YXJnZXQ6IHt2YWx1ZTogZXZlbnRUYXJnZXQsIGVudW1lcmFibGU6IHRydWV9LFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiB7dmFsdWU6IGV2ZW50VGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlfSxcbiAgICAgICAgZXZlbnRQaGFzZToge3ZhbHVlOiAyLCBlbnVtZXJhYmxlOiB0cnVlfSxcbiAgICAgICAgYnViYmxlczoge3ZhbHVlOiBCb29sZWFuKGV2ZW50LmJ1YmJsZXMpLCBlbnVtZXJhYmxlOiB0cnVlfSxcbiAgICAgICAgY2FuY2VsYWJsZToge3ZhbHVlOiBCb29sZWFuKGV2ZW50LmNhbmNlbGFibGUpLCBlbnVtZXJhYmxlOiB0cnVlfSxcbiAgICAgICAgdGltZVN0YW1wOiB7dmFsdWU6IHRpbWVTdGFtcCwgZW51bWVyYWJsZTogdHJ1ZX0sXG4gICAgICAgIGlzVHJ1c3RlZDoge3ZhbHVlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZX0sXG4gICAgfVxuICAgIHByb3BlcnR5RGVmaW5pdGlvbltTVE9QX0lNTUVESUFURV9QUk9QQUdBVElPTl9GTEFHXSA9IHt2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlfVxuICAgIHByb3BlcnR5RGVmaW5pdGlvbltDQU5DRUxFRF9GTEFHXSA9IHt2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlfVxuICAgIHByb3BlcnR5RGVmaW5pdGlvbltQQVNTSVZFX0xJU1RFTkVSX0ZMQUddID0ge3ZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWV9XG4gICAgcHJvcGVydHlEZWZpbml0aW9uW09SSUdJTkFMX0VWRU5UXSA9IHt2YWx1ZTogZXZlbnR9XG5cbiAgICAvLyBGb3IgQ3VzdG9tRXZlbnQuXG4gICAgaWYgKHR5cGVvZiBldmVudC5kZXRhaWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcHJvcGVydHlEZWZpbml0aW9uLmRldGFpbCA9IHt2YWx1ZTogZXZlbnQuZGV0YWlsLCBlbnVtZXJhYmxlOiB0cnVlfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgICAgICBPYmplY3QuY3JlYXRlKGV2ZW50LCB3cmFwcGVyUHJvdG90eXBlRGVmaW5pdGlvbiksXG4gICAgICAgIHByb3BlcnR5RGVmaW5pdGlvblxuICAgIClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ldmVudC10YXJnZXQtc2hpbS9saWIvZXZlbnQtd3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzLWJ1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uKCl7XHJcbiAgdmFyIGNyeXB0ID0gcmVxdWlyZSgnY3J5cHQnKSxcclxuICAgICAgdXRmOCA9IHJlcXVpcmUoJ2NoYXJlbmMnKS51dGY4LFxyXG4gICAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpLFxyXG4gICAgICBiaW4gPSByZXF1aXJlKCdjaGFyZW5jJykuYmluLFxyXG5cclxuICAvLyBUaGUgY29yZVxyXG4gIG1kNSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGUgYXJyYXlcclxuICAgIGlmIChtZXNzYWdlLmNvbnN0cnVjdG9yID09IFN0cmluZylcclxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpXHJcbiAgICAgICAgbWVzc2FnZSA9IGJpbi5zdHJpbmdUb0J5dGVzKG1lc3NhZ2UpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWVzc2FnZSA9IHV0Zjguc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgIGVsc2UgaWYgKGlzQnVmZmVyKG1lc3NhZ2UpKVxyXG4gICAgICBtZXNzYWdlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZSwgMCk7XHJcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgIC8vIGVsc2UsIGFzc3VtZSBieXRlIGFycmF5IGFscmVhZHlcclxuXHJcbiAgICB2YXIgbSA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcclxuICAgICAgICBsID0gbWVzc2FnZS5sZW5ndGggKiA4LFxyXG4gICAgICAgIGEgPSAgMTczMjU4NDE5MyxcclxuICAgICAgICBiID0gLTI3MTczMzg3OSxcclxuICAgICAgICBjID0gLTE3MzI1ODQxOTQsXHJcbiAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gICAgLy8gU3dhcCBlbmRpYW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtW2ldID0gKChtW2ldIDw8ICA4KSB8IChtW2ldID4+PiAyNCkpICYgMHgwMEZGMDBGRiB8XHJcbiAgICAgICAgICAgICAoKG1baV0gPDwgMjQpIHwgKG1baV0gPj4+ICA4KSkgJiAweEZGMDBGRjAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhZGRpbmdcclxuICAgIG1bbCA+Pj4gNV0gfD0gMHg4MCA8PCAobCAlIDMyKTtcclxuICAgIG1bKCgobCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsO1xyXG5cclxuICAgIC8vIE1ldGhvZCBzaG9ydGN1dHNcclxuICAgIHZhciBGRiA9IG1kNS5fZmYsXHJcbiAgICAgICAgR0cgPSBtZDUuX2dnLFxyXG4gICAgICAgIEhIID0gbWQ1Ll9oaCxcclxuICAgICAgICBJSSA9IG1kNS5faWk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xyXG5cclxuICAgICAgdmFyIGFhID0gYSxcclxuICAgICAgICAgIGJiID0gYixcclxuICAgICAgICAgIGNjID0gYyxcclxuICAgICAgICAgIGRkID0gZDtcclxuXHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDBdLCAgNywgLTY4MDg3NjkzNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDcsIC0xNzY0MTg4OTcpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgOF0sICA3LCAgMTc3MDAzNTQxNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDcsICAxODA0NjAzNjgyKTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyAxXSwgIDUsIC0xNjU3OTY1MTApO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyA2XSwgIDksIC0xMDY5NTAxNjMyKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgNV0sICA1LCAtNzAxNTU4NjkxKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxMF0sICA5LCAgMzgwMTYwODMpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA5XSwgIDUsICA1Njg0NDY0MzgpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzE0XSwgIDksIC0xMDE5ODAzNjkwKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyAyXSwgIDksIC01MTQwMzc4NCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDVdLCAgNCwgLTM3ODU1OCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKzEzXSwgIDQsICA2ODEyNzkxNzQpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDYsIC0xOTg2MzA4NDQpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgNF0sICA2LCAtMTQ1NTIzMDcwKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgICBhID0gKGEgKyBhYSkgPj4+IDA7XHJcbiAgICAgIGIgPSAoYiArIGJiKSA+Pj4gMDtcclxuICAgICAgYyA9IChjICsgY2MpID4+PiAwO1xyXG4gICAgICBkID0gKGQgKyBkZCkgPj4+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyeXB0LmVuZGlhbihbYSwgYiwgYywgZF0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEF1eGlsaWFyeSBmdW5jdGlvbnNcclxuICBtZDUuX2ZmICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGMgfCB+YiAmIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2dnICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGQgfCBjICYgfmQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2hoICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9paSAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG5cclxuICAvLyBQYWNrYWdlIHByaXZhdGUgYmxvY2tzaXplXHJcbiAgbWQ1Ll9ibG9ja3NpemUgPSAxNjtcclxuICBtZDUuX2RpZ2VzdHNpemUgPSAxNjtcclxuXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQgJyArIG1lc3NhZ2UpO1xyXG5cclxuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhtZDUobWVzc2FnZSwgb3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxyXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XHJcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZDUvbWQ1LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgU0RLIGZyb20gXCIuL3Nka1wiO1xuaW1wb3J0IHsgc2VsZWN0T3JPcGVuVGFiIH0gZnJvbSBcIi4vY2hhbm5lbC91dGlsc1wiO1xuaW1wb3J0IENoYW5uZWxDb250cm9sbGVyIGZyb20gXCIuL2NoYW5uZWwvY29udHJvbGxlclwiO1xuaW1wb3J0IHByZWZzIGZyb20gJy4vcHJlZmVyZW5jZXMnO1xuaW1wb3J0IExpdmVTdGF0ZSBmcm9tICcuL2NoYW5uZWwvbGl2ZS1zdGF0ZSc7XG5pbXBvcnQgTGlzdFZpZXcgZnJvbSAnLi9saXN0JztcbmltcG9ydCBzZXJpYWxpemVkUHJvdmlkZXJzIGZyb20gXCIuL3Byb3ZpZGVycy9zZXJpYWxpemVkXCI7XG5pbXBvcnQgKiBhcyBxcyBmcm9tICcuL3F1ZXVlL3NlcnZpY2UnO1xuaW1wb3J0IE5vdGlmaWVyIGZyb20gXCIuL25vdGlmaWVyXCI7XG5cbmNvbnN0IFNfVE9fTVNfRkFDVE9SID0gMTAwMCxcblxuLy8gSW5pdCB0aGluZ3NcbiAgICBub3RpZmllciA9IG5ldyBOb3RpZmllcigpLFxuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ2hhbm5lbENvbnRyb2xsZXIoKSxcbiAgICBsaXN0ID0gbmV3IExpc3RWaWV3KCk7XG5cbmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5XCIsICgpID0+IHtcbiAgICBjb250cm9sbGVyLmdldENoYW5uZWxzQnlUeXBlKClcbiAgICAgICAgLnRoZW4oKGNoYW5uZWxzKSA9PiBsaXN0LmFkZENoYW5uZWxzKGNoYW5uZWxzKSk7XG5cbiAgICBsaXN0LnNldFByb3ZpZGVycyhzZXJpYWxpemVkUHJvdmlkZXJzKTtcblxuICAgIHByZWZzLmdldChbXG4gICAgICAgIFwidXBkYXRlSW50ZXJ2YWxcIixcbiAgICAgICAgXCJwYW5lbF9zdHlsZVwiLFxuICAgICAgICBcInBhbmVsX2V4dHJhc1wiLFxuICAgICAgICBcInRoZW1lXCJcbiAgICBdKS50aGVuKChbIHVwZGF0ZUludGVydmFsLCBzdHlsZSwgZXh0cmFzLCB0aGVtZSBdKSA9PiB7XG4gICAgICAgIGxpc3Quc2V0UXVldWVTdGF0dXMocGFyc2VJbnQodXBkYXRlSW50ZXJ2YWwsIDEwKSAhPT0gMCk7XG4gICAgICAgIGxpc3Quc2V0U3R5bGUocGFyc2VJbnQoc3R5bGUsIDEwKSk7XG4gICAgICAgIGxpc3Quc2V0RXh0cmFzVmlzaWJpbGl0eShleHRyYXMpO1xuICAgICAgICBsaXN0LnNldFRoZW1lKHBhcnNlSW50KHRoZW1lLCAxMCkpO1xuICAgIH0pO1xufSk7XG5cbmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5jbVwiLCAoKSA9PiBjb250cm9sbGVyLnNob3dNYW5hZ2VyKCkpO1xubGlzdC5hZGRFdmVudExpc3RlbmVyKFwiYWRkY2hhbm5lbFwiLCAoeyBkZXRhaWw6IFsgbG9naW4sIHR5cGUgXSB9KSA9PiB7XG4gICAgY29udHJvbGxlci5hZGRDaGFubmVsKGxvZ2luLCB0eXBlKTtcbn0pO1xubGlzdC5hZGRFdmVudExpc3RlbmVyKFwicmVmcmVzaFwiLCAoeyBkZXRhaWw6IGNoYW5uZWxJZCB9KSA9PiB7XG4gICAgaWYoY2hhbm5lbElkKSB7XG4gICAgICAgIGNvbnRyb2xsZXIudXBkYXRlQ2hhbm5lbChjaGFubmVsSWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci51cGRhdGVDaGFubmVscygpO1xuICAgIH1cbn0pO1xubGlzdC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoeyBkZXRhaWw6IFsgY2hhbm5lbElkLCB3aGF0IF0gfSkgPT4ge1xuICAgIGxldCBwO1xuICAgIGlmKHR5cGVvZiBjaGFubmVsSWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcCA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB1cmw6IFsgY2hhbm5lbElkIF0sXG4gICAgICAgICAgICBsaXZlOiBuZXcgTGl2ZVN0YXRlKExpdmVTdGF0ZS5MSVZFKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHAgPSBjb250cm9sbGVyLmdldENoYW5uZWwoY2hhbm5lbElkKTtcbiAgICB9XG5cbiAgICBwLnRoZW4oKGNoYW5uZWwpID0+IHNlbGVjdE9yT3BlblRhYihjaGFubmVsLCB3aGF0KSk7XG59KTtcbmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsICgpID0+IHFzLnBhdXNlKCkpO1xubGlzdC5hZGRFdmVudExpc3RlbmVyKFwicmVzdW1lXCIsICgpID0+IHFzLnJlc3VtZSgpKTtcbmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgKHsgZGV0YWlsOiBbIGNoYW5uZWwsIHR5cGUgXSB9KSA9PiB7XG4gICAgY29udHJvbGxlci5jb3B5Q2hhbm5lbFVSTChjaGFubmVsLCB0eXBlKS50aGVuKChjaGFubmVsKSA9PiB7XG4gICAgICAgIG5vdGlmaWVyLm5vdGlmeUNvcGllZChjaGFubmVsLnVuYW1lKTtcbiAgICB9KTtcbn0pO1xuXG4vLyBXaXJlIHRoaW5ncyB1cFxuXG5ub3RpZmllci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKHsgZGV0YWlsOiBjaGFubmVsSWQgfSkgPT4ge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCBjb250cm9sbGVyLmdldENoYW5uZWwoY2hhbm5lbElkKTtcbiAgICBzZWxlY3RPck9wZW5UYWIoY2hhbm5lbCk7XG59KTtcblxuY29udHJvbGxlci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbm5lbHVwZGF0ZWRcIiwgKHsgZGV0YWlsOiBjaGFubmVsIH0pID0+IHtcbiAgICBub3RpZmllci5zZW5kTm90aWZpY2F0aW9uKGNoYW5uZWwpO1xuICAgIGxpc3Qub25DaGFubmVsQ2hhbmdlZChjaGFubmVsKTtcbn0pO1xuXG5jb250cm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFubmVsc2FkZGVkXCIsICh7IGRldGFpbDogY2hhbm5lbHMgfSkgPT4ge1xuICAgIGxpc3QuYWRkQ2hhbm5lbHMoY2hhbm5lbHMpO1xuICAgIGNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IG5vdGlmaWVyLnNlbmROb3RpZmljYXRpb24oY2hhbm5lbCkpO1xufSk7XG5cbmNvbnRyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5uZWxkZWxldGVkXCIsICh7IGRldGFpbDogY2hhbm5lbElkIH0pID0+IHtcbiAgICBub3RpZmllci5vbkNoYW5uZWxSZW1vdmVkKGNoYW5uZWxJZCk7XG4gICAgbGlzdC5yZW1vdmVDaGFubmVsKGNoYW5uZWxJZCk7XG59KTtcblxuY29udHJvbGxlci5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlY2hhbm5lbGRlbGV0ZWRcIiwgKCkgPT4gcXMucGF1c2UoKSk7XG4vL1RPRE8gZG8gY291bnRpbmcgaW5zdGVhZCBvZiByZWx5aW5nIG9uIHJhbmRvbW5lc3MgYmVpbmcgaW4gb3VyIGZhdm9yIDspXG5jb250cm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhZnRlcmNoYW5uZWxkZWxldGVkXCIsICgpID0+IHFzLnJlc3VtZSgpKTtcblxucHJlZnMuZ2V0KFtcbiAgICBcInRoZW1lXCIsXG4gICAgXCJwYW5lbF9ub25saXZlXCIsXG4gICAgXCJ1cGRhdGVJbnRlcnZhbFwiLFxuICAgIFwicXVldWVfcmF0aW9cIixcbiAgICBcInF1ZXVlX21heFJlcXVlc3RCYXRjaFNpemVcIlxuXSkudGhlbigoW1xuICAgIHRoZW1lLFxuICAgIG5vbmxpdmUsXG4gICAgaW50ZXJ2YWwsXG4gICAgcmF0aW8sXG4gICAgYmF0Y2hTaXplXG5dKSA9PiB7XG4gICAgY29udHJvbGxlci5zZXRUaGVtZShwYXJzZUludCh0aGVtZSwgMTApKTtcbiAgICBsaXN0LnNldE5vbkxpdmVEaXNwbGF5KG5vbmxpdmUpO1xuICAgIHFzLnNldE9wdGlvbnMoe1xuICAgICAgICBpbnRlcnZhbDogU19UT19NU19GQUNUT1IgKiBpbnRlcnZhbCxcbiAgICAgICAgYW1vdW50OiAxIC8gcmF0aW8sXG4gICAgICAgIG1heFNpemU6IGJhdGNoU2l6ZVxuICAgIH0pO1xufSk7XG5cbnFzLmFkZExpc3RlbmVycyh7XG4gICAgcGF1c2VkOiAoKSA9PiBsaXN0LnNldFF1ZXVlUGF1c2VkKHRydWUpLFxuICAgIHJlc3VtZWQ6ICgpID0+IGxpc3Quc2V0UXVldWVQYXVzZWQoZmFsc2UpXG59KTtcblxucHJlZnMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoeyBkZXRhaWw6IHsgcHJlZiwgdmFsdWUgfSB9KSA9PiB7XG4gICAgaWYocHJlZiA9PSBcIm1hbmFnZUNoYW5uZWxzXCIpIHtcbiAgICAgICAgY29udHJvbGxlci5zaG93TWFuYWdlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmKHByZWYgPT0gXCJ0aGVtZVwiKSB7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgY29udHJvbGxlci5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICAgIGxpc3Quc2V0VGhlbWUodGhlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmKHByZWYgPT0gXCJwYW5lbF9ub25saXZlXCIpIHtcbiAgICAgICAgbGlzdC5zZXROb25MaXZlRGlzcGxheShwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgZWxzZSBpZihwcmVmID09IFwicGFuZWxfZXh0cmFzXCIpIHtcbiAgICAgICAgbGlzdC5zZXRFeHRyYXNWaXNpYmlsaXR5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZihwcmVmID09IFwicGFuZWxfc3R5bGVcIikge1xuICAgICAgICBsaXN0LnNldFN0eWxlKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICBlbHNlIGlmKHByZWYgPT0gXCJ1cGRhdGVJbnRlcnZhbFwiKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgcXMudXBkYXRlT3B0aW9ucyhTX1RPX01TX0ZBQ1RPUiAqIGludGVydmFsKTtcbiAgICAgICAgbGlzdC5zZXRRdWV1ZVN0YXR1cyhpbnRlcnZhbCAhPT0gMCk7XG4gICAgfVxufSk7XG5cbi8vIERvIG1pZ3JhdGlvbiBvZiBjaGFubmVsIGRhdGEgaWYgbmVjZXNzYXJ5XG5icm93c2VyLnN0b3JhZ2UubG9jYWwuZ2V0KFwibWlncmF0ZWRcIikudGhlbigodmFsdWUpID0+IHtcbiAgICBpZighdmFsdWUubWlncmF0ZWQpIHtcbiAgICAgICAgU0RLLmRvQWN0aW9uKFwibWlncmF0ZS1jaGFubmVsc1wiKS50aGVuKChbIGNoYW5uZWxzLCB1c2VycyBdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodXNlcnMubWFwKCh1c2VyKSA9PiBjb250cm9sbGVyLmFkZFVzZXIodXNlci5sb2dpbiwgdXNlci50eXBlKSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5hbGwoY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjb250cm9sbGVyLmFkZENoYW5uZWwoY2hhbm5lbC5sb2dpbiwgY2hhbm5lbC50eXBlKSkpKTtcbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgICAgICAgICAgICAgbWlncmF0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==